[{"st": 0, "ed": 2, "text": "Formal Verification"}, {"st": 3, "ed": 5, "text": "Safety Properties"}, {"st": 6, "ed": 10, "text": "Ownership Authentication Transfer Protocol"}]
[{"st": 10, "ed": 12, "text": "valuable information"}, {"st": 46, "ed": 48, "text": "private data"}, {"st": 58, "ed": 60, "text": "user data"}, {"st": 64, "ed": 66, "text": "user privacy"}, {"st": 73, "ed": 76, "text": "ownership authentication transfer"}, {"st": 110, "ed": 112, "text": "old owner"}, {"st": 166, "ed": 168, "text": "impersonation attack"}, {"st": 177, "ed": 179, "text": "basic process"}, {"st": 181, "ed": 185, "text": "ownership authentication transfer protocol"}, {"st": 188, "ed": 190, "text": "safety properties"}, {"st": 207, "ed": 211, "text": "symbolic model checker tool"}, {"st": 215, "ed": 217, "text": "safety properties"}, {"st": 218, "ed": 221, "text": "ownership transfer protocol"}, {"st": 227, "ed": 229, "text": "CTL specification"}, {"st": 239, "ed": 241, "text": "protocol constraint"}]
[{"st": 0, "ed": 2, "text": "Expressive Completeness"}, {"st": 3, "ed": 6, "text": "Metric Temporal Logic"}]
[{"st": 0, "ed": 3, "text": "Metric Temporal Logic"}, {"st": 10, "ed": 13, "text": "Linear Temporal Logic"}, {"st": 26, "ed": 28, "text": "metric constraints"}, {"st": 30, "ed": 32, "text": "seminal result"}, {"st": 44, "ed": 46, "text": "order logic"}, {"st": 47, "ed": 51, "text": "binary order relation <"}, {"st": 52, "ed": 54, "text": "unary function"}, {"st": 63, "ed": 65, "text": "integer constants"}, {"st": 71, "ed": 73, "text": "temporal logic"}, {"st": 81, "ed": 83, "text": "quantifier depth"}, {"st": 97, "ed": 99, "text": "surprising result"}, {"st": 103, "ed": 105, "text": "unary functions"}, {"st": 109, "ed": 111, "text": "q rational"}, {"st": 116, "ed": 118, "text": "order logic"}, {"st": 120, "ed": 123, "text": "allow rational constants"}, {"st": 132, "ed": 135, "text": "same expressive power"}, {"st": 139, "ed": 141, "text": "first generalisation"}, {"st": 147, "ed": 149, "text": "expressive completeness"}, {"st": 158, "ed": 160, "text": "quantitative setting"}]
[{"st": 4, "ed": 6, "text": "State Reachability"}]
[{"st": 0, "ed": 2, "text": "Efficient implementations"}, {"st": 3, "ed": 5, "text": "atomic objects"}, {"st": 7, "ed": 9, "text": "concurrent stacks"}, {"st": 19, "ed": 22, "text": "necessitate automatic verification"}, {"st": 25, "ed": 27, "text": "correctness criteria"}, {"st": 33, "ed": 35, "text": "ADT specifications"}, {"st": 48, "ed": 52, "text": "usual temporal safety properties"}, {"st": 55, "ed": 57, "text": "state reachability"}, {"st": 73, "ed": 77, "text": "certain fixed ADT specifications"}, {"st": 82, "ed": 84, "text": "state reachability"}, {"st": 89, "ed": 91, "text": "arbitrary ADTs"}, {"st": 101, "ed": 104, "text": "popular atomic objects"}, {"st": 109, "ed": 112, "text": "first decidability results"}, {"st": 119, "ed": 121, "text": "concurrent threads"}, {"st": 132, "ed": 134, "text": "verification tools"}, {"st": 135, "ed": 137, "text": "linearizability verification"}]
[{"st": 1, "ed": 3, "text": "Diagnosability Analysis"}, {"st": 4, "ed": 6, "text": "Petri Nets"}]
[{"st": 6, "ed": 9, "text": "diagnos- ability analysis"}, {"st": 10, "ed": 12, "text": "concurrent systems"}, {"st": 14, "ed": 16, "text": "Petri nets"}, {"st": 23, "ed": 26, "text": "common observable transitions"}, {"st": 32, "ed": 34, "text": "several components"}, {"st": 36, "ed": 38, "text": "diagnosability analysis"}, {"st": 40, "ed": 42, "text": "entire system"}, {"st": 55, "ed": 58, "text": "fault free versions"}, {"st": 60, "ed": 62, "text": "other components"}, {"st": 68, "ed": 70, "text": "efficient methods"}, {"st": 74, "ed": 77, "text": "particular parallel LTL"}, {"st": 78, "ed": 80, "text": "X model"}, {"st": 86, "ed": 88, "text": "diagnosability verification"}]
[{"st": 1, "ed": 4, "text": "finite basis theorem"}, {"st": 10, "ed": 12, "text": "\\cal ALC}$"}]
[{"st": 1, "ed": 3, "text": "main result"}, {"st": 13, "ed": 15, "text": "finite basis"}, {"st": 21, "ed": 23, "text": "\\cal ALC}$."}, {"st": 29, "ed": 32, "text": "General Concept Inclusions"}, {"st": 38, "ed": 40, "text": "finite model"}, {"st": 43, "ed": 45, "text": "finite basis"}, {"st": 63, "ed": 65, "text": "previous result"}, {"st": 76, "ed": 78, "text": "finite basis"}, {"st": 83, "ed": 85, "text": "finite model"}, {"st": 88, "ed": 91, "text": "inexpressive description logics"}, {"st": 93, "ed": 95, "text": "\\cal EL}$"}, {"st": 98, "ed": 100, "text": "\\cal EL}_{gfp}$."}, {"st": 108, "ed": 110, "text": "finite basis"}, {"st": 123, "ed": 126, "text": "finite basis theorem"}, {"st": 129, "ed": 132, "text": "generated complete covariety"}, {"st": 140, "ed": 142, "text": "morphism domain"}, {"st": 151, "ed": 153, "text": "finite set"}, {"st": 154, "ed": 156, "text": "finite models"}]
[{"st": 1, "ed": 3, "text": "stratified regions"}]
[{"st": 2, "ed": 4, "text": "effect systems"}, {"st": 25, "ed": 28, "text": "called reducibility candidates"}, {"st": 30, "ed": 32, "text": "suitable stratification"}, {"st": 36, "ed": 38, "text": "effect system"}, {"st": 43, "ed": 45, "text": "typable programs"}, {"st": 47, "ed": 49, "text": "proof technique"}, {"st": 79, "ed": 81, "text": "interaction mechanisms"}]
[]
[{"st": 8, "ed": 10, "text": "alternation hierarchy"}, {"st": 11, "ed": 15, "text": "FO^2 [ < ]"}, {"st": 17, "ed": 19, "text": "2-variable fragment"}, {"st": 21, "ed": 24, "text": "first order logic"}, {"st": 41, "ed": 43, "text": "condensed rankers"}, {"st": 58, "ed": 60, "text": "decidable hierarchy"}, {"st": 68, "ed": 70, "text": "alternation hierarchy"}, {"st": 81, "ed": 83, "text": "latter hierarchy"}, {"st": 91, "ed": 93, "text": "formula alpha"}, {"st": 94, "ed": 98, "text": "FO^2 [ < ]"}, {"st": 104, "ed": 106, "text": "integer m"}, {"st": 129, "ed": 132, "text": "only m-1 blocks"}, {"st": 138, "ed": 140, "text": "precise result"}, {"st": 147, "ed": 149, "text": "alternation hierarchy"}, {"st": 150, "ed": 154, "text": "FO [ < ]"}, {"st": 157, "ed": 159, "text": "decidability result"}, {"st": 164, "ed": 166, "text": "first levels"}]
[{"st": 0, "ed": 2, "text": "Inconsistency Robustness"}, {"st": 3, "ed": 5, "text": "Logic Programs"}]
[{"st": 0, "ed": 2, "text": "Inconsistency robustness"}, {"st": 4, "ed": 7, "text": "information system performance"}, {"st": 12, "ed": 14, "text": "pervasive inconsistencies"}, {"st": 16, "ed": 19, "text": "A fundamental principle"}, {"st": 20, "ed": 22, "text": "Inconsistency Robustness"}, {"st": 44, "ed": 46, "text": "Inconsistency Robustness"}, {"st": 52, "ed": 54, "text": "Logic Programs"}, {"st": 55, "ed": 57, "text": "Robert Kowalski"}, {"st": 60, "ed": 62, "text": "bold thesis"}, {"st": 68, "ed": 70, "text": "early discoveries"}, {"st": 87, "ed": 89, "text": "mathematical logic"}, {"st": 93, "ed": 95, "text": "computational steps"}, {"st": 96, "ed": 98, "text": "computational systems"}, {"st": 114, "ed": 117, "text": "sent multiple messages"}, {"st": 120, "ed": 122, "text": "reception orders"}, {"st": 124, "ed": 126, "text": "general indeterminate"}, {"st": 133, "ed": 135, "text": "prior information"}, {"st": 136, "ed": 138, "text": "mathematical logic"}, {"st": 140, "ed": 143, "text": "Therefore mathematical logic"}, {"st": 146, "ed": 149, "text": "general implement computation"}, {"st": 157, "ed": 162, "text": "term \" Functional Program \""}, {"st": 174, "ed": 178, "text": "\" Logic Program \""}, {"st": 182, "ed": 184, "text": "similar trajectory"}, {"st": 187, "ed": 191, "text": "\" Logic Program \""}, {"st": 194, "ed": 197, "text": "general precise characterization"}, {"st": 204, "ed": 206, "text": "different characterizations"}, {"st": 207, "ed": 209, "text": "Logic Programs"}, {"st": 218, "ed": 220, "text": "Logic Program"}, {"st": 223, "ed": 225, "text": "Clause syntax"}, {"st": 232, "ed": 234, "text": "computational step"}, {"st": 237, "ed": 239, "text": "Actor Model"}, {"st": 242, "ed": 244, "text": "Logic Program"}, {"st": 250, "ed": 252, "text": "Direct Logic"}, {"st": 255, "ed": 257, "text": "above examples"}, {"st": 263, "ed": 265, "text": "inconsistency robustness"}, {"st": 269, "ed": 271, "text": "Logic Programs"}]
[{"st": 1, "ed": 4, "text": "Constructive Epistemic Logic"}, {"st": 5, "ed": 7, "text": "Public Announcement"}]
[{"st": 6, "ed": 9, "text": "epistemic \\emph{possible worlds"}, {"st": 24, "ed": 26, "text": "classic view"}, {"st": 45, "ed": 47, "text": "Epistemic Logic"}, {"st": 51, "ed": 53, "text": "predetermined possibilities"}, {"st": 57, "ed": 60, "text": "constructive epistemic logic"}, {"st": 64, "ed": 66, "text": "completeness theorems"}, {"st": 77, "ed": 80, "text": "public announcement operator"}, {"st": 95, "ed": 98, "text": "Surprise Exam Paradox"}, {"st": 105, "ed": 108, "text": "constructive epistemic logic"}]
[{"st": 0, "ed": 3, "text": "Monadic Datalog Containment"}]
[{"st": 13, "ed": 16, "text": "query containment problem"}, {"st": 17, "ed": 19, "text": "monadic datalog"}, {"st": 33, "ed": 35, "text": "unordered trees"}, {"st": 72, "ed": 75, "text": "query containment problem"}, {"st": 81, "ed": 84, "text": "2-fold exponential time"}, {"st": 92, "ed": 95, "text": "problems exact complexity"}, {"st": 104, "ed": 106, "text": "present paper"}]
[{"st": 5, "ed": 9, "text": "order Abstract Separation Logic"}]
[{"st": 7, "ed": 9, "text": "assertion language"}, {"st": 10, "ed": 12, "text": "separation logic"}, {"st": 18, "ed": 20, "text": "abstract semantics"}, {"st": 29, "ed": 31, "text": "program verification"}, {"st": 34, "ed": 36, "text": "concrete models"}, {"st": 44, "ed": 46, "text": "important element"}, {"st": 47, "ed": 49, "text": "concrete SL"}, {"st": 58, "ed": 60, "text": "singleton heap"}, {"st": 87, "ed": 89, "text": "order SL"}, {"st": 95, "ed": 97, "text": "abstracted version"}, {"st": 116, "ed": 118, "text": "abstract semantics"}, {"st": 122, "ed": 125, "text": "standard SL semantics"}, {"st": 134, "ed": 136, "text": "reasoning principles"}, {"st": 146, "ed": 148, "text": "FOASL theories"}, {"st": 159, "ed": 163, "text": "concrete program verification problems"}, {"st": 167, "ed": 169, "text": "example theories"}, {"st": 175, "ed": 177, "text": "different variants"}, {"st": 178, "ed": 180, "text": "separation logics"}, {"st": 202, "ed": 204, "text": "theorem prover"}, {"st": 210, "ed": 212, "text": "large fragment"}, {"st": 213, "ed": 215, "text": "separation logic"}, {"st": 216, "ed": 218, "text": "heap semantics"}, {"st": 223, "ed": 225, "text": "standard semantics"}]
[{"st": 2, "ed": 4, "text": "Fault Trees"}, {"st": 7, "ed": 9, "text": "order Logic"}, {"st": 11, "ed": 14, "text": "Deep Embedding Approach"}]
[{"st": 0, "ed": 2, "text": "Fault Tree"}, {"st": 7, "ed": 11, "text": "standard failure modeling technique"}, {"st": 24, "ed": 28, "text": "many complex engineering systems"}, {"st": 34, "ed": 36, "text": "formal analysis"}, {"st": 46, "ed": 48, "text": "logic formalization"}, {"st": 66, "ed": 68, "text": "large systems"}, {"st": 71, "ed": 73, "text": "FT models"}, {"st": 75, "ed": 79, "text": "corresponding Reliability Block Diagram"}, {"st": 93, "ed": 95, "text": "availability analyses"}, {"st": 106, "ed": 108, "text": "deep embedding"}, {"st": 126, "ed": 129, "text": "NOT FT gates"}, {"st": 140, "ed": 142, "text": "FT gates"}, {"st": 155, "ed": 157, "text": "majority Voting"}, {"st": 160, "ed": 162, "text": "formal verification"}, {"st": 164, "ed": 167, "text": "failure probability expressions"}, {"st": 169, "ed": 171, "text": "illustration purposes"}, {"st": 175, "ed": 178, "text": "formal failure analysis"}, {"st": 180, "ed": 183, "text": "communication gateway software"}, {"st": 185, "ed": 191, "text": "next generation air traffic management system"}]
[{"st": 0, "ed": 4, "text": "Efficient Description Logic Reasoning"}, {"st": 8, "ed": 10, "text": "DLog system"}]
[{"st": 6, "ed": 8, "text": "Description Logic"}, {"st": 15, "ed": 17, "text": "Description Logic"}, {"st": 20, "ed": 22, "text": "Prolog program"}, {"st": 25, "ed": 28, "text": "standard Prolog execution"}, {"st": 31, "ed": 34, "text": "instance retrieval queries"}, {"st": 37, "ed": 40, "text": "Description Logic point"}, {"st": 46, "ed": 49, "text": "ABox reasoning engine"}, {"st": 51, "ed": 54, "text": "full SHIQ language"}, {"st": 56, "ed": 58, "text": "DLog approach"}, {"st": 80, "ed": 83, "text": "description logic ontologies"}, {"st": 88, "ed": 90, "text": "information sources"}, {"st": 98, "ed": 100, "text": "Logic Programming"}]
[{"st": 0, "ed": 2, "text": "Random generation"}, {"st": 13, "ed": 15, "text": "logic programming"}, {"st": 16, "ed": 18, "text": "Boltzmann samplers"}]
[{"st": 1, "ed": 3, "text": "natural approach"}, {"st": 4, "ed": 7, "text": "software quality assurance"}, {"st": 10, "ed": 12, "text": "unit tests"}, {"st": 16, "ed": 18, "text": "code invariants"}, {"st": 23, "ed": 25, "text": "great body"}, {"st": 38, "ed": 40, "text": "intensive process"}, {"st": 42, "ed": 44, "text": "prominent example"}, {"st": 46, "ed": 48, "text": "successful use"}, {"st": 52, "ed": 54, "text": "particular random"}, {"st": 66, "ed": 69, "text": "Glasgow Haskell Compiler"}, {"st": 76, "ed": 79, "text": "difficult combinatorial structure"}, {"st": 84, "ed": 86, "text": "effective uniform"}, {"st": 95, "ed": 98, "text": "fundamental open problem"}, {"st": 100, "ed": 102, "text": "random software"}, {"st": 113, "ed": 115, "text": "Boltzmann samplers"}, {"st": 117, "ed": 119, "text": "powerful technique"}, {"st": 120, "ed": 124, "text": "random combinatorial structure generation"}, {"st": 128, "ed": 130, "text": "Prolog systems"}, {"st": 134, "ed": 136, "text": "logic variables"}, {"st": 139, "ed": 141, "text": "occurs check"}, {"st": 142, "ed": 144, "text": "efficient backtracking"}, {"st": 151, "ed": 154, "text": "novel sampling mechanism"}, {"st": 157, "ed": 159, "text": "uniformly random"}, {"st": 178, "ed": 180, "text": "uniformly random"}, {"st": 184, "ed": 186, "text": "normal forms"}, {"st": 189, "ed": 192, "text": "parallel execution mechanism"}, {"st": 195, "ed": 198, "text": "achievable term size"}]
[{"st": 1, "ed": 3, "text": "Coalgebraic Approach"}, {"st": 5, "ed": 8, "text": "Linear Time Logics"}]
[{"st": 2, "ed": 5, "text": "quantitative fixpoint logics"}, {"st": 8, "ed": 11, "text": "linear time properties"}, {"st": 21, "ed": 23, "text": "such systems"}, {"st": 33, "ed": 35, "text": "branching monad"}, {"st": 39, "ed": 41, "text": "polynomial endofunctors"}, {"st": 50, "ed": 52, "text": "truth values"}, {"st": 67, "ed": 69, "text": "special modality"}, {"st": 101, "ed": 103, "text": "wise semantics"}, {"st": 105, "ed": 107, "text": "alternative path"}, {"st": 114, "ed": 116, "text": "free fragments"}, {"st": 123, "ed": 125, "text": "logics support"}, {"st": 132, "ed": 134, "text": "minimal cost"}, {"st": 138, "ed": 141, "text": "linear time property"}, {"st": 152, "ed": 155, "text": "linear time flavour"}, {"st": 171, "ed": 173, "text": "resource usage"}, {"st": 181, "ed": 183, "text": "quantitative logic"}, {"st": 186, "ed": 188, "text": "component interaction"}]
[]
[{"st": 7, "ed": 9, "text": "integer endpoints"}, {"st": 18, "ed": 20, "text": "order logic"}, {"st": 47, "ed": 49, "text": "n$ times"}, {"st": 51, "ed": 54, "text": "next time interval"}, {"st": 61, "ed": 63, "text": "counting modalities"}, {"st": 88, "ed": 91, "text": "expressive decidable fragments"}]
[{"st": 2, "ed": 7, "text": "Metric Temporal Logic Expressively Complete"}]
[{"st": 1, "ed": 3, "text": "seminal result"}, {"st": 9, "ed": 13, "text": "reals Linear Temporal Logic"}, {"st": 18, "ed": 21, "text": "same expressive power"}, {"st": 24, "ed": 26, "text": "order logic"}, {"st": 27, "ed": 31, "text": "binary order relation <"}, {"st": 32, "ed": 34, "text": "monadic predicates"}, {"st": 36, "ed": 38, "text": "key question"}, {"st": 49, "ed": 52, "text": "Metric Temporal Logic"}, {"st": 73, "ed": 75, "text": "metric constraints"}, {"st": 81, "ed": 83, "text": "negative answer"}, {"st": 88, "ed": 90, "text": "order logic"}, {"st": 91, "ed": 95, "text": "binary order relation <"}, {"st": 96, "ed": 98, "text": "unary function"}, {"st": 107, "ed": 109, "text": "integer constants"}, {"st": 113, "ed": 115, "text": "recent result"}, {"st": 124, "ed": 127, "text": "rational timing constants"}, {"st": 131, "ed": 134, "text": "same expressive power"}, {"st": 137, "ed": 139, "text": "order logic"}, {"st": 142, "ed": 144, "text": "positive answer"}, {"st": 155, "ed": 157, "text": "precise characterization"}, {"st": 168, "ed": 170, "text": "order logic"}, {"st": 172, "ed": 175, "text": "same expressive power"}, {"st": 183, "ed": 185, "text": "order expressiveness"}, {"st": 210, "ed": 213, "text": "expressive decidable fragments"}]
[{"st": 2, "ed": 5, "text": "Communicating Timed Processes"}]
[{"st": 3, "ed": 5, "text": "reachability problem"}, {"st": 7, "ed": 9, "text": "timed processes"}, {"st": 14, "ed": 16, "text": "dense time"}, {"st": 22, "ed": 25, "text": "local timing constraints"}, {"st": 27, "ed": 30, "text": "unbounded FIFO channels"}, {"st": 39, "ed": 41, "text": "local clocks"}, {"st": 47, "ed": 49, "text": "same rate"}, {"st": 51, "ed": 53, "text": "main contribution"}, {"st": 55, "ed": 57, "text": "complete characterization"}, {"st": 60, "ed": 63, "text": "undecidable communication topologies"}, {"st": 68, "ed": 70, "text": "dense time"}, {"st": 74, "ed": 76, "text": "complexity results"}, {"st": 81, "ed": 83, "text": "timed processes"}, {"st": 89, "ed": 91, "text": "Petri nets"}, {"st": 94, "ed": 96, "text": "discrete time"}, {"st": 102, "ed": 104, "text": "Petri nets"}, {"st": 109, "ed": 111, "text": "mutual topology"}, {"st": 121, "ed": 123, "text": "counter automata"}]
[{"st": 0, "ed": 2, "text": "Linear Types"}]
[{"st": 5, "ed": 9, "text": "full classical linear logic"}, {"st": 11, "ed": 13, "text": "linear proofs"}]
[{"st": 1, "ed": 3, "text": "decision problem"}, {"st": 10, "ed": 12, "text": "set theory"}, {"st": 13, "ed": 15, "text": "restricted quantification"}, {"st": 16, "ed": 18, "text": "finite enumerations"}]
[{"st": 3, "ed": 5, "text": "satisfiability problem"}, {"st": 12, "ed": 14, "text": "set theory"}, {"st": 23, "ed": 25, "text": "restricted form"}, {"st": 30, "ed": 32, "text": "set variables"}, {"st": 34, "ed": 36, "text": "finite enumeration"}, {"st": 48, "ed": 50, "text": "individual variables"}, {"st": 57, "ed": 60, "text": "small model property"}, {"st": 64, "ed": 66, "text": "satisfiable formula"}, {"st": 73, "ed": 75, "text": "finite model"}, {"st": 90, "ed": 92, "text": "theoretic constructs"}, {"st": 104, "ed": 107, "text": "power set operator"}, {"st": 109, "ed": 112, "text": "unordered Cartesian product"}, {"st": 118, "ed": 121, "text": "unordered Cartesian product"}, {"st": 126, "ed": 128, "text": "finite enumerations"}, {"st": 151, "ed": 153, "text": "such terms"}]
[{"st": 1, "ed": 3, "text": "Concurrency Problem"}, {"st": 4, "ed": 6, "text": "Exponential DPLL(T"}]
[{"st": 0, "ed": 5, "text": "Many satisfiability modulo theories solvers"}, {"st": 23, "ed": 25, "text": "propositional abstraction"}, {"st": 29, "ed": 31, "text": "Such solvers"}, {"st": 41, "ed": 44, "text": "enough theory conflicts"}, {"st": 47, "ed": 49, "text": "propositional contradiction"}, {"st": 57, "ed": 59, "text": "diamonds problem"}, {"st": 63, "ed": 65, "text": "many conflicts"}, {"st": 69, "ed": 71, "text": "general criterion"}, {"st": 79, "ed": 81, "text": "theory conflicts"}, {"st": 97, "ed": 99, "text": "different state"}, {"st": 108, "ed": 110, "text": "order encodings"}, {"st": 115, "ed": 118, "text": "representative concurrency problem"}, {"st": 138, "ed": 141, "text": "bound proof complexity"}, {"st": 152, "ed": 154, "text": "multiple solvers"}, {"st": 155, "ed": 157, "text": "theory combinations"}]
[{"st": 2, "ed": 6, "text": "Minimal Effective Programming Systems"}]
[{"st": 1, "ed": 3, "text": "Rogers semilattice"}, {"st": 15, "ed": 17, "text": "effective numberings"}, {"st": 19, "ed": 22, "text": "partial computable functions"}, {"st": 53, "ed": 55, "text": "eps \\psi\\"}, {"st": 67, "ed": 70, "text": "translation function t"}, {"st": 77, "ed": 80, "text": "enumerable equivalence relation"}, {"st": 96, "ed": 99, "text": "program equivalence relation"}, {"st": 126, "ed": 128, "text": "minimal eps"}, {"st": 131, "ed": 134, "text": "single such R"}, {"st": 139, "ed": 141, "text": "such t."}, {"st": 147, "ed": 149, "text": "minimal eps"}, {"st": 155, "ed": 157, "text": "ceer R"}, {"st": 163, "ed": 166, "text": "program equivalence relation"}, {"st": 171, "ed": 174, "text": "translation function t"}, {"st": 181, "ed": 183, "text": "t fails"}, {"st": 190, "ed": 192, "text": "equivalence classes"}]
[{"st": 1, "ed": 4, "text": "Probabilistic Wireless Networks"}]
[{"st": 3, "ed": 5, "text": "process calculus"}, {"st": 7, "ed": 11, "text": "high level wireless systems"}, {"st": 32, "ed": 34, "text": "wireless networks"}, {"st": 36, "ed": 38, "text": "broadcast communication"}, {"st": 39, "ed": 41, "text": "probabilistic behaviour"}, {"st": 43, "ed": 45, "text": "first focus"}, {"st": 50, "ed": 52, "text": "wireless networks"}, {"st": 57, "ed": 59, "text": "compositional theory"}, {"st": 62, "ed": 64, "text": "probabilistic generalisation"}, {"st": 75, "ed": 77, "text": "pre- orders"}, {"st": 83, "ed": 85, "text": "extensional semantics"}, {"st": 98, "ed": 101, "text": "deadlock simulation preorders"}, {"st": 102, "ed": 104, "text": "wireless networks"}, {"st": 109, "ed": 111, "text": "simulation preorder"}, {"st": 125, "ed": 129, "text": "deadlock simulation pre- order"}, {"st": 142, "ed": 144, "text": "large class"}, {"st": 157, "ed": 159, "text": "simulation preorder"}, {"st": 183, "ed": 186, "text": "probabilistic routing protocols"}]
[{"st": 3, "ed": 5, "text": "Product Operators"}, {"st": 6, "ed": 8, "text": "Abstract Interpretation"}]
[{"st": 9, "ed": 11, "text": "general overview"}, {"st": 13, "ed": 15, "text": "product operators"}, {"st": 25, "ed": 27, "text": "analysis accuracy"}, {"st": 29, "ed": 32, "text": "Abstract Interpretation framework"}, {"st": 41, "ed": 43, "text": "reduced products"}, {"st": 50, "ed": 52, "text": "cardinal power"}, {"st": 66, "ed": 68, "text": "potential impact"}, {"st": 69, "ed": 71, "text": "practical applications"}]
[{"st": 1, "ed": 3, "text": "Proof System"}, {"st": 6, "ed": 8, "text": "Modal Mu"}]
[{"st": 3, "ed": 5, "text": "important ingredient"}, {"st": 8, "ed": 10, "text": "abstract interpretation"}, {"st": 11, "ed": 13, "text": "program logics"}, {"st": 21, "ed": 24, "text": "considerable expressive power"}, {"st": 26, "ed": 28, "text": "general issue"}, {"st": 32, "ed": 34, "text": "proof systems"}, {"st": 35, "ed": 37, "text": "such logics"}, {"st": 41, "ed": 43, "text": "proof systems"}, {"st": 44, "ed": 46, "text": "modal logic"}, {"st": 52, "ed": 55, "text": "tableau proof system"}, {"st": 69, "ed": 71, "text": "fixpoint variables"}]
[{"st": 0, "ed": 2, "text": "Model Checking"}]
[{"st": 4, "ed": 6, "text": "concurrent programs"}, {"st": 8, "ed": 10, "text": "difficult problem"}, {"st": 14, "ed": 16, "text": "state explosion"}, {"st": 18, "ed": 20, "text": "exponential growth"}, {"st": 22, "ed": 25, "text": "program state space"}, {"st": 31, "ed": 33, "text": "active components"}, {"st": 42, "ed": 44, "text": "conquer strategy"}, {"st": 46, "ed": 48, "text": "state explosion"}, {"st": 53, "ed": 55, "text": "single component"}, {"st": 70, "ed": 74, "text": "\" split \" invariant"}, {"st": 96, "ed": 98, "text": "component invariants"}, {"st": 106, "ed": 108, "text": "classical Owicki"}, {"st": 132, "ed": 134, "text": "limited scope"}, {"st": 141, "ed": 143, "text": "localized forms"}, {"st": 153, "ed": 155, "text": "Split invariance"}, {"st": 157, "ed": 159, "text": "interesting connections"}, {"st": 164, "ed": 166, "text": "quantified invariant"}, {"st": 168, "ed": 170, "text": "parametric system"}, {"st": 172, "ed": 174, "text": "split invariant"}, {"st": 200, "ed": 202, "text": "split invariant"}, {"st": 204, "ed": 206, "text": "small instance"}, {"st": 217, "ed": 219, "text": "entire family"}]
[{"st": 0, "ed": 2, "text": "Interaction Grammars"}]
[{"st": 0, "ed": 2, "text": "Interaction Grammar"}, {"st": 7, "ed": 9, "text": "grammatical formalism"}, {"st": 19, "ed": 21, "text": "resource sensitivity"}, {"st": 22, "ed": 24, "text": "natural languages"}, {"st": 31, "ed": 34, "text": "unsaturated syntactic structures"}, {"st": 35, "ed": 37, "text": "Syntactic composition"}, {"st": 41, "ed": 43, "text": "chemical reaction"}, {"st": 57, "ed": 59, "text": "theoretic framework"}, {"st": 62, "ed": 64, "text": "constraint systems"}, {"st": 68, "ed": 70, "text": "tree description"}, {"st": 77, "ed": 81, "text": "building tree description models"}]
[]
[{"st": 5, "ed": 7, "text": "constructive proof"}, {"st": 9, "ed": 11, "text": "following language"}, {"st": 12, "ed": 14, "text": "theoretic result"}, {"st": 19, "ed": 22, "text": "free language L"}, {"st": 26, "ed": 28, "text": "bounded context"}, {"st": 29, "ed": 32, "text": "free language L"}, {"st": 39, "ed": 41, "text": "same Parikh"}, {"st": 46, "ed": 48, "text": "L. Bounded"}, {"st": 59, "ed": 61, "text": "regular languages"}, {"st": 63, "ed": 65, "text": "form w1*w2*"}, {"st": 66, "ed": 68, "text": "wk *"}, {"st": 70, "ed": 72, "text": "finite words"}, {"st": 83, "ed": 85, "text": "free languages"}, {"st": 89, "ed": 91, "text": "decidability properties"}, {"st": 93, "ed": 95, "text": "proof proceeds"}, {"st": 107, "ed": 109, "text": "language semiring"}, {"st": 115, "ed": 118, "text": "free subset Ls"}, {"st": 131, "ed": 133, "text": "linear language"}, {"st": 136, "ed": 139, "text": "same Parikh image"}, {"st": 140, "ed": 142, "text": "L. Second"}, {"st": 153, "ed": 155, "text": "free subset"}, {"st": 166, "ed": 168, "text": "model checking"}, {"st": 172, "ed": 175, "text": "reachable state space"}, {"st": 176, "ed": 179, "text": "multithreaded procedural programs"}, {"st": 183, "ed": 186, "text": "reachable state space"}, {"st": 187, "ed": 190, "text": "recursive counter programs"}, {"st": 192, "ed": 194, "text": "bounded language"}, {"st": 198, "ed": 200, "text": "decidable underapproximation"}, {"st": 202, "ed": 204, "text": "original problems"}, {"st": 218, "ed": 220, "text": "original problems"}, {"st": 241, "ed": 243, "text": "progress guarantee"}, {"st": 245, "ed": 247, "text": "word w"}, {"st": 271, "ed": 273, "text": "multithreaded programs"}]
[{"st": 5, "ed": 7, "text": "Relational Specifications"}]
[{"st": 3, "ed": 6, "text": "hereditary Harrop formulas"}, {"st": 15, "ed": 17, "text": "wide range"}, {"st": 18, "ed": 20, "text": "formal systems"}, {"st": 27, "ed": 29, "text": "hypothetical judgment"}, {"st": 43, "ed": 45, "text": "side conditions"}, {"st": 51, "ed": 54, "text": "structural operational semantics"}, {"st": 57, "ed": 59, "text": "style presentations"}, {"st": 73, "ed": 79, "text": "Abella theorem prover supports such reasoning"}, {"st": 83, "ed": 85, "text": "specification logic"}, {"st": 87, "ed": 90, "text": "rich reasoning logic"}, {"st": 104, "ed": 106, "text": "induction principle"}, {"st": 112, "ed": 114, "text": "assumption sets"}, {"st": 118, "ed": 121, "text": "original Abella system"}, {"st": 127, "ed": 130, "text": "HH specification logic"}, {"st": 141, "ed": 143, "text": "inductive reasoning"}, {"st": 175, "ed": 177, "text": "such assumption"}, {"st": 179, "ed": 181, "text": "reasoning logic"}, {"st": 190, "ed": 192, "text": "several specification"}, {"st": 195, "ed": 198, "text": "theoretic reasoning examples"}, {"st": 204, "ed": 206, "text": "extended version"}]
[{"st": 9, "ed": 11, "text": "Automated Reasoning"}]
[{"st": 10, "ed": 12, "text": "various aspects"}, {"st": 13, "ed": 15, "text": "Computational Logic"}, {"st": 20, "ed": 22, "text": "key role"}, {"st": 36, "ed": 38, "text": "Howard correspondence"}, {"st": 43, "ed": 45, "text": "classical logic"}, {"st": 48, "ed": 50, "text": "linear logic"}, {"st": 56, "ed": 58, "text": "meaningful semantics"}, {"st": 63, "ed": 65, "text": "classical logic"}, {"st": 82, "ed": 84, "text": "Value disciplines"}, {"st": 85, "ed": 87, "text": "functional programming"}, {"st": 89, "ed": 91, "text": "first part"}, {"st": 114, "ed": 116, "text": "positive formulae"}, {"st": 123, "ed": 128, "text": "negative formulae consume such data"}, {"st": 143, "ed": 145, "text": "pure pattern"}, {"st": 155, "ed": 157, "text": "second part"}, {"st": 164, "ed": 166, "text": "realisability semantics"}, {"st": 179, "ed": 181, "text": "such data"}, {"st": 188, "ed": 190, "text": "orthogonality relation"}, {"st": 200, "ed": 203, "text": "Coq proof assistant"}, {"st": 227, "ed": 229, "text": "third part"}, {"st": 248, "ed": 250, "text": "other applications"}, {"st": 257, "ed": 259, "text": "theorem proving"}, {"st": 272, "ed": 274, "text": "main algorithm"}, {"st": 294, "ed": 296, "text": "search engine"}, {"st": 313, "ed": 315, "text": "smart techniques"}, {"st": 321, "ed": 323, "text": "user interface"}]
[{"st": 0, "ed": 3, "text": "Axiomatic constraint systems"}, {"st": 4, "ed": 8, "text": "proof search modulo theories"}]
[{"st": 3, "ed": 5, "text": "proof search"}, {"st": 23, "ed": 25, "text": "such variables"}, {"st": 31, "ed": 33, "text": "tree branches"}, {"st": 37, "ed": 39, "text": "order unification"}, {"st": 43, "ed": 46, "text": "specific background reasoner"}, {"st": 53, "ed": 55, "text": "such mechanisms"}, {"st": 58, "ed": 60, "text": "specific constraints"}, {"st": 70, "ed": 72, "text": "modular proof"}, {"st": 73, "ed": 75, "text": "search procedures"}, {"st": 76, "ed": 78, "text": "such mechanisms"}, {"st": 82, "ed": 84, "text": "sequent calculus"}, {"st": 91, "ed": 93, "text": "such constraints"}, {"st": 112, "ed": 114, "text": "abstract constraints"}, {"st": 121, "ed": 124, "text": "same way unifiers"}, {"st": 132, "ed": 134, "text": "abstract framework"}, {"st": 135, "ed": 137, "text": "component interface"}, {"st": 141, "ed": 143, "text": "concrete implementations"}, {"st": 144, "ed": 146, "text": "background reasoners"}]
[{"st": 1, "ed": 3, "text": "Hoare logic"}, {"st": 5, "ed": 7, "text": "coinductive trace"}, {"st": 11, "ed": 13, "text": "step semantics"}]
[{"st": 4, "ed": 6, "text": "foundational framework"}, {"st": 9, "ed": 11, "text": "observable behavior"}, {"st": 28, "ed": 30, "text": "step semantics"}, {"st": 43, "ed": 45, "text": "initial states"}, {"st": 46, "ed": 48, "text": "program runs"}, {"st": 66, "ed": 69, "text": "standard inductive state"}, {"st": 77, "ed": 80, "text": "Hoare logic counterpart"}, {"st": 82, "ed": 84, "text": "coinductive trace"}, {"st": 101, "ed": 103, "text": "correctness state"}, {"st": 113, "ed": 115, "text": "correctness variation"}, {"st": 122, "ed": 124, "text": "converse direction"}, {"st": 134, "ed": 136, "text": "Hoare triple"}, {"st": 159, "ed": 161, "text": "Hoare triple"}, {"st": 167, "ed": 170, "text": "constructive underlying logic"}, {"st": 174, "ed": 176, "text": "program properties"}, {"st": 182, "ed": 184, "text": "fine structure"}, {"st": 200, "ed": 202, "text": "total search"}, {"st": 209, "ed": 211, "text": "nonetheless nondivergent"}]
[{"st": 5, "ed": 7, "text": "Weak Bisimilarity"}, {"st": 8, "ed": 10, "text": "Markov Automata"}]
[{"st": 1, "ed": 5, "text": "new weak bisimulation semantics"}, {"st": 8, "ed": 10, "text": "Markov automata"}, {"st": 17, "ed": 19, "text": "internal actions"}, {"st": 23, "ed": 25, "text": "expected values"}, {"st": 33, "ed": 35, "text": "internal actions"}, {"st": 51, "ed": 53, "text": "Markov automata"}, {"st": 63, "ed": 65, "text": "weak bisimilarity"}, {"st": 67, "ed": 70, "text": "labeled transition systems"}, {"st": 80, "ed": 82, "text": "stochastic time"}, {"st": 83, "ed": 85, "text": "deterministic time"}]
[{"st": 3, "ed": 5, "text": "Intuitionistic Negation"}]
[{"st": 7, "ed": 9, "text": "\\cal A}=(S"}, {"st": 17, "ed": 19, "text": "intuitionistic logic"}, {"st": 28, "ed": 30, "text": "intuitionistic negation"}, {"st": 39, "ed": 41, "text": "\\cal A}$"}, {"st": 53, "ed": 55, "text": "intuitionistic models"}, {"st": 60, "ed": 62, "text": "complete extensions"}, {"st": 65, "ed": 67, "text": "\\cal A}$."}, {"st": 70, "ed": 72, "text": "argumentation networks"}, {"st": 73, "ed": 76, "text": "intuitionistic logic yields"}, {"st": 81, "ed": 83, "text": "representation theorem"}, {"st": 85, "ed": 87, "text": "additional benefits"}, {"st": 96, "ed": 98, "text": "level attacks"}, {"st": 104, "ed": 106, "text": "xRy$ \""}, {"st": 110, "ed": 112, "text": "attack \""}, {"st": 113, "ed": 115, "text": "uRv$ \""}, {"st": 133, "ed": 135, "text": "such meta"}]
[{"st": 8, "ed": 10, "text": "successor relations"}, {"st": 11, "ed": 14, "text": "finite linear orders"}]
[{"st": 3, "ed": 6, "text": "finitary satisfiability problem"}, {"st": 7, "ed": 10, "text": "first order logic"}, {"st": 15, "ed": 17, "text": "binary relations"}, {"st": 21, "ed": 24, "text": "induced successor relations"}, {"st": 26, "ed": 29, "text": "finite linear orders"}]
[{"st": 5, "ed": 8, "text": "step reduction strategy"}, {"st": 10, "ed": 13, "text": "distributive lambda calculus"}]
[{"st": 4, "ed": 6, "text": "question A.1.6"}, {"st": 7, "ed": 9, "text": "J. Klop"}, {"st": 10, "ed": 13, "text": "\" Ustica Notes"}, {"st": 23, "ed": 26, "text": "step reduction strategy"}, {"st": 31, "ed": 33, "text": "\" Micro"}, {"st": 34, "ed": 36, "text": "\\lambda$-calculus refers"}, {"st": 64, "ed": 66, "text": "\\lambda x"}, {"st": 67, "ed": 69, "text": "M)\\ N$"}]
[{"st": 1, "ed": 3, "text": "perfect recall"}, {"st": 6, "ed": 9, "text": "step temporal operators"}, {"st": 14, "ed": 18, "text": "S5 Epistemic Temporal Logic"}]
[{"st": 5, "ed": 7, "text": "perfect recall"}, {"st": 11, "ed": 13, "text": "interpreted systems"}, {"st": 14, "ed": 16, "text": "game theory"}, {"st": 18, "ed": 20, "text": "epistemic logic"}, {"st": 25, "ed": 28, "text": "Epistemic Temporal Logic"}, {"st": 40, "ed": 43, "text": "novel frame condition"}, {"st": 44, "ed": 46, "text": "perfect recall"}, {"st": 67, "ed": 70, "text": "step temporal operators"}, {"st": 72, "ed": 74, "text": "frame condition"}, {"st": 79, "ed": 81, "text": "complete axiomatization"}, {"st": 82, "ed": 84, "text": "S5 ETL"}, {"st": 86, "ed": 88, "text": "perfect recall"}, {"st": 100, "ed": 102, "text": "perfect recall"}, {"st": 105, "ed": 107, "text": "S5 settings"}, {"st": 110, "ed": 112, "text": "various notions"}]
[{"st": 0, "ed": 5, "text": "Computational Higher Type Theory II"}, {"st": 6, "ed": 9, "text": "Dependent Cubical Realizability"}]
[{"st": 17, "ed": 20, "text": "dependent type theory"}, {"st": 25, "ed": 27, "text": "dimensional types"}, {"st": 32, "ed": 35, "text": "cubical realizability framework"}, {"st": 36, "ed": 38, "text": "simple types"}, {"st": 48, "ed": 50, "text": "meaning explanation"}, {"st": 54, "ed": 57, "text": "dimensional type theory"}, {"st": 63, "ed": 66, "text": "computational Kan condition"}, {"st": 76, "ed": 78, "text": "type families"}, {"st": 83, "ed": 85, "text": "identification types"}, {"st": 97, "ed": 99, "text": "dependent function"}, {"st": 100, "ed": 102, "text": "product types"}, {"st": 104, "ed": 106, "text": "main result"}, {"st": 108, "ed": 110, "text": "canonicity theorem"}, {"st": 115, "ed": 117, "text": "closed term"}, {"st": 118, "ed": 120, "text": "boolean type"}, {"st": 131, "ed": 134, "text": "first computational interpretation"}, {"st": 136, "ed": 139, "text": "dependent type theory"}, {"st": 142, "ed": 145, "text": "deterministic operational semantics"}, {"st": 154, "ed": 156, "text": "Kan condition"}]
[{"st": 0, "ed": 3, "text": "Coalgebraic Trace Semantics"}, {"st": 6, "ed": 8, "text": "Parity Automata"}]
[{"st": 5, "ed": 8, "text": "numerous general results"}, {"st": 23, "ed": 26, "text": "Buechi acceptance condition"}, {"st": 28, "ed": 30, "text": "basic notion"}, {"st": 36, "ed": 38, "text": "infinite words"}, {"st": 47, "ed": 49, "text": "clean answer"}, {"st": 56, "ed": 60, "text": "\" maximality \" characterization"}, {"st": 61, "ed": 63, "text": "infinite traces"}, {"st": 71, "ed": 73, "text": "accepted language"}, {"st": 75, "ed": 77, "text": "Buechi automaton"}, {"st": 87, "ed": 89, "text": "least homomorphism"}, {"st": 109, "ed": 111, "text": "point equations"}, {"st": 118, "ed": 120, "text": "nondeterministic branching"}, {"st": 122, "ed": 124, "text": "probabilistic one"}, {"st": 140, "ed": 143, "text": "parity acceptance condition"}]
[{"st": 1, "ed": 4, "text": "Fully Abstract Semantics"}, {"st": 7, "ed": 9, "text": "passing CCS"}]
[{"st": 5, "ed": 7, "text": "abstract semantics"}, {"st": 10, "ed": 12, "text": "passing CCS"}, {"st": 19, "ed": 21, "text": "operational semantics"}, {"st": 28, "ed": 30, "text": "reduction semantics"}, {"st": 35, "ed": 38, "text": "labelled transition semantics"}, {"st": 40, "ed": 43, "text": "labelled transition semantics"}, {"st": 61, "ed": 63, "text": "behavioral equivalence"}, {"st": 66, "ed": 69, "text": "weak barbed congruence"}, {"st": 70, "ed": 72, "text": "weak bisimilarity"}, {"st": 81, "ed": 83, "text": "congruence coincides"}, {"st": 84, "ed": 86, "text": "weak bisimilarity"}, {"st": 89, "ed": 91, "text": "finite processes"}, {"st": 95, "ed": 98, "text": "first such result"}, {"st": 100, "ed": 102, "text": "concurrent model"}, {"st": 103, "ed": 105, "text": "tree structures"}]
[{"st": 2, "ed": 5, "text": "Expected Mean Payoff"}, {"st": 6, "ed": 10, "text": "Energy Markov Decision Processes"}]
[{"st": 0, "ed": 4, "text": "Energy Markov Decision Processes"}, {"st": 10, "ed": 13, "text": "state Markov decision"}, {"st": 20, "ed": 23, "text": "integer counter update"}, {"st": 25, "ed": 27, "text": "rational payoff"}, {"st": 29, "ed": 31, "text": "EMDP configuration"}, {"st": 33, "ed": 35, "text": "pair s(n"}, {"st": 41, "ed": 43, "text": "control state"}, {"st": 47, "ed": 50, "text": "current counter value"}, {"st": 60, "ed": 62, "text": "standard way"}, {"st": 70, "ed": 72, "text": "safe strategy"}, {"st": 88, "ed": 91, "text": "expected mean payoff"}]
[{"st": 1, "ed": 3, "text": "Computational Paths"}, {"st": 5, "ed": 7, "text": "Fundamental Groupoid"}]
[{"st": 1, "ed": 3, "text": "main objective"}, {"st": 9, "ed": 11, "text": "mathematical properties"}, {"st": 12, "ed": 14, "text": "computational paths"}, {"st": 19, "ed": 21, "text": "Queiroz \\"}, {"st": 33, "ed": 35, "text": "computational paths"}, {"st": 44, "ed": 46, "text": "propositional equality"}, {"st": 48, "ed": 50, "text": "computational objects"}, {"st": 53, "ed": 55, "text": "computational paths"}, {"st": 56, "ed": 58, "text": "categorical semantics"}, {"st": 66, "ed": 68, "text": "type theory"}, {"st": 81, "ed": 83, "text": "fundamental groupoid"}, {"st": 99, "ed": 101, "text": "homotopical interpretation"}, {"st": 103, "ed": 105, "text": "identity type"}, {"st": 107, "ed": 109, "text": "main difference"}, {"st": 116, "ed": 118, "text": "semantical interpretation"}, {"st": 119, "ed": 121, "text": "computational paths"}, {"st": 127, "ed": 129, "text": "type theory"}, {"st": 137, "ed": 139, "text": "computational paths"}, {"st": 141, "ed": 143, "text": "fundamental groupoids"}]
[{"st": 2, "ed": 5, "text": "Small Progress Measures"}]
[{"st": 0, "ed": 3, "text": "Small Progress Measures"}, {"st": 7, "ed": 10, "text": "classical parity game"}, {"st": 16, "ed": 18, "text": "n vertices"}, {"st": 19, "ed": 21, "text": "m edges"}, {"st": 23, "ed": 25, "text": "different priorities"}, {"st": 27, "ed": 29, "text": "original algorithm"}, {"st": 31, "ed": 33, "text": "winning regions"}, {"st": 35, "ed": 37, "text": "winning strategy"}, {"st": 43, "ed": 46, "text": "O(dm.(n / floor(d/2))^floor(d/2"}, {"st": 52, "ed": 54, "text": "winning strategy"}, {"st": 56, "ed": 58, "text": "other player"}, {"st": 70, "ed": 72, "text": "winning region"}, {"st": 76, "ed": 78, "text": "runtime complexity"}, {"st": 79, "ed": 82, "text": "O(dm.(n / ceil(d/2))^ceil(d/2"}, {"st": 87, "ed": 89, "text": "winning regions"}, {"st": 105, "ed": 107, "text": "winning strategy"}, {"st": 117, "ed": 119, "text": "upper bound"}, {"st": 120, "ed": 122, "text": "strategy derivation"}, {"st": 125, "ed": 128, "text": "O(dm.(n / floor(d/2))^floor(d/2"}, {"st": 139, "ed": 142, "text": "novel operational interpretation"}, {"st": 145, "ed": 147, "text": "progress measure"}]
[{"st": 0, "ed": 2, "text": "Negotiation Games"}]
[{"st": 7, "ed": 10, "text": "multi party negotiation"}, {"st": 18, "ed": 20, "text": "J. Desel"}, {"st": 21, "ed": 23, "text": "J. Esparza"}, {"st": 36, "ed": 38, "text": "coalition problems"}, {"st": 67, "ed": 69, "text": "coalition force"}, {"st": 80, "ed": 82, "text": "arbitrary negotiations"}, {"st": 99, "ed": 102, "text": "weakly deterministic negotiations"}, {"st": 129, "ed": 131, "text": "state space"}]
[{"st": 1, "ed": 6, "text": "Linear Temporal Logics Meet Costs"}]
[{"st": 5, "ed": 7, "text": "parameterized extensions"}, {"st": 8, "ed": 11, "text": "Linear Temporal Logic"}, {"st": 17, "ed": 20, "text": "attractive algorithmic properties"}, {"st": 24, "ed": 27, "text": "polynomial space model"}, {"st": 33, "ed": 36, "text": "exponential time algorithm"}, {"st": 56, "ed": 58, "text": "Parametric LTL"}, {"st": 69, "ed": 71, "text": "temporal operators"}, {"st": 91, "ed": 93, "text": "Parametric LDL"}, {"st": 108, "ed": 110, "text": "regular properties"}, {"st": 152, "ed": 154, "text": "model checking"}, {"st": 168, "ed": 170, "text": "corresponding problems"}, {"st": 184, "ed": 186, "text": "cost functions"}]
[]
[{"st": 7, "ed": 10, "text": "upper time bounds"}, {"st": 39, "ed": 41, "text": "same preorder"}, {"st": 51, "ed": 53, "text": "present paper"}, {"st": 55, "ed": 57, "text": "operational semantics"}, {"st": 73, "ed": 75, "text": "same preorder"}, {"st": 91, "ed": 93, "text": "third variant"}, {"st": 106, "ed": 109, "text": "new operational semantics"}, {"st": 118, "ed": 120, "text": "same preorder"}]
[{"st": 0, "ed": 2, "text": "NP Datalog"}, {"st": 4, "ed": 6, "text": "Logic Language"}, {"st": 7, "ed": 10, "text": "Expressing NP Search"}, {"st": 11, "ed": 13, "text": "Optimization Problems"}]
[{"st": 4, "ed": 6, "text": "logic language"}, {"st": 8, "ed": 10, "text": "NP search"}, {"st": 11, "ed": 13, "text": "optimization problems"}, {"st": 29, "ed": 31, "text": "efficient constructs"}, {"st": 34, "ed": 36, "text": "stratified negation"}, {"st": 39, "ed": 41, "text": "exclusive disjunction"}, {"st": 54, "ed": 56, "text": "restricted form"}, {"st": 79, "ed": 81, "text": "NP Datalog"}, {"st": 88, "ed": 90, "text": "unstratified negation"}, {"st": 94, "ed": 96, "text": "optimization problems"}, {"st": 98, "ed": 100, "text": "system prototype"}, {"st": 101, "ed": 103, "text": "NP Datalog"}, {"st": 109, "ed": 111, "text": "NP Datalog"}, {"st": 113, "ed": 115, "text": "OPL programs"}, {"st": 120, "ed": 124, "text": "ILOG OPL Development Studio"}, {"st": 128, "ed": 130, "text": "easy formulation"}, {"st": 138, "ed": 141, "text": "declarative logic language"}, {"st": 147, "ed": 149, "text": "ILOG System"}, {"st": 150, "ed": 152, "text": "Several experiments"}]
[{"st": 1, "ed": 3, "text": "Last Paper"}, {"st": 7, "ed": 11, "text": "Shoham Interval Temporal Logic"}]
[{"st": 3, "ed": 5, "text": "Shoham logic"}, {"st": 7, "ed": 9, "text": "modal logic"}, {"st": 10, "ed": 12, "text": "time intervals"}, {"st": 19, "ed": 22, "text": "last ten years"}, {"st": 27, "ed": 29, "text": "beautiful logic"}, {"st": 35, "ed": 37, "text": "satisfiability problem"}, {"st": 52, "ed": 54, "text": "unexpected result"}, {"st": 71, "ed": 73, "text": "operator \""}, {"st": 85, "ed": 87, "text": "discrete structures"}, {"st": 97, "ed": 99, "text": "dense orders"}, {"st": 101, "ed": 103, "text": "reflexive variant"}, {"st": 109, "ed": 111, "text": "discrete structures"}]
[]
[{"st": 2, "ed": 4, "text": "passing calculi"}, {"st": 5, "ed": 7, "text": "foundational models"}, {"st": 23, "ed": 25, "text": "relative expressiveness"}, {"st": 44, "ed": 47, "text": "model independent approach"}, {"st": 54, "ed": 56, "text": "passing calculi"}, {"st": 60, "ed": 62, "text": "uniform treatment"}, {"st": 66, "ed": 68, "text": "technical tools"}, {"st": 84, "ed": 86, "text": "passing calculus"}]
[{"st": 1, "ed": 4, "text": "New Representation Theorem"}, {"st": 8, "ed": 10, "text": "Modal Logics"}]
[{"st": 3, "ed": 5, "text": "new definition"}, {"st": 7, "ed": 9, "text": "representation theorem"}, {"st": 16, "ed": 18, "text": "modal operators"}, {"st": 27, "ed": 29, "text": "algebraic models"}, {"st": 34, "ed": 36, "text": "relational structures"}, {"st": 43, "ed": 45, "text": "world semantics"}, {"st": 50, "ed": 52, "text": "new framework"}, {"st": 54, "ed": 56, "text": "new semantics"}, {"st": 66, "ed": 68, "text": "invariance entailment"}, {"st": 76, "ed": 78, "text": "current definitions"}, {"st": 84, "ed": 86, "text": "designated subset"}, {"st": 87, "ed": 89, "text": "logic values"}, {"st": 93, "ed": 95, "text": "satisfaction relation"}, {"st": 109, "ed": 111, "text": "modal logics"}, {"st": 122, "ed": 125, "text": "complete distributive lattices"}, {"st": 128, "ed": 131, "text": "compact autoreferential Kripke"}, {"st": 132, "ed": 135, "text": "style canonical representation"}, {"st": 139, "ed": 141, "text": "style semantics"}, {"st": 145, "ed": 147, "text": "modal logics"}, {"st": 151, "ed": 153, "text": "irreducible subset"}, {"st": 155, "ed": 157, "text": "carrier set"}, {"st": 165, "ed": 167, "text": "possible worlds"}, {"st": 169, "ed": 171, "text": "significant member"}, {"st": 176, "ed": 179, "text": "paraconsistent fuzzy logic"}, {"st": 181, "ed": 184, "text": "new logic values"}, {"st": 192, "ed": 194, "text": "inconsistent information"}, {"st": 196, "ed": 198, "text": "new theory"}, {"st": 215, "ed": 217, "text": "4-valued bilattice"}, {"st": 220, "ed": 222, "text": "minimal extension"}, {"st": 223, "ed": 225, "text": "classical logic"}, {"st": 230, "ed": 232, "text": "inconsistent information"}]
[{"st": 0, "ed": 2, "text": "Probabilistic Logic"}]
[{"st": 1, "ed": 3, "text": "probability theory"}, {"st": 53, "ed": 55, "text": "current approaches"}, {"st": 62, "ed": 64, "text": "/ logics"}, {"st": 67, "ed": 69, "text": "linear inequalities"}, {"st": 78, "ed": 80, "text": "weak points"}, {"st": 88, "ed": 90, "text": "complete revision"}, {"st": 99, "ed": 101, "text": "full embedding"}, {"st": 102, "ed": 104, "text": "Nilsson'probabilistic structure"}, {"st": 105, "ed": 108, "text": "propositional logic results"}, {"st": 124, "ed": 126, "text": "current considerations"}, {"st": 127, "ed": 130, "text": "propositional probabilistic logic"}, {"st": 148, "ed": 151, "text": "2-valued intensional FOL"}, {"st": 152, "ed": 154, "text": "intensional abstraction"}, {"st": 157, "ed": 159, "text": "current ad"}, {"st": 160, "ed": 162, "text": "hoc system"}, {"st": 165, "ed": 168, "text": "different 2-valued logics"}, {"st": 172, "ed": 175, "text": "classical propositional logic"}, {"st": 189, "ed": 191, "text": "probabilistic constraints"}, {"st": 192, "ed": 194, "text": "probabilistic variables"}, {"st": 196, "ed": 199, "text": "obtained theoretical results"}, {"st": 202, "ed": 205, "text": "Probabilistic Logic Programming"}]
[{"st": 1, "ed": 3, "text": "Equivalence Problem"}, {"st": 4, "ed": 8, "text": "Deterministic MSO Tree Transducers"}]
[{"st": 4, "ed": 8, "text": "deterministic MSO definable graph"}, {"st": 17, "ed": 19, "text": "tree transducers"}, {"st": 27, "ed": 29, "text": "free set"}]
[{"st": 0, "ed": 3, "text": "Coalgebraic Infinite Traces"}, {"st": 4, "ed": 6, "text": "Kleisli Simulations"}]
[{"st": 0, "ed": 2, "text": "Kleisli simulation"}, {"st": 4, "ed": 6, "text": "categorical notion"}, {"st": 11, "ed": 14, "text": "finite trace inclusion"}, {"st": 24, "ed": 26, "text": "backward simulation"}, {"st": 27, "ed": 29, "text": "various types"}, {"st": 33, "ed": 36, "text": "generic categorical theory"}, {"st": 37, "ed": 39, "text": "Kleisli simulation"}, {"st": 52, "ed": 55, "text": "finite trace semantics"}, {"st": 65, "ed": 67, "text": "partial execution"}, {"st": 68, "ed": 71, "text": "FPE)---a categorical transformation"}, {"st": 85, "ed": 87, "text": "Kleisli simulation"}, {"st": 88, "ed": 90, "text": "theoretical foundation"}, {"st": 97, "ed": 99, "text": "infinite trace"}, {"st": 107, "ed": 110, "text": "infinite trace semantics"}, {"st": 125, "ed": 127, "text": "forward simulations"}, {"st": 133, "ed": 135, "text": "backward simulation"}, {"st": 141, "ed": 144, "text": "certain additional conditions"}, {"st": 162, "ed": 164, "text": "infinite trace"}, {"st": 170, "ed": 172, "text": "Kleisli simulations"}, {"st": 175, "ed": 177, "text": "trace inclusion"}, {"st": 196, "ed": 198, "text": "time behaviors"}, {"st": 205, "ed": 207, "text": "powerset monad"}, {"st": 217, "ed": 219, "text": "Giry monad"}]
[{"st": 1, "ed": 3, "text": "Nested Sequents"}, {"st": 4, "ed": 7, "text": "Constructive Modal Logics"}]
[{"st": 2, "ed": 4, "text": "deductive systems"}, {"st": 5, "ed": 8, "text": "various modal logics"}, {"st": 14, "ed": 16, "text": "constructive variant"}, {"st": 18, "ed": 22, "text": "normal modal logic CK"}, {"st": 27, "ed": 29, "text": "axioms d"}, {"st": 42, "ed": 44, "text": "constructive variants"}, {"st": 46, "ed": 50, "text": "standard modal logics K4"}, {"st": 64, "ed": 66, "text": "nested sequents"}, {"st": 69, "ed": 71, "text": "syntactic proof"}, {"st": 72, "ed": 74, "text": "cut elimination"}]
[{"st": 3, "ed": 5, "text": "Distributed Fault"}, {"st": 6, "ed": 8, "text": "tolerant Systems"}]
[{"st": 1, "ed": 3, "text": "formal specifications"}, {"st": 4, "ed": 6, "text": "distributed systems"}, {"st": 10, "ed": 13, "text": "simple consistency requirements"}, {"st": 22, "ed": 25, "text": "complicated information flow"}, {"st": 27, "ed": 29, "text": "distributed system"}, {"st": 43, "ed": 45, "text": "other components"}, {"st": 67, "ed": 69, "text": "distributed realizability"}, {"st": 71, "ed": 73, "text": "temporal specification"}, {"st": 88, "ed": 90, "text": "bounded synthesis"}, {"st": 96, "ed": 98, "text": "positive case"}, {"st": 106, "ed": 108, "text": "realizable specification"}, {"st": 113, "ed": 115, "text": "negative case"}, {"st": 148, "ed": 150, "text": "such counterexamples"}, {"st": 156, "ed": 159, "text": "time temporal logic"}, {"st": 175, "ed": 177, "text": "different sequence"}, {"st": 212, "ed": 214, "text": "such counterexamples"}, {"st": 217, "ed": 221, "text": "classic distributed realizability problem"}, {"st": 226, "ed": 229, "text": "tolerant realizability problem"}, {"st": 231, "ed": 233, "text": "method considers"}, {"st": 249, "ed": 251, "text": "safety specifications"}, {"st": 253, "ed": 255, "text": "ordered architectures"}, {"st": 258, "ed": 260, "text": "decision procedure"}, {"st": 264, "ed": 266, "text": "full LTL"}, {"st": 267, "ed": 269, "text": "arbitrary architectures"}, {"st": 273, "ed": 275, "text": "many paths"}, {"st": 276, "ed": 278, "text": "Experimental results"}, {"st": 285, "ed": 287, "text": "prototype implementation"}, {"st": 293, "ed": 295, "text": "simple errors"}, {"st": 302, "ed": 305, "text": "high combinatorial complexity"}, {"st": 308, "ed": 310, "text": "Byzantine Generals"}]
[{"st": 1, "ed": 3, "text": "Finite Posets"}]
[{"st": 3, "ed": 5, "text": "monoidal category"}, {"st": 8, "ed": 11, "text": "finite partial orders"}, {"st": 16, "ed": 18, "text": "maximal elements"}, {"st": 32, "ed": 34, "text": "monoidal category"}]
[{"st": 0, "ed": 2, "text": "Automatic Generation"}, {"st": 3, "ed": 5, "text": "Proof Tactics"}]
[{"st": 7, "ed": 9, "text": "logical frameworks"}, {"st": 16, "ed": 18, "text": "wide range"}, {"st": 19, "ed": 21, "text": "mathematical theories"}, {"st": 26, "ed": 28, "text": "order metalanguage"}, {"st": 31, "ed": 33, "text": "proof assistants"}, {"st": 39, "ed": 43, "text": "such powerful systems resides"}, {"st": 50, "ed": 52, "text": "reasoning capabilities"}, {"st": 59, "ed": 61, "text": "programming languages"}, {"st": 80, "ed": 82, "text": "proof tactics"}, {"st": 84, "ed": 86, "text": "present contribution"}, {"st": 96, "ed": 99, "text": "complete tableau systems"}, {"st": 102, "ed": 104, "text": "inclusive class"}, {"st": 110, "ed": 112, "text": "propositional logics"}, {"st": 125, "ed": 127, "text": "algorithmic formation"}, {"st": 128, "ed": 130, "text": "automated theorem"}, {"st": 133, "ed": 135, "text": "such logics"}, {"st": 148, "ed": 150, "text": "generalized notion"}, {"st": 153, "ed": 155, "text": "proof systems"}, {"st": 163, "ed": 166, "text": "corresponding automated tactics"}, {"st": 168, "ed": 170, "text": "concerns theoremhood"}, {"st": 172, "ed": 174, "text": "targeted logics"}]
[{"st": 1, "ed": 4, "text": "Temporal Regular Properties"}, {"st": 7, "ed": 10, "text": "Term Rewriting Systems"}]
[{"st": 1, "ed": 4, "text": "tree automaton completion"}, {"st": 10, "ed": 12, "text": "safety properties"}, {"st": 27, "ed": 29, "text": "verification technique"}, {"st": 35, "ed": 37, "text": "infinite systems"}, {"st": 38, "ed": 40, "text": "cryptographic protocols"}, {"st": 44, "ed": 47, "text": "Java Bytecode programs"}, {"st": 52, "ed": 54, "text": "tree automaton"}, {"st": 66, "ed": 68, "text": "reachable terms"}, {"st": 70, "ed": 72, "text": "initial terms"}, {"st": 98, "ed": 101, "text": "same equivalence class"}, {"st": 107, "ed": 109, "text": "same state"}, {"st": 111, "ed": 113, "text": "tree automaton"}, {"st": 127, "ed": 129, "text": "relation sufficient"}, {"st": 131, "ed": 133, "text": "temporal properties"}, {"st": 151, "ed": 153, "text": "equivalence classes"}, {"st": 168, "ed": 170, "text": "ground transitions"}, {"st": 174, "ed": 176, "text": "equivalence classes"}, {"st": 201, "ed": 203, "text": "Kripke structure"}, {"st": 211, "ed": 213, "text": "Kripke structure"}, {"st": 217, "ed": 219, "text": "tree automaton"}, {"st": 221, "ed": 223, "text": "transition relation"}, {"st": 236, "ed": 238, "text": "Kripke structure"}, {"st": 247, "ed": 249, "text": "ground transitions"}, {"st": 252, "ed": 254, "text": "Kripke structure"}, {"st": 258, "ed": 262, "text": "Regular Linear Temporal Logic"}, {"st": 271, "ed": 273, "text": "Such properties"}, {"st": 278, "ed": 280, "text": "standard model"}, {"st": 284, "ed": 286, "text": "only difference"}, {"st": 298, "ed": 300, "text": "regular sets"}, {"st": 301, "ed": 303, "text": "acceptable terms"}]
[{"st": 0, "ed": 4, "text": "Bisimulation Relations Between Automata"}, {"st": 5, "ed": 8, "text": "Stochastic Differential Equations"}, {"st": 9, "ed": 11, "text": "Petri Nets"}]
[{"st": 1, "ed": 4, "text": "formal stochastic models"}, {"st": 14, "ed": 16, "text": "stochastic process"}, {"st": 23, "ed": 26, "text": "stochastic model formalisms"}, {"st": 32, "ed": 35, "text": "stochastic model formalism"}, {"st": 40, "ed": 44, "text": "other stochastic model formalism"}, {"st": 53, "ed": 55, "text": "bisimilarity relations"}, {"st": 56, "ed": 59, "text": "stochastic hybrid automata"}, {"st": 60, "ed": 63, "text": "stochastic differential equations"}, {"st": 64, "ed": 66, "text": "hybrid space"}, {"st": 67, "ed": 71, "text": "stochastic hybrid Petri nets"}, {"st": 73, "ed": 75, "text": "bisimilarity relations"}, {"st": 81, "ed": 84, "text": "formal verification power"}, {"st": 88, "ed": 90, "text": "analysis power"}, {"st": 91, "ed": 94, "text": "stochastic differential equations"}, {"st": 96, "ed": 99, "text": "compositional specification power"}, {"st": 100, "ed": 102, "text": "Petri nets"}, {"st": 107, "ed": 109, "text": "combined strengths"}, {"st": 113, "ed": 116, "text": "air traffic example"}]
[{"st": 1, "ed": 4, "text": "Complete Decision Procedure"}, {"st": 5, "ed": 8, "text": "Univariate Polynomial Problems"}, {"st": 9, "ed": 12, "text": "Isabelle / HOL"}]
[{"st": 8, "ed": 10, "text": "decision procedure"}, {"st": 13, "ed": 17, "text": "order univariate polynomial problems"}, {"st": 25, "ed": 27, "text": "executable function"}, {"st": 33, "ed": 35, "text": "univariate polynomial"}, {"st": 37, "ed": 40, "text": "real algebraic point"}, {"st": 46, "ed": 48, "text": "trusted code"}, {"st": 54, "ed": 56, "text": "code generation"}, {"st": 61, "ed": 64, "text": "first step towards"}, {"st": 66, "ed": 69, "text": "MetiTarski theorem prover"}]
[{"st": 2, "ed": 4, "text": "AMBA AHB"}, {"st": 5, "ed": 7, "text": "Formal Specification"}]
[{"st": 1, "ed": 3, "text": "standard procedure"}, {"st": 4, "ed": 6, "text": "hardware design"}, {"st": 12, "ed": 15, "text": "hardware description language"}, {"st": 16, "ed": 18, "text": "logic level"}, {"st": 20, "ed": 22, "text": "extensive verification"}, {"st": 32, "ed": 34, "text": "significant time"}, {"st": 46, "ed": 49, "text": "formal specification language"}, {"st": 53, "ed": 57, "text": "level hardware description language"}, {"st": 61, "ed": 63, "text": "formal specification"}, {"st": 64, "ed": 66, "text": "Bloem et.al"}, {"st": 68, "ed": 70, "text": "formal specifications"}, {"st": 73, "ed": 76, "text": "AMBA AHB Arbiter"}, {"st": 88, "ed": 91, "text": "compact formal specifications"}, {"st": 93, "ed": 96, "text": "AMBA AHB Arbiter"}, {"st": 107, "ed": 109, "text": "synthesis results"}, {"st": 122, "ed": 124, "text": "synthesize circuit"}, {"st": 131, "ed": 133, "text": "formal specification"}, {"st": 137, "ed": 139, "text": "compact circuits"}, {"st": 146, "ed": 149, "text": "AMBA AHB protocol"}, {"st": 153, "ed": 156, "text": "AMBA AHB Master"}, {"st": 157, "ed": 160, "text": "AMBA AHB Slave"}, {"st": 170, "ed": 173, "text": "present few principles"}, {"st": 175, "ed": 177, "text": "formal specifications"}, {"st": 178, "ed": 181, "text": "efficient hardware synthesis"}, {"st": 186, "ed": 189, "text": "complete formal specifications"}, {"st": 200, "ed": 202, "text": "industrial protocol"}]
[{"st": 1, "ed": 3, "text": "finiteness structure"}, {"st": 4, "ed": 6, "text": "resource terms"}]
[{"st": 2, "ed": 5, "text": "paper \" Uniformity"}, {"st": 7, "ed": 9, "text": "Taylor expansion"}, {"st": 17, "ed": 19, "text": "Laurent Regnier"}, {"st": 30, "ed": 33, "text": "infinite linear combinations"}, {"st": 57, "ed": 60, "text": "differential linear logic"}, {"st": 61, "ed": 63, "text": "differential lambda"}, {"st": 67, "ed": 69, "text": "good properties"}, {"st": 71, "ed": 73, "text": "translation wrt"}, {"st": 81, "ed": 83, "text": "coherence relation"}, {"st": 84, "ed": 86, "text": "resource terms"}, {"st": 92, "ed": 94, "text": "stable \""}, {"st": 100, "ed": 103, "text": "coherence space semantics"}, {"st": 104, "ed": 106, "text": "linear logic"}, {"st": 110, "ed": 112, "text": "coherence relation"}, {"st": 113, "ed": 116, "text": "Such coherence properties"}, {"st": 125, "ed": 127, "text": "algebraic extensions"}, {"st": 157, "ed": 161, "text": "\" finiteness structure \""}, {"st": 162, "ed": 164, "text": "resource terms"}, {"st": 169, "ed": 172, "text": "vector space structure"}, {"st": 179, "ed": 181, "text": "infinite coefficients"}, {"st": 185, "ed": 187, "text": "typed settings"}]
[]
[{"st": 9, "ed": 11, "text": "different ways"}, {"st": 60, "ed": 62, "text": "model theory"}, {"st": 76, "ed": 78, "text": "essence operator"}, {"st": 80, "ed": 82, "text": "accident operator"}, {"st": 85, "ed": 88, "text": "only primitive modality"}, {"st": 102, "ed": 104, "text": "modal logic"}, {"st": 107, "ed": 109, "text": "reflexive models"}, {"st": 118, "ed": 120, "text": "reflexive models"}, {"st": 125, "ed": 127, "text": "frame properties"}, {"st": 144, "ed": 146, "text": "suitable bisimulation"}, {"st": 156, "ed": 158, "text": "expressive power"}, {"st": 162, "ed": 164, "text": "modal logic"}, {"st": 168, "ed": 170, "text": "order logic"}, {"st": 176, "ed": 179, "text": "various frame classes"}, {"st": 183, "ed": 185, "text": "symmetric case"}, {"st": 207, "ed": 209, "text": "certain axioms"}, {"st": 215, "ed": 217, "text": "special frames"}, {"st": 223, "ed": 225, "text": "side effect"}, {"st": 229, "ed": 231, "text": "open questions"}]
[{"st": 3, "ed": 6, "text": "central soft sets"}, {"st": 9, "ed": 11, "text": "basic operations"}]
[{"st": 5, "ed": 7, "text": "new kind"}, {"st": 8, "ed": 10, "text": "soft sets"}, {"st": 13, "ed": 15, "text": "common decision"}, {"st": 18, "ed": 20, "text": "real life"}, {"st": 21, "ed": 24, "text": "central soft sets"}, {"st": 30, "ed": 32, "text": "basic operations"}, {"st": 33, "ed": 36, "text": "central soft sets"}, {"st": 44, "ed": 46, "text": "classic operations"}, {"st": 47, "ed": 49, "text": "soft sets"}, {"st": 53, "ed": 56, "text": "central soft sets"}, {"st": 58, "ed": 61, "text": "different central sets"}, {"st": 68, "ed": 70, "text": "evaluation system"}, {"st": 76, "ed": 78, "text": "optional solutions"}, {"st": 85, "ed": 89, "text": "such decision making problems"}]
[{"st": 1, "ed": 5, "text": "Successive Rough Set Approximations"}]
[{"st": 2, "ed": 5, "text": "double successive approximations"}, {"st": 16, "ed": 18, "text": "\\ U_2U_1"}, {"st": 41, "ed": 44, "text": "equivalent equivalence relations"}, {"st": 55, "ed": 57, "text": "finite non"}, {"st": 87, "ed": 89, "text": "equivalence relations"}, {"st": 108, "ed": 110, "text": "unique solutions"}, {"st": 134, "ed": 136, "text": "relation pairs"}, {"st": 142, "ed": 145, "text": "unique such operators"}]
[{"st": 3, "ed": 5, "text": "categorical model"}]
[{"st": 6, "ed": 9, "text": "abstract model theory"}, {"st": 11, "ed": 13, "text": "untyped differential"}, {"st": 18, "ed": 20, "text": "resource calculus"}, {"st": 26, "ed": 28, "text": "general definition"}, {"st": 38, "ed": 41, "text": "linear reflexive object"}, {"st": 45, "ed": 47, "text": "differential category"}]
[{"st": 1, "ed": 3, "text": "Safety Properties"}, {"st": 5, "ed": 8, "text": "TLA+ Proof System"}]
[{"st": 3, "ed": 6, "text": "TLA+ proof system"}, {"st": 14, "ed": 16, "text": "mechanical verification"}, {"st": 17, "ed": 19, "text": "TLA+ proofs"}, {"st": 22, "ed": 24, "text": "declarative style"}, {"st": 25, "ed": 27, "text": "little background"}, {"st": 28, "ed": 30, "text": "elementary mathematics"}, {"st": 38, "ed": 41, "text": "linear proof construction"}, {"st": 50, "ed": 52, "text": "verification tool"}, {"st": 56, "ed": 58, "text": "Proof Manager"}, {"st": 63, "ed": 65, "text": "theorem provers"}, {"st": 66, "ed": 68, "text": "proof assistants"}, {"st": 69, "ed": 71, "text": "SMT solvers"}, {"st": 73, "ed": 75, "text": "decision procedures"}, {"st": 77, "ed": 79, "text": "TLA+ proofs"}, {"st": 81, "ed": 83, "text": "paper documents"}, {"st": 84, "ed": 87, "text": "first public release"}, {"st": 105, "ed": 107, "text": "temporal part"}, {"st": 113, "ed": 115, "text": "temporal reasoning"}, {"st": 118, "ed": 121, "text": "standard safety properties"}, {"st": 123, "ed": 125, "text": "particular invariance"}, {"st": 126, "ed": 128, "text": "step simulation"}, {"st": 131, "ed": 133, "text": "liveness properties"}]
[{"st": 1, "ed": 3, "text": "Algebraic Treatment"}]
[{"st": 4, "ed": 6, "text": "principal methods"}, {"st": 12, "ed": 14, "text": "process algebra"}, {"st": 22, "ed": 24, "text": "algebraic approach"}, {"st": 31, "ed": 33, "text": "unguarded recursion"}]
[{"st": 7, "ed": 12, "text": "QBF Solver Beyond Traditional QCDCL"}]
[{"st": 8, "ed": 11, "text": "quantified Boolean formula"}, {"st": 14, "ed": 16, "text": "solver DepQBF"}, {"st": 31, "ed": 34, "text": "driven clause learning"}, {"st": 43, "ed": 46, "text": "art propositional satisfiability"}, {"st": 54, "ed": 56, "text": "resolution calculus"}, {"st": 61, "ed": 64, "text": "QBF proof system"}, {"st": 68, "ed": 70, "text": "QCDCL solvers"}, {"st": 72, "ed": 74, "text": "QRES proofs"}, {"st": 77, "ed": 81, "text": "prenex conjunctive normal form"}, {"st": 95, "ed": 97, "text": "traditional QCDCL"}, {"st": 125, "ed": 127, "text": "additional axioms"}, {"st": 130, "ed": 132, "text": "original Q"}, {"st": 133, "ed": 135, "text": "resolution rules"}, {"st": 150, "ed": 152, "text": "traditional QCDCL"}, {"st": 166, "ed": 168, "text": "experimental results"}, {"st": 173, "ed": 175, "text": "generalized QRES"}]
[{"st": 1, "ed": 4, "text": "New Execution Model"}, {"st": 8, "ed": 11, "text": "hereditary Harrop formulas"}]
[{"st": 5, "ed": 9, "text": "order Hereditary Harrop formulas"}, {"st": 22, "ed": 24, "text": "order Horn"}, {"st": 27, "ed": 29, "text": "operational semantics"}, {"st": 32, "ed": 34, "text": "intuitionistic provability"}, {"st": 38, "ed": 40, "text": "operational semantics"}, {"st": 47, "ed": 49, "text": "game semantics"}, {"st": 51, "ed": 53, "text": "new semantics"}, {"st": 54, "ed": 57, "text": "several interesting aspects"}, {"st": 64, "ed": 66, "text": "logical status"}, {"st": 69, "ed": 71, "text": "read$ predicate"}]
[{"st": 3, "ed": 7, "text": "Handle Linear Temporal Properties"}, {"st": 9, "ed": 12, "text": "o-)Regular Model Checking"}]
[{"st": 4, "ed": 6, "text": "several years"}, {"st": 10, "ed": 13, "text": "regular model checking"}, {"st": 21, "ed": 23, "text": "state reachability"}, {"st": 24, "ed": 26, "text": "safety properties"}, {"st": 32, "ed": 35, "text": "linear temporal properties"}, {"st": 51, "ed": 53, "text": "corresponding details"}, {"st": 63, "ed": 65, "text": "regular model"}, {"st": 75, "ed": 77, "text": "infinite words"}, {"st": 82, "ed": 84, "text": "exact constructions"}, {"st": 94, "ed": 96, "text": "partial solution"}, {"st": 104, "ed": 106, "text": "infinite computations"}, {"st": 107, "ed": 109, "text": "unbounded configurations"}, {"st": 113, "ed": 115, "text": "same configuration"}, {"st": 119, "ed": 122, "text": "cycle detection problematic"}]
[{"st": 4, "ed": 6, "text": "Checking Emptiness"}, {"st": 7, "ed": 9, "text": "Buechi Automata"}]
[{"st": 14, "ed": 16, "text": "state systems"}, {"st": 17, "ed": 19, "text": "Typical solutions"}, {"st": 33, "ed": 35, "text": "Buechi emptiness"}, {"st": 41, "ed": 43, "text": "linear time"}, {"st": 51, "ed": 53, "text": "property exist"}, {"st": 56, "ed": 59, "text": "subtle design decisions"}, {"st": 62, "ed": 64, "text": "great difference"}, {"st": 66, "ed": 68, "text": "actual performance"}, {"st": 89, "ed": 92, "text": "large benchmark suite"}, {"st": 98, "ed": 100, "text": "time performance"}, {"st": 102, "ed": 104, "text": "propose improvements"}, {"st": 138, "ed": 141, "text": "state model checking"}]
[{"st": 0, "ed": 3, "text": "Modular Complexity Analysis"}, {"st": 4, "ed": 6, "text": "Term Rewriting"}]
[{"st": 1, "ed": 3, "text": "current investigations"}, {"st": 6, "ed": 8, "text": "derivational complexity"}, {"st": 9, "ed": 12, "text": "term rewrite systems"}, {"st": 16, "ed": 19, "text": "single termination method"}, {"st": 28, "ed": 30, "text": "exclusive use"}, {"st": 31, "ed": 33, "text": "direct criteria"}, {"st": 38, "ed": 40, "text": "restricted power"}, {"st": 49, "ed": 51, "text": "modular framework"}, {"st": 58, "ed": 60, "text": "upper bounds"}, {"st": 64, "ed": 67, "text": "term rewrite systems"}, {"st": 69, "ed": 71, "text": "different criteria"}, {"st": 74, "ed": 76, "text": "fundamental idea"}, {"st": 79, "ed": 81, "text": "relative rewriting"}, {"st": 85, "ed": 87, "text": "matrix interpretations"}, {"st": 100, "ed": 102, "text": "relative rewriting"}, {"st": 106, "ed": 108, "text": "modular framework"}, {"st": 115, "ed": 117, "text": "conventional setting"}, {"st": 128, "ed": 130, "text": "significant gains"}]
[{"st": 0, "ed": 3, "text": "Proof Pattern Search"}, {"st": 4, "ed": 7, "text": "Coq / SSReflect"}]
[{"st": 6, "ed": 9, "text": "Proof General interface"}, {"st": 17, "ed": 19, "text": "learning algorithms"}, {"st": 21, "ed": 23, "text": "proof similarities"}, {"st": 24, "ed": 28, "text": "Coq / SSReect libraries"}, {"st": 36, "ed": 38, "text": "new improvements"}, {"st": 44, "ed": 46, "text": "new method"}, {"st": 47, "ed": 49, "text": "\" recurrent"}, {"st": 55, "ed": 57, "text": "statistical features"}, {"st": 58, "ed": 60, "text": "Coq terms"}, {"st": 68, "ed": 70, "text": "similar definitions"}, {"st": 73, "ed": 75, "text": "lemma statements"}, {"st": 84, "ed": 86, "text": "Coq proofs"}, {"st": 92, "ed": 94, "text": "proof strategies"}, {"st": 98, "ed": 100, "text": "different stages"}, {"st": 115, "ed": 117, "text": "shape representation"}, {"st": 118, "ed": 120, "text": "proof patterns"}]
[{"st": 1, "ed": 3, "text": "Bisimilarity Checking"}]
[{"st": 0, "ed": 2, "text": "Recent studies"}, {"st": 13, "ed": 16, "text": "Basic Parallel Process"}, {"st": 20, "ed": 24, "text": "normed Basic Process Algebra"}, {"st": 36, "ed": 38, "text": "other models"}, {"st": 44, "ed": 47, "text": "Process Rewrite System"}, {"st": 62, "ed": 64, "text": "branching bisimilarity"}, {"st": 70, "ed": 72, "text": "Counter Net"}, {"st": 76, "ed": 79, "text": "normed Process Algebra"}, {"st": 92, "ed": 94, "text": "negative answer"}]
[{"st": 3, "ed": 5, "text": "Description Logic"}]
[{"st": 6, "ed": 8, "text": "intuitionistic version"}, {"st": 10, "ed": 14, "text": "classical description logic ALC"}, {"st": 20, "ed": 23, "text": "constructive modal logics"}, {"st": 25, "ed": 27, "text": "Simpson \\cite{simpson95"}, {"st": 31, "ed": 33, "text": "description languages"}, {"st": 35, "ed": 37, "text": "hybrid logics"}, {"st": 39, "ed": 41, "text": "dePaiva \\cite{depaiva2003}."}, {"st": 42, "ed": 44, "text": "article correcta"}, {"st": 62, "ed": 65, "text": "intuitionistic hybrid logic"}, {"st": 67, "ed": 69, "text": "\\cite{depaiva2003}. Completeness"}, {"st": 70, "ed": 72, "text": "soundness proofs"}, {"st": 76, "ed": 78, "text": "brief discussion"}, {"st": 80, "ed": 82, "text": "computacional complexity"}, {"st": 83, "ed": 85, "text": "iALC provability"}, {"st": 98, "ed": 101, "text": "legal knowledge \\cite{HPR:2010a"}]
[{"st": 1, "ed": 3, "text": "Completeness Problem"}, {"st": 4, "ed": 6, "text": "Modal Logic"}]
[{"st": 3, "ed": 5, "text": "completeness problem"}, {"st": 6, "ed": 8, "text": "Modal Logic"}, {"st": 29, "ed": 31, "text": "same complexity"}, {"st": 33, "ed": 35, "text": "certain exceptions"}, {"st": 44, "ed": 46, "text": "complete formulas"}, {"st": 49, "ed": 51, "text": "upper bounds"}, {"st": 58, "ed": 60, "text": "bisimulation games"}]
[{"st": 2, "ed": 5, "text": "Style Token Machines"}, {"st": 6, "ed": 9, "text": "Quantum Lambda Calculi"}, {"st": 10, "ed": 12, "text": "Long Version"}]
[{"st": 2, "ed": 5, "text": "style token machines"}, {"st": 24, "ed": 26, "text": "linear logic"}, {"st": 34, "ed": 36, "text": "token machines"}, {"st": 64, "ed": 66, "text": "token machine"}, {"st": 82, "ed": 84, "text": "same time"}, {"st": 96, "ed": 99, "text": "simple operational semantics"}, {"st": 107, "ed": 109, "text": "quantum computation"}]
[]
[{"st": 3, "ed": 5, "text": "mathematical theory"}, {"st": 6, "ed": 8, "text": "epistemic updates"}, {"st": 12, "ed": 14, "text": "duality theory"}, {"st": 21, "ed": 23, "text": "Epistemic Actions"}, {"st": 33, "ed": 35, "text": "Moss- Solecki"}, {"st": 38, "ed": 41, "text": "common knowledge operator"}, {"st": 46, "ed": 49, "text": "product update construction"}, {"st": 53, "ed": 55, "text": "certain construction"}, {"st": 57, "ed": 59, "text": "complex algebras"}, {"st": 66, "ed": 68, "text": "complex algebra"}, {"st": 71, "ed": 73, "text": "updated model"}, {"st": 75, "ed": 77, "text": "dual characterization"}, {"st": 80, "ed": 83, "text": "much wider classes"}, {"st": 95, "ed": 97, "text": "arbitrary BAOs"}, {"st": 98, "ed": 101, "text": "arbitrary modal expansions"}, {"st": 113, "ed": 115, "text": "dual characterization"}, {"st": 119, "ed": 121, "text": "intuitionistic analogue"}, {"st": 125, "ed": 127, "text": "epistemic knowledge"}, {"st": 142, "ed": 144, "text": "IEAK w.r.t"}, {"st": 148, "ed": 150, "text": "relational models"}, {"st": 162, "ed": 165, "text": "concrete epistemic scenario"}]
[{"st": 4, "ed": 6, "text": "maximal cliques"}]
[{"st": 10, "ed": 12, "text": "primitive notion"}, {"st": 18, "ed": 21, "text": "primary logical concepts"}, {"st": 71, "ed": 73, "text": "Logical formulas"}, {"st": 86, "ed": 88, "text": "particular properties"}, {"st": 109, "ed": 111, "text": "typed objects"}, {"st": 123, "ed": 127, "text": "\" useful \" designs"}, {"st": 190, "ed": 192, "text": "minimal denotation"}, {"st": 207, "ed": 209, "text": "constructive way"}, {"st": 234, "ed": 236, "text": "alternative definition"}, {"st": 265, "ed": 267, "text": "game semantics"}]
[{"st": 0, "ed": 3, "text": "Resolution Proof Transformation"}]
[{"st": 0, "ed": 2, "text": "Verification methods"}, {"st": 9, "ed": 11, "text": "Theorem Proving"}, {"st": 19, "ed": 21, "text": "powerful tool"}, {"st": 29, "ed": 31, "text": "overall effort"}, {"st": 42, "ed": 44, "text": "minimal reason"}, {"st": 56, "ed": 58, "text": "Craig interpolants"}, {"st": 66, "ed": 68, "text": "important aspects"}, {"st": 69, "ed": 72, "text": "concern efficient handling"}, {"st": 87, "ed": 89, "text": "proof size"}, {"st": 102, "ed": 104, "text": "input problem"}, {"st": 117, "ed": 119, "text": "further processing"}, {"st": 128, "ed": 131, "text": "flexible preprocessing step"}, {"st": 134, "ed": 136, "text": "interpolant computation"}, {"st": 149, "ed": 152, "text": "local rewriting rules"}, {"st": 161, "ed": 163, "text": "careful use"}, {"st": 176, "ed": 178, "text": "effective simplification"}, {"st": 180, "ed": 182, "text": "original proofs"}, {"st": 186, "ed": 188, "text": "several heuristics"}, {"st": 190, "ed": 192, "text": "wide range"}, {"st": 193, "ed": 195, "text": "unsatisfiable problems"}, {"st": 199, "ed": 202, "text": "SMT test cases"}]
[{"st": 5, "ed": 7, "text": "Imperative Programs"}, {"st": 8, "ed": 10, "text": "Linear Logic"}]
[{"st": 12, "ed": 14, "text": "imperative programs"}, {"st": 24, "ed": 26, "text": "program constructs"}, {"st": 32, "ed": 35, "text": "natural semantics style"}, {"st": 37, "ed": 39, "text": "additional observation"}, {"st": 53, "ed": 57, "text": "natural semantics style rules"}, {"st": 67, "ed": 69, "text": "particular programs"}, {"st": 78, "ed": 80, "text": "key aspect"}, {"st": 89, "ed": 91, "text": "linear logic"}, {"st": 102, "ed": 106, "text": "natural semantics style descriptions"}, {"st": 110, "ed": 112, "text": "linear logic"}, {"st": 116, "ed": 118, "text": "logical expression"}, {"st": 129, "ed": 131, "text": "theoretic properties"}, {"st": 136, "ed": 140, "text": "natural semantics style descriptions"}, {"st": 156, "ed": 159, "text": "natural semantics rules"}, {"st": 179, "ed": 181, "text": "imperative programs"}, {"st": 185, "ed": 187, "text": "such models"}]
[{"st": 3, "ed": 6, "text": "Vector Addition Systems"}]
[{"st": 9, "ed": 11, "text": "decidability proofs"}, {"st": 14, "ed": 17, "text": "vector addition systems"}, {"st": 55, "ed": 58, "text": "complexity upper bound"}, {"st": 68, "ed": 70, "text": "decomposition technique"}, {"st": 77, "ed": 79, "text": "ideal decomposition"}, {"st": 99, "ed": 101, "text": "second part"}, {"st": 104, "ed": 106, "text": "recent results"}, {"st": 110, "ed": 112, "text": "termination thanks"}, {"st": 114, "ed": 116, "text": "quasi orders"}, {"st": 122, "ed": 126, "text": "cubic Ackermann upper bound"}, {"st": 128, "ed": 130, "text": "decomposition algorithms"}, {"st": 136, "ed": 138, "text": "upper bounds"}, {"st": 139, "ed": 142, "text": "general VAS reachability"}]
[{"st": 0, "ed": 2, "text": "Tractability Frontier"}, {"st": 3, "ed": 5, "text": "Data Complexity"}, {"st": 6, "ed": 8, "text": "Team Semantics"}]
[{"st": 3, "ed": 5, "text": "data complexity"}, {"st": 12, "ed": 14, "text": "team semantics"}, {"st": 18, "ed": 20, "text": "independence logic"}, {"st": 25, "ed": 29, "text": "tractability / intractability frontier"}, {"st": 30, "ed": 32, "text": "data complexity"}, {"st": 38, "ed": 40, "text": "quantified formulas"}, {"st": 42, "ed": 45, "text": "inclusion logic formulas"}, {"st": 51, "ed": 53, "text": "checking problem"}, {"st": 55, "ed": 57, "text": "satisfiability problem"}, {"st": 63, "ed": 66, "text": "Horn propositional formulas"}, {"st": 74, "ed": 76, "text": "alternative proof"}, {"st": 78, "ed": 80, "text": "recent result"}, {"st": 83, "ed": 85, "text": "data complexity"}, {"st": 86, "ed": 88, "text": "inclusion logic"}]
[{"st": 0, "ed": 2, "text": "Better Quasi"}, {"st": 4, "ed": 6, "text": "Transition Systems"}]
[{"st": 4, "ed": 6, "text": "model checking"}, {"st": 9, "ed": 11, "text": "state systems"}, {"st": 28, "ed": 31, "text": "general powerful technique"}, {"st": 49, "ed": 51, "text": "Several methodologies"}, {"st": 57, "ed": 59, "text": "new well"}, {"st": 61, "ed": 64, "text": "ordered constraint systems"}, {"st": 70, "ed": 72, "text": "constraint systems"}, {"st": 75, "ed": 80, "text": "\" constraint explosion problem \""}, {"st": 86, "ed": 88, "text": "generated constraints"}, {"st": 128, "ed": 131, "text": "symbolic model checking"}, {"st": 136, "ed": 138, "text": "constraint systems"}, {"st": 150, "ed": 152, "text": "main application"}, {"st": 155, "ed": 157, "text": "existential zones"}, {"st": 159, "ed": 161, "text": "constraint system"}, {"st": 167, "ed": 169, "text": "many clocks"}, {"st": 176, "ed": 178, "text": "existential zones"}, {"st": 189, "ed": 191, "text": "existential zones"}, {"st": 194, "ed": 197, "text": "timed Petri nets"}, {"st": 200, "ed": 202, "text": "experimental results"}, {"st": 211, "ed": 214, "text": "new constraint systems"}, {"st": 217, "ed": 219, "text": "broadcast protocols"}, {"st": 220, "ed": 223, "text": "lossy channel systems"}, {"st": 225, "ed": 228, "text": "integral relational automata"}, {"st": 230, "ed": 233, "text": "new constraint systems"}, {"st": 252, "ed": 254, "text": "previous methods"}]
[{"st": 2, "ed": 5, "text": "Temporal Logic Hierarchy"}, {"st": 9, "ed": 11, "text": "Confluence Property"}, {"st": 12, "ed": 15, "text": "Efficient LTL Synthesis"}]
[{"st": 1, "ed": 3, "text": "classic approaches"}, {"st": 6, "ed": 8, "text": "reactive system"}, {"st": 10, "ed": 13, "text": "linear temporal logic"}, {"st": 21, "ed": 23, "text": "LTL formula"}, {"st": 33, "ed": 35, "text": "winning strategy"}, {"st": 40, "ed": 42, "text": "regular game"}, {"st": 64, "ed": 66, "text": "determinization procedure"}, {"st": 77, "ed": 79, "text": "determinization step"}, {"st": 84, "ed": 86, "text": "tool implementations"}, {"st": 93, "ed": 95, "text": "determinization procedures"}, {"st": 105, "ed": 108, "text": "temporal logic hierarchy"}, {"st": 128, "ed": 130, "text": "Buechi automata"}, {"st": 134, "ed": 136, "text": "boolean closures"}, {"st": 143, "ed": 145, "text": "confluence property"}, {"st": 152, "ed": 154, "text": "certain translations"}, {"st": 155, "ed": 157, "text": "LTL formulas"}, {"st": 162, "ed": 164, "text": "symbolic implementations"}, {"st": 165, "ed": 167, "text": "determinization procedures"}, {"st": 176, "ed": 179, "text": "Hayashi breakpoint construction"}, {"st": 186, "ed": 188, "text": "experimental results"}, {"st": 191, "ed": 193, "text": "practical applicability"}, {"st": 195, "ed": 198, "text": "new synthesis procedure"}]
[{"st": 0, "ed": 3, "text": "Efficient Symmetry Reduction"}, {"st": 7, "ed": 9, "text": "State Symmetries"}, {"st": 10, "ed": 13, "text": "Symbolic Model Checking"}]
[{"st": 7, "ed": 10, "text": "space explosion problem"}, {"st": 11, "ed": 15, "text": "temporal logic model checking"}, {"st": 16, "ed": 18, "text": "symmetry reduction"}, {"st": 22, "ed": 24, "text": "symmetry reduction"}, {"st": 25, "ed": 28, "text": "symbolic model checking"}, {"st": 33, "ed": 35, "text": "long time"}, {"st": 38, "ed": 40, "text": "large BDD"}, {"st": 42, "ed": 44, "text": "orbit relation"}, {"st": 45, "ed": 48, "text": "Dynamic symmetry reduction"}, {"st": 51, "ed": 53, "text": "equivalence classes"}, {"st": 63, "ed": 65, "text": "orbit relation"}, {"st": 73, "ed": 76, "text": "new efficient model"}, {"st": 80, "ed": 83, "text": "dynamic symmetry reduction"}, {"st": 107, "ed": 109, "text": "state symmetries"}, {"st": 110, "ed": 113, "text": "symbolic symmetry reduction"}, {"st": 123, "ed": 125, "text": "state symmetries"}, {"st": 130, "ed": 133, "text": "symbolic model checking"}]
[]
[{"st": 6, "ed": 8, "text": "termination problem"}, {"st": 10, "ed": 12, "text": "Turing machine"}, {"st": 15, "ed": 17, "text": "simplified form"}, {"st": 19, "ed": 22, "text": "Post correspondence problem"}, {"st": 32, "ed": 35, "text": "time Markov chain"}, {"st": 43, "ed": 45, "text": "rewriting rules"}, {"st": 57, "ed": 59, "text": "computable CTMC"}]
[{"st": 3, "ed": 5, "text": "measurement outcomes"}, {"st": 11, "ed": 13, "text": "commutative algebras"}]
[{"st": 5, "ed": 7, "text": "hidden variables"}, {"st": 21, "ed": 24, "text": "partial measurement outcomes"}, {"st": 28, "ed": 31, "text": "double negation sheafification"}, {"st": 37, "ed": 39, "text": "measurement outcomes"}, {"st": 45, "ed": 47, "text": "commutative C*-algebras"}]
[{"st": 2, "ed": 5, "text": "payoff Automaton Expressions"}]
[{"st": 0, "ed": 2, "text": "Quantitative languages"}, {"st": 6, "ed": 8, "text": "boolean languages"}, {"st": 14, "ed": 16, "text": "real number"}, {"st": 19, "ed": 21, "text": "payoff automata"}, {"st": 22, "ed": 24, "text": "finite automata"}, {"st": 25, "ed": 27, "text": "numerical weights"}, {"st": 33, "ed": 35, "text": "infinite path"}, {"st": 38, "ed": 40, "text": "run average"}, {"st": 42, "ed": 44, "text": "transition weights"}, {"st": 62, "ed": 64, "text": "corresponding class"}, {"st": 65, "ed": 67, "text": "quantitative languages"}, {"st": 77, "ed": 79, "text": "pointwise operations"}, {"st": 87, "ed": 89, "text": "numerical complement"}, {"st": 95, "ed": 97, "text": "payoff automata"}, {"st": 104, "ed": 106, "text": "quantitative generalization"}, {"st": 112, "ed": 114, "text": "language inclusion"}, {"st": 120, "ed": 122, "text": "new class"}, {"st": 123, "ed": 125, "text": "quantitative languages"}, {"st": 130, "ed": 133, "text": "payoff automaton expressions"}, {"st": 146, "ed": 148, "text": "pointwise operations"}, {"st": 154, "ed": 156, "text": "decision problems"}, {"st": 164, "ed": 167, "text": "payoff automaton expressions"}, {"st": 168, "ed": 170, "text": "deterministic mean"}, {"st": 171, "ed": 173, "text": "payoff automata"}, {"st": 180, "ed": 182, "text": "expressive power"}, {"st": 189, "ed": 191, "text": "payoff automata"}, {"st": 197, "ed": 199, "text": "first time"}, {"st": 206, "ed": 208, "text": "quantitative languages"}, {"st": 214, "ed": 216, "text": "quantitative languages"}, {"st": 221, "ed": 224, "text": "payoff automaton expressions"}]
[]
[{"st": 3, "ed": 5, "text": "close relationship"}, {"st": 6, "ed": 8, "text": "abstract machines"}, {"st": 33, "ed": 35, "text": "sequent calculus"}, {"st": 39, "ed": 41, "text": "way Curien"}, {"st": 44, "ed": 46, "text": "syntactic kit"}, {"st": 59, "ed": 61, "text": "term language"}, {"st": 79, "ed": 81, "text": "cut elimination"}, {"st": 83, "ed": 85, "text": "non confluent"}, {"st": 89, "ed": 91, "text": "key slogan"}, {"st": 101, "ed": 103, "text": "first time"}, {"st": 106, "ed": 110, "text": "commutative cut elimination rules"}, {"st": 111, "ed": 115, "text": "explicit substitution propagation rules"}, {"st": 120, "ed": 124, "text": "focalised proof search discipline"}, {"st": 127, "ed": 129, "text": "classical setting"}, {"st": 138, "ed": 140, "text": "rewriting rules"}, {"st": 142, "ed": 144, "text": "confluent calculus"}, {"st": 149, "ed": 151, "text": "second author"}, {"st": 152, "ed": 155, "text": "focalising system L"}, {"st": 173, "ed": 175, "text": "finitary syntax"}, {"st": 177, "ed": 179, "text": "synthetic presentation"}, {"st": 180, "ed": 182, "text": "classical logic"}, {"st": 200, "ed": 202, "text": "negative connectives"}]
[{"st": 4, "ed": 6, "text": "Functional Interpretation"}]
[{"st": 4, "ed": 6, "text": "short paper"}, {"st": 10, "ed": 12, "text": "practical introduction"}, {"st": 13, "ed": 15, "text": "functional interpretation"}, {"st": 18, "ed": 20, "text": "computer scientists"}]
[{"st": 1, "ed": 3, "text": "general translation"}, {"st": 5, "ed": 7, "text": "Petri nets"}]
[{"st": 1, "ed": 3, "text": "Petri nets"}, {"st": 8, "ed": 10, "text": "interaction protocols"}, {"st": 13, "ed": 15, "text": "adaptive systems"}, {"st": 16, "ed": 18, "text": "interorganizational workflows"}, {"st": 21, "ed": 23, "text": "few results"}, {"st": 30, "ed": 32, "text": "automated tools"}, {"st": 46, "ed": 48, "text": "general translation"}, {"st": 50, "ed": 52, "text": "Petri nets"}, {"st": 66, "ed": 69, "text": "SPIN model checker"}, {"st": 79, "ed": 81, "text": "main limitations"}, {"st": 84, "ed": 86, "text": "SPIN performance"}, {"st": 88, "ed": 90, "text": "practical examples"}]
[{"st": 1, "ed": 4, "text": "Multiple Boolean Functions"}, {"st": 8, "ed": 10, "text": "Single Proof"}]
[{"st": 8, "ed": 10, "text": "Boolean controller"}, {"st": 12, "ed": 14, "text": "complex system"}, {"st": 38, "ed": 40, "text": "pipelined processor"}, {"st": 46, "ed": 48, "text": "visible behavior"}, {"st": 50, "ed": 52, "text": "pipelined system"}, {"st": 60, "ed": 62, "text": "reference system"}, {"st": 65, "ed": 67, "text": "Dill paradigm"}, {"st": 72, "ed": 74, "text": "novel procedure"}, {"st": 77, "ed": 81, "text": "multiple Boolean control signals"}, {"st": 90, "ed": 92, "text": "order formula"}, {"st": 103, "ed": 105, "text": "uninterpreted functions"}, {"st": 115, "ed": 118, "text": "unsatisfiable SMT formula"}, {"st": 137, "ed": 139, "text": "Craig interpolation"}, {"st": 141, "ed": 144, "text": "multiple coordinated interpolants"}, {"st": 147, "ed": 150, "text": "Boolean control signals"}, {"st": 152, "ed": 156, "text": "method avoids iterative learning"}, {"st": 162, "ed": 164, "text": "control functions"}, {"st": 183, "ed": 187, "text": "present first experimental results"}]
[{"st": 0, "ed": 2, "text": "Satisfiability Games"}, {"st": 5, "ed": 7, "text": "Time Logics"}]
[{"st": 1, "ed": 3, "text": "satisfiability problem"}, {"st": 6, "ed": 9, "text": "time temporal logics"}, {"st": 10, "ed": 12, "text": "CTL *"}, {"st": 17, "ed": 19, "text": "important applications"}, {"st": 20, "ed": 22, "text": "program specification"}, {"st": 26, "ed": 28, "text": "computational complexities"}, {"st": 31, "ed": 33, "text": "CTL *"}, {"st": 39, "ed": 41, "text": "exponential time"}, {"st": 46, "ed": 49, "text": "single exponential time"}, {"st": 51, "ed": 53, "text": "decision procedures"}, {"st": 61, "ed": 63, "text": "tree automata"}, {"st": 66, "ed": 68, "text": "axiom systems"}, {"st": 75, "ed": 77, "text": "uniform game"}, {"st": 78, "ed": 80, "text": "theoretic framework"}, {"st": 82, "ed": 84, "text": "satisfiability problem"}, {"st": 88, "ed": 91, "text": "time temporal logics"}, {"st": 94, "ed": 96, "text": "satisfiability games"}, {"st": 98, "ed": 100, "text": "full branching"}, {"st": 101, "ed": 106, "text": "time temporal logic CTL *"}, {"st": 110, "ed": 112, "text": "level definition"}, {"st": 125, "ed": 127, "text": "fixpoint unfoldings"}, {"st": 132, "ed": 134, "text": "formal languages"}, {"st": 171, "ed": 173, "text": "B\\\"uchi games"}, {"st": 177, "ed": 179, "text": "case complexity"}, {"st": 202, "ed": 204, "text": "optimal treatment"}, {"st": 209, "ed": 212, "text": "time temporal logics"}, {"st": 218, "ed": 221, "text": "temporal logic machinery"}, {"st": 229, "ed": 231, "text": "syntactical relationship"}, {"st": 233, "ed": 235, "text": "input formula"}, {"st": 250, "ed": 252, "text": "B\\\"uchi game"}, {"st": 262, "ed": 264, "text": "Ladner closure"}, {"st": 266, "ed": 268, "text": "input formula"}, {"st": 285, "ed": 287, "text": "tool support"}, {"st": 289, "ed": 291, "text": "satisfiability problem"}, {"st": 295, "ed": 297, "text": "time logics"}, {"st": 298, "ed": 300, "text": "CTL *"}]
[{"st": 0, "ed": 2, "text": "Implicit Resolution"}]
[{"st": 6, "ed": 8, "text": "unsatisfiable clauses"}, {"st": 10, "ed": 13, "text": "implicit resolution refutation"}, {"st": 17, "ed": 19, "text": "circuit \\beta"}, {"st": 21, "ed": 23, "text": "resolution proof"}, {"st": 28, "ed": 31, "text": "statement \" \\beta"}, {"st": 37, "ed": 39, "text": "resolution refutation"}, {"st": 40, "ed": 42, "text": "\\Omega \""}, {"st": 46, "ed": 48, "text": "such system"}, {"st": 53, "ed": 55, "text": "Extended Frege"}, {"st": 68, "ed": 70, "text": "[ P"}, {"st": 92, "ed": 95, "text": "statement \" \\beta"}, {"st": 100, "ed": 102, "text": "correct Q"}, {"st": 105, "ed": 107, "text": "\\tau \""}, {"st": 111, "ed": 113, "text": "[ EF"}, {"st": 114, "ed": 120, "text": "P ] \\leq p [ R"}, {"st": 121, "ed": 123, "text": "P ]"}, {"st": 124, "ed": 126, "text": "arbitrary Cook"}, {"st": 127, "ed": 131, "text": "Reckhow proof system P."}]
[{"st": 0, "ed": 2, "text": "Homomorphism Preservation"}, {"st": 5, "ed": 7, "text": "Wide Classes"}]
[{"st": 11, "ed": 13, "text": "preservation property"}, {"st": 19, "ed": 21, "text": "order formula"}, {"st": 35, "ed": 37, "text": "positive formula"}, {"st": 50, "ed": 52, "text": "finite structures"}, {"st": 57, "ed": 59, "text": "previous work"}, {"st": 74, "ed": 76, "text": "latter results"}, {"st": 84, "ed": 86, "text": "wide class"}, {"st": 92, "ed": 94, "text": "wide class"}, {"st": 101, "ed": 103, "text": "disjoint unions"}, {"st": 107, "ed": 109, "text": "preservation property"}, {"st": 121, "ed": 123, "text": "bounded expansion"}, {"st": 126, "ed": 128, "text": "exclude minors"}, {"st": 142, "ed": 144, "text": "finite structures"}, {"st": 150, "ed": 152, "text": "disjoint unions"}, {"st": 159, "ed": 161, "text": "preservation property"}]
[]
[{"st": 7, "ed": 9, "text": "Emacs interface"}, {"st": 21, "ed": 23, "text": "ACL2 user"}, {"st": 44, "ed": 46, "text": "similar theorems"}, {"st": 49, "ed": 51, "text": "auxiliary lemmas"}, {"st": 62, "ed": 64, "text": "recent extensions"}, {"st": 77, "ed": 80, "text": "similar function definitions"}, {"st": 87, "ed": 89, "text": "similar theorems"}, {"st": 93, "ed": 96, "text": "lemma generation tool"}, {"st": 111, "ed": 113, "text": "guard mechanism"}, {"st": 126, "ed": 128, "text": "latter extension"}, {"st": 133, "ed": 135, "text": "own conjectures"}]
[{"st": 1, "ed": 4, "text": "Branching Time Model"}]
[{"st": 3, "ed": 6, "text": "branching time model"}, {"st": 13, "ed": 15, "text": "other models"}, {"st": 27, "ed": 29, "text": "semantic equivalence"}, {"st": 31, "ed": 33, "text": "linear time"}, {"st": 34, "ed": 37, "text": "branching time spectrum"}, {"st": 41, "ed": 44, "text": "preserving coupled similarity"}, {"st": 63, "ed": 65, "text": "bisimulation family"}, {"st": 66, "ed": 68, "text": "semantic equivalences"}, {"st": 74, "ed": 76, "text": "transition systems"}, {"st": 77, "ed": 79, "text": "internal actions"}, {"st": 82, "ed": 84, "text": "strong bisimilarity"}, {"st": 90, "ed": 92, "text": "equational laws"}, {"st": 98, "ed": 100, "text": "complete axiomatisation"}, {"st": 105, "ed": 107, "text": "free terms"}]
[{"st": 2, "ed": 4, "text": "Coinductive Components"}, {"st": 5, "ed": 7, "text": "Corecursive Functions"}]
[{"st": 1, "ed": 4, "text": "Constructive Type Theory"}, {"st": 7, "ed": 9, "text": "corecursive definitions"}, {"st": 12, "ed": 14, "text": "syntactic restrictions"}, {"st": 18, "ed": 20, "text": "recursive functions"}, {"st": 23, "ed": 25, "text": "corecursive functions"}, {"st": 28, "ed": 30, "text": "many terminating"}, {"st": 31, "ed": 33, "text": "productive functions"}, {"st": 37, "ed": 39, "text": "syntactic tests"}, {"st": 46, "ed": 48, "text": "elegant reformulation"}, {"st": 52, "ed": 54, "text": "accessibility predicates"}, {"st": 59, "ed": 62, "text": "terminative recursive functions"}, {"st": 64, "ed": 67, "text": "Constructive Type Theory"}, {"st": 75, "ed": 77, "text": "same goal"}, {"st": 78, "ed": 81, "text": "productive corecursive functions"}, {"st": 89, "ed": 91, "text": "coinductive definitions"}, {"st": 92, "ed": 94, "text": "productive functions"}, {"st": 104, "ed": 106, "text": "hoc predicates"}, {"st": 110, "ed": 112, "text": "systematic algorithm"}, {"st": 117, "ed": 119, "text": "coinductive parts"}]
[{"st": 1, "ed": 3, "text": "Timed Automata"}]
[{"st": 13, "ed": 15, "text": "such automata"}, {"st": 20, "ed": 23, "text": "decidable emptiness problem"}, {"st": 24, "ed": 26, "text": "finite words"}, {"st": 30, "ed": 32, "text": "new class"}, {"st": 33, "ed": 35, "text": "timed languages"}, {"st": 39, "ed": 41, "text": "boolean operations"}, {"st": 45, "ed": 47, "text": "effective presentation"}, {"st": 55, "ed": 57, "text": "emptiness problem"}, {"st": 67, "ed": 69, "text": "primitive recursive"}, {"st": 80, "ed": 82, "text": "universality problem"}, {"st": 108, "ed": 110, "text": "infinite words"}, {"st": 116, "ed": 118, "text": "universality problem"}]
[{"st": 1, "ed": 3, "text": "Fixpoint Semantics"}, {"st": 4, "ed": 6, "text": "Event Systems"}, {"st": 9, "ed": 11, "text": "Fairness Assumptions"}]
[{"st": 3, "ed": 5, "text": "fixpoint semantics"}, {"st": 6, "ed": 8, "text": "event systems"}, {"st": 15, "ed": 17, "text": "general framework"}, {"st": 39, "ed": 41, "text": "general framework"}, {"st": 43, "ed": 45, "text": "general framework"}, {"st": 51, "ed": 54, "text": "weak fairness assumptions"}, {"st": 55, "ed": 57, "text": "similar results"}, {"st": 69, "ed": 71, "text": "sufficient conditions"}, {"st": 78, "ed": 80, "text": "minimal progress"}, {"st": 83, "ed": 85, "text": "proof obligations"}]
[{"st": 4, "ed": 6, "text": "Boolean Categories"}]
[{"st": 3, "ed": 5, "text": "Boolean category"}, {"st": 19, "ed": 21, "text": "Boolean algebra"}, {"st": 29, "ed": 31, "text": "Boolean category"}, {"st": 34, "ed": 37, "text": "abstract algebraic structure"}, {"st": 41, "ed": 43, "text": "Boolean Logic"}, {"st": 46, "ed": 48, "text": "same sense"}, {"st": 57, "ed": 59, "text": "intuitionistic logic"}, {"st": 61, "ed": 64, "text": "* -autonomous category"}, {"st": 68, "ed": 70, "text": "linear logic"}, {"st": 73, "ed": 75, "text": "recent work"}, {"st": 81, "ed": 83, "text": "canonical axiomatisation"}, {"st": 85, "ed": 87, "text": "Boolean category"}, {"st": 103, "ed": 106, "text": "possible such axiomatisations"}, {"st": 113, "ed": 116, "text": "* -autonomous category"}, {"st": 123, "ed": 125, "text": "medial map"}, {"st": 132, "ed": 134, "text": "inference rule"}, {"st": 140, "ed": 143, "text": "free deductive system"}, {"st": 144, "ed": 146, "text": "Boolean logic"}, {"st": 160, "ed": 162, "text": "proof nets"}, {"st": 171, "ed": 173, "text": "Boolean category"}]
[{"st": 2, "ed": 4, "text": "Dependent Types"}]
[{"st": 5, "ed": 8, "text": "dependent type theory"}, {"st": 18, "ed": 20, "text": "intensional Id"}, {"st": 28, "ed": 30, "text": "slight variation"}, {"st": 40, "ed": 43, "text": "free winning strategies"}, {"st": 54, "ed": 56, "text": "function extensionality"}, {"st": 62, "ed": 64, "text": "identity proofs"}, {"st": 75, "ed": 77, "text": "full subcategory"}, {"st": 80, "ed": 82, "text": "faithful model"}, {"st": 91, "ed": 93, "text": "intensional Id"}, {"st": 99, "ed": 103, "text": "finite inductive type families"}, {"st": 121, "ed": 123, "text": "type hierarchy"}, {"st": 143, "ed": 145, "text": "positive occurrence"}, {"st": 154, "ed": 157, "text": "full type hierarchy"}]
[{"st": 0, "ed": 2, "text": "Coalgebraic completeness"}, {"st": 7, "ed": 10, "text": "distributive substructural logics"}]
[{"st": 2, "ed": 4, "text": "strong completeness"}, {"st": 8, "ed": 10, "text": "substructural logics"}, {"st": 14, "ed": 16, "text": "natural poset"}, {"st": 18, "ed": 20, "text": "relational semantics"}, {"st": 22, "ed": 24, "text": "coalgebraic version"}, {"st": 39, "ed": 41, "text": "coalgebraic logics"}, {"st": 45, "ed": 47, "text": "modular theory"}, {"st": 50, "ed": 52, "text": "wide variety"}, {"st": 53, "ed": 55, "text": "different logics"}, {"st": 57, "ed": 59, "text": "single framework"}, {"st": 64, "ed": 66, "text": "further extensions"}, {"st": 73, "ed": 75, "text": "coalgebraic framework"}, {"st": 79, "ed": 81, "text": "principled way"}, {"st": 86, "ed": 88, "text": "resource models"}, {"st": 90, "ed": 92, "text": "semantics side"}, {"st": 94, "ed": 96, "text": "substructural logics"}, {"st": 98, "ed": 100, "text": "syntactic side"}]
[{"st": 3, "ed": 5, "text": "intuitionistic system"}]
[{"st": 5, "ed": 7, "text": "intuitionistic system"}, {"st": 21, "ed": 26, "text": "Plotkin Dual Intuitionistic Linear Logic"}, {"st": 29, "ed": 31, "text": "threaded programs"}, {"st": 50, "ed": 52, "text": "finite set"}, {"st": 60, "ed": 62, "text": "region usage"}, {"st": 73, "ed": 75, "text": "typable programs"}, {"st": 84, "ed": 88, "text": "region stratification guarantees termination"}]
[]
[{"st": 13, "ed": 15, "text": "logic programs"}, {"st": 28, "ed": 30, "text": "abstract substitutions"}, {"st": 43, "ed": 45, "text": "clique set"}, {"st": 64, "ed": 66, "text": "set representation"}, {"st": 95, "ed": 97, "text": "abstract functions"}, {"st": 99, "ed": 101, "text": "standard top"}, {"st": 102, "ed": 104, "text": "down analyses"}, {"st": 123, "ed": 125, "text": "experimental evaluation"}, {"st": 147, "ed": 149, "text": "precision losses"}, {"st": 153, "ed": 156, "text": "useful efficiency gains"}, {"st": 166, "ed": 168, "text": "set representation"}, {"st": 174, "ed": 176, "text": "memory capacity"}, {"st": 177, "ed": 180, "text": "classical sharing representations"}]
[{"st": 1, "ed": 3, "text": "Coinductive Calculus"}, {"st": 4, "ed": 6, "text": "Asynchronous Side"}, {"st": 7, "ed": 9, "text": "effecting Processes"}]
[{"st": 3, "ed": 5, "text": "abstract framework"}, {"st": 6, "ed": 8, "text": "concurrent processes"}, {"st": 10, "ed": 12, "text": "atomic steps"}, {"st": 13, "ed": 16, "text": "generic side effects"}, {"st": 23, "ed": 25, "text": "monadic encapsulation"}, {"st": 34, "ed": 36, "text": "infinite resumptions"}, {"st": 39, "ed": 41, "text": "final coalgebras"}, {"st": 43, "ed": 45, "text": "monadic base"}, {"st": 50, "ed": 52, "text": "such processes"}, {"st": 56, "ed": 58, "text": "concurrent extension"}, {"st": 61, "ed": 63, "text": "monadic metalanguage"}, {"st": 73, "ed": 76, "text": "natural equational axiomatisation"}, {"st": 85, "ed": 87, "text": "corecursion scheme"}, {"st": 93, "ed": 95, "text": "base language"}, {"st": 97, "ed": 100, "text": "flexible expressive means"}, {"st": 104, "ed": 106, "text": "new operators"}, {"st": 111, "ed": 113, "text": "parallel composition"}, {"st": 116, "ed": 118, "text": "worked example"}, {"st": 125, "ed": 129, "text": "generic mutual exclusion scheme"}, {"st": 131, "ed": 133, "text": "verification logic"}, {"st": 138, "ed": 140, "text": "equational calculus"}]
[{"st": 3, "ed": 5, "text": "Distributed Multi"}, {"st": 6, "ed": 8, "text": "Context Systems"}]
[{"st": 0, "ed": 3, "text": "Heterogeneous nonmonotonic multi"}, {"st": 4, "ed": 6, "text": "context systems"}, {"st": 10, "ed": 12, "text": "different logics"}, {"st": 16, "ed": 18, "text": "different contexts"}, {"st": 23, "ed": 25, "text": "bridge rules"}, {"st": 31, "ed": 33, "text": "symmetry detection"}, {"st": 37, "ed": 39, "text": "such systems"}, {"st": 41, "ed": 43, "text": "symmetric parts"}, {"st": 45, "ed": 47, "text": "search space"}, {"st": 53, "ed": 55, "text": "evaluation process"}, {"st": 59, "ed": 61, "text": "distributed algorithm"}, {"st": 64, "ed": 66, "text": "local stance"}, {"st": 72, "ed": 74, "text": "partial symmetries"}, {"st": 83, "ed": 85, "text": "potential symmetries"}, {"st": 93, "ed": 95, "text": "partial symmetries"}, {"st": 110, "ed": 113, "text": "such symmetry detection"}, {"st": 114, "ed": 116, "text": "symmetry breaking"}, {"st": 120, "ed": 122, "text": "context system"}, {"st": 127, "ed": 129, "text": "set programs"}, {"st": 132, "ed": 134, "text": "computational benefit"}]
[{"st": 2, "ed": 4, "text": "Infinite Structures"}, {"st": 5, "ed": 7, "text": "Path Logics"}]
[{"st": 4, "ed": 6, "text": "undecidability results"}, {"st": 10, "ed": 12, "text": "checking problem"}, {"st": 13, "ed": 16, "text": "infinite tree structures"}, {"st": 18, "ed": 20, "text": "tree structures"}, {"st": 27, "ed": 30, "text": "infinite relational structures"}, {"st": 38, "ed": 40, "text": "tree iteration"}, {"st": 42, "ed": 45, "text": "relational structure M"}, {"st": 56, "ed": 58, "text": "classical results"}, {"st": 75, "ed": 77, "text": "tree model"}, {"st": 78, "ed": 80, "text": "checking problem"}, {"st": 85, "ed": 87, "text": "path quantifiers"}, {"st": 88, "ed": 90, "text": "chain quantifiers"}, {"st": 104, "ed": 106, "text": "time logics"}, {"st": 111, "ed": 113, "text": "same time"}, {"st": 121, "ed": 123, "text": "level relation"}, {"st": 136, "ed": 139, "text": "same tree level"}, {"st": 145, "ed": 147, "text": "tree logic"}, {"st": 156, "ed": 159, "text": "underlying structure M."}, {"st": 165, "ed": 167, "text": "decidability results"}, {"st": 171, "ed": 173, "text": "slight extensions"}, {"st": 175, "ed": 177, "text": "framework lead"}]
[{"st": 1, "ed": 3, "text": "coinductive semantics"}, {"st": 5, "ed": 8, "text": "Unlimited Register Machine"}]
[{"st": 3, "ed": 5, "text": "co)inductive specifications"}, {"st": 14, "ed": 16, "text": "level programs"}, {"st": 18, "ed": 21, "text": "Unlimited Register Machine"}, {"st": 26, "ed": 28, "text": "Coq system"}, {"st": 30, "ed": 32, "text": "proof assistant"}, {"st": 38, "ed": 42, "text": "Co)Inductive Constructions type theory"}, {"st": 52, "ed": 54, "text": "partial functions"}, {"st": 62, "ed": 64, "text": "first step"}, {"st": 72, "ed": 74, "text": "formal analysis"}]
[{"st": 1, "ed": 4, "text": "Probabilistic Temporal Logic"}, {"st": 5, "ed": 7, "text": "Frequency Operators"}, {"st": 9, "ed": 11, "text": "Model Checking"}]
[{"st": 0, "ed": 4, "text": "Probabilistic Computation Tree Logic"}, {"st": 8, "ed": 11, "text": "Continuous Stochastic Logic"}, {"st": 21, "ed": 23, "text": "probabilistic properties"}, {"st": 24, "ed": 26, "text": "discrete time"}, {"st": 27, "ed": 29, "text": "continuous time"}, {"st": 43, "ed": 45, "text": "temporal properties"}, {"st": 51, "ed": 53, "text": "probabilistic extension"}, {"st": 55, "ed": 57, "text": "path quantifiers"}, {"st": 59, "ed": 63, "text": "basic Computation Tree Logic"}, {"st": 69, "ed": 71, "text": "path formulae"}, {"st": 77, "ed": 79, "text": "same operators"}, {"st": 94, "ed": 97, "text": "quantitative temporal properties"}, {"st": 113, "ed": 115, "text": "time points"}, {"st": 118, "ed": 121, "text": "certain bounded interval"}, {"st": 134, "ed": 137, "text": "new temporal operator"}, {"st": 148, "ed": 152, "text": "probabilistic frequency temporal logic"}, {"st": 168, "ed": 170, "text": "temporal properties"}, {"st": 173, "ed": 175, "text": "probabilistic systems"}, {"st": 184, "ed": 186, "text": "model checker"}, {"st": 188, "ed": 190, "text": "full PFTL"}, {"st": 193, "ed": 195, "text": "rich expressiveness"}, {"st": 203, "ed": 205, "text": "checking algorithm"}, {"st": 216, "ed": 219, "text": "state Markov chains"}, {"st": 222, "ed": 224, "text": "approximate model"}, {"st": 225, "ed": 227, "text": "checking algorithm"}, {"st": 229, "ed": 233, "text": "bounded Linear Temporal Logic"}, {"st": 243, "ed": 246, "text": "state Markov chains"}]
[{"st": 6, "ed": 9, "text": "polynomial time complexity"}]
[{"st": 9, "ed": 11, "text": "polynomial time"}, {"st": 17, "ed": 19, "text": "program paradigm"}, {"st": 23, "ed": 25, "text": "cut elimination"}, {"st": 31, "ed": 33, "text": "stratification principle"}, {"st": 38, "ed": 41, "text": "door \" principle"}, {"st": 48, "ed": 50, "text": "systems L^4"}, {"st": 59, "ed": 62, "text": "own complex proof"}, {"st": 63, "ed": 65, "text": "Ptime soundness"}, {"st": 72, "ed": 75, "text": "broad sufficient criterion"}, {"st": 76, "ed": 78, "text": "Ptime soundness"}, {"st": 79, "ed": 82, "text": "linear logic subsystems"}, {"st": 108, "ed": 110, "text": "future systems"}, {"st": 113, "ed": 115, "text": "additional gain"}, {"st": 121, "ed": 123, "text": "reduction strategy"}, {"st": 133, "ed": 135, "text": "particular strategy"}]
[]
[{"st": 2, "ed": 4, "text": "final chain"}, {"st": 6, "ed": 9, "text": "countable powerset functor"}, {"st": 24, "ed": 26, "text": "transition system"}, {"st": 35, "ed": 39, "text": "\" ghost \" element"}]
[{"st": 9, "ed": 11, "text": "Topological Spaces"}]
[{"st": 4, "ed": 6, "text": "\\sf V$"}, {"st": 10, "ed": 13, "text": "\\sf V\\text{-}{\\bf Top}$"}, {"st": 15, "ed": 19, "text": "\\sf V$-valued topological spaces"}, {"st": 24, "ed": 26, "text": "full subcategory"}, {"st": 30, "ed": 33, "text": "V$-valued closure spaces"}, {"st": 34, "ed": 36, "text": "closure operation"}, {"st": 37, "ed": 39, "text": "finite joins"}, {"st": 47, "ed": 49, "text": "topological spaces"}, {"st": 51, "ed": 53, "text": "lax algebras"}, {"st": 55, "ed": 57, "text": "lax extension"}, {"st": 59, "ed": 61, "text": "ultrafilter monad"}, {"st": 77, "ed": 79, "text": "V$-topological spaces"}, {"st": 88, "ed": 90, "text": "lax extension"}, {"st": 92, "ed": 94, "text": "ultrafilter monad"}, {"st": 96, "ed": 99, "text": "\\sf V$-valued relations"}, {"st": 106, "ed": 108, "text": "V\\text{-}{\\bf Top}$"}, {"st": 113, "ed": 115, "text": "topological category"}, {"st": 117, "ed": 119, "text": "\\bf Set$"}, {"st": 137, "ed": 139, "text": "free proof"}, {"st": 142, "ed": 144, "text": "V\\text{-}{\\bf Top}$"}, {"st": 146, "ed": 148, "text": "topological category"}, {"st": 150, "ed": 152, "text": "\\bf Set$"}, {"st": 155, "ed": 157, "text": "milder provision"}, {"st": 163, "ed": 165, "text": "spatial coframe"}, {"st": 172, "ed": 174, "text": "continuous lattice"}, {"st": 178, "ed": 180, "text": "complete distributivity"}, {"st": 182, "ed": 184, "text": "\\sf V$"}, {"st": 186, "ed": 188, "text": "constructive sense"}, {"st": 193, "ed": 195, "text": "ordinary sense"}]
[{"st": 3, "ed": 5, "text": "Safety Properties"}, {"st": 6, "ed": 10, "text": "Ad Hoc Network Protocols"}]
[{"st": 3, "ed": 5, "text": "main results"}, {"st": 7, "ed": 9, "text": "recent work"}, {"st": 11, "ed": 13, "text": "parameterized verification"}, {"st": 14, "ed": 16, "text": "safety properties"}, {"st": 17, "ed": 21, "text": "ad hoc network protocols"}, {"st": 29, "ed": 31, "text": "communication topology"}, {"st": 40, "ed": 43, "text": "Nodes represent states"}, {"st": 44, "ed": 46, "text": "individual processes"}, {"st": 47, "ed": 50, "text": "Adjacent nodes represent"}, {"st": 52, "ed": 54, "text": "hop neighbors"}, {"st": 57, "ed": 60, "text": "finite state automata"}, {"st": 63, "ed": 66, "text": "selective broadcast messages"}, {"st": 76, "ed": 78, "text": "hop neighbors"}, {"st": 85, "ed": 87, "text": "decision problem"}, {"st": 99, "ed": 101, "text": "initial topology"}, {"st": 120, "ed": 122, "text": "certain state"}, {"st": 124, "ed": 126, "text": "decision problem"}, {"st": 138, "ed": 140, "text": "communication topology"}, {"st": 142, "ed": 144, "text": "initial configurations"}, {"st": 148, "ed": 150, "text": "complete picture"}, {"st": 154, "ed": 156, "text": "complexity boundaries"}, {"st": 161, "ed": 163, "text": "various assumptions"}, {"st": 165, "ed": 167, "text": "possible topologies"}]
[{"st": 0, "ed": 2, "text": "Towards reduction"}, {"st": 3, "ed": 6, "text": "Paradigm coordination models"}]
[{"st": 3, "ed": 5, "text": "language Paradigm"}, {"st": 12, "ed": 14, "text": "dynamic constraints"}, {"st": 17, "ed": 19, "text": "Paradigm model"}, {"st": 20, "ed": 22, "text": "component dynamics"}, {"st": 30, "ed": 32, "text": "global level"}, {"st": 37, "ed": 39, "text": "automated verification"}, {"st": 40, "ed": 42, "text": "Paradigm models"}, {"st": 48, "ed": 50, "text": "process algebra"}, {"st": 54, "ed": 56, "text": "previous work"}, {"st": 68, "ed": 70, "text": "server example"}, {"st": 73, "ed": 75, "text": "Paradigm models"}, {"st": 80, "ed": 82, "text": "global inertness"}, {"st": 85, "ed": 87, "text": "Paradigm models"}, {"st": 97, "ed": 100, "text": "preserving equivalence relation"}, {"st": 105, "ed": 108, "text": "reduced Paradigm model"}, {"st": 116, "ed": 118, "text": "Paradigm models"}]
[{"st": 0, "ed": 2, "text": "Formal Component"}]
[{"st": 22, "ed": 25, "text": "Peter D. Mosses"}, {"st": 38, "ed": 42, "text": "modular meta theoretic reasoning"}, {"st": 55, "ed": 58, "text": "theorem prover Coq"}, {"st": 63, "ed": 65, "text": "Modular SOS"}, {"st": 73, "ed": 75, "text": "essential use"}, {"st": 76, "ed": 78, "text": "dependent types"}, {"st": 82, "ed": 84, "text": "type classes"}, {"st": 91, "ed": 95, "text": "modular meta theoretic formalizations"}, {"st": 96, "ed": 98, "text": "theorem provers"}, {"st": 101, "ed": 103, "text": "small example"}, {"st": 105, "ed": 107, "text": "modular proof"}]
[]
[{"st": 10, "ed": 13, "text": "GSOS rule format"}, {"st": 39, "ed": 41, "text": "automatic generation"}, {"st": 44, "ed": 46, "text": "complete axiomatizations"}, {"st": 49, "ed": 51, "text": "GSOS systems"}, {"st": 61, "ed": 63, "text": "SOS specifications"}, {"st": 68, "ed": 70, "text": "corresponding axiomatizations"}, {"st": 78, "ed": 80, "text": "strong bisimilarity"}, {"st": 81, "ed": 83, "text": "process terms"}]
[{"st": 0, "ed": 3, "text": "Regular Expression Matching"}, {"st": 4, "ed": 6, "text": "Operational Semantics"}]
[{"st": 0, "ed": 3, "text": "Many programming languages"}, {"st": 11, "ed": 14, "text": "Java String library"}, {"st": 16, "ed": 19, "text": "regular expression matchers"}, {"st": 25, "ed": 27, "text": "regular expression"}, {"st": 29, "ed": 32, "text": "deterministic finite automaton"}, {"st": 33, "ed": 35, "text": "such implementations"}, {"st": 38, "ed": 40, "text": "regular expression"}, {"st": 50, "ed": 52, "text": "virtual machines"}, {"st": 54, "ed": 56, "text": "regular expression"}, {"st": 67, "ed": 69, "text": "deterministic constructs"}, {"st": 72, "ed": 74, "text": "Kleene star"}, {"st": 78, "ed": 80, "text": "implementation technique"}, {"st": 81, "ed": 83, "text": "regular expression"}, {"st": 85, "ed": 87, "text": "operational semantics"}, {"st": 95, "ed": 97, "text": "abstract machines"}, {"st": 101, "ed": 103, "text": "abstract definition"}, {"st": 107, "ed": 109, "text": "realistic machines"}, {"st": 117, "ed": 119, "text": "operational semantics"}, {"st": 128, "ed": 130, "text": "current expression"}, {"st": 139, "ed": 141, "text": "data structure"}, {"st": 146, "ed": 148, "text": "redundant searches"}, {"st": 154, "ed": 156, "text": "pointer equality"}, {"st": 166, "ed": 168, "text": "lockstep construction"}, {"st": 183, "ed": 185, "text": "large number"}, {"st": 196, "ed": 198, "text": "parallel machine"}, {"st": 199, "ed": 201, "text": "process algebra"}, {"st": 204, "ed": 206, "text": "preliminary experiments"}, {"st": 211, "ed": 213, "text": "graphics processor"}]
[{"st": 1, "ed": 5, "text": "Proof Carrying Code Framework"}, {"st": 6, "ed": 9, "text": "Inlined Reference Monitors"}, {"st": 10, "ed": 12, "text": "Java Bytecode"}]
[{"st": 5, "ed": 7, "text": "weight approach"}, {"st": 13, "ed": 16, "text": "sequential Java bytecode"}, {"st": 32, "ed": 34, "text": "quality assurance"}, {"st": 35, "ed": 37, "text": "development time"}, {"st": 45, "ed": 47, "text": "shipping code"}, {"st": 56, "ed": 58, "text": "host TCB"}, {"st": 63, "ed": 65, "text": "security policies"}, {"st": 69, "ed": 74, "text": "API call / return sequences"}, {"st": 81, "ed": 84, "text": "style program annotations"}, {"st": 101, "ed": 103, "text": "time polynomial"}, {"st": 110, "ed": 112, "text": "Policy adherence"}, {"st": 120, "ed": 122, "text": "inlined monitor"}, {"st": 126, "ed": 131, "text": "trusted \" ghost \" monitor"}, {"st": 135, "ed": 137, "text": "style annotations"}, {"st": 145, "ed": 147, "text": "proof annotations"}, {"st": 158, "ed": 162, "text": "own trusted ghost monitor"}, {"st": 166, "ed": 168, "text": "verification conditions"}, {"st": 180, "ed": 182, "text": "correct policy"}, {"st": 192, "ed": 195, "text": "Java bytecode level"}, {"st": 209, "ed": 211, "text": "application loader"}, {"st": 214, "ed": 216, "text": "mobile device"}, {"st": 228, "ed": 230, "text": "sample applications"}]
[{"st": 2, "ed": 6, "text": "A Stochastic Process Algebra"}]
[{"st": 1, "ed": 3, "text": "syntactic nature"}, {"st": 4, "ed": 6, "text": "compositionality characteristic"}, {"st": 7, "ed": 10, "text": "stochastic process algebras"}, {"st": 17, "ed": 19, "text": "human beings"}, {"st": 33, "ed": 35, "text": "mathematical analysis"}, {"st": 36, "ed": 38, "text": "stochastic simulation"}, {"st": 43, "ed": 46, "text": "numerical representation schema"}, {"st": 48, "ed": 52, "text": "stochastic process algebra PEPA"}, {"st": 66, "ed": 68, "text": "computational approaches"}, {"st": 104, "ed": 107, "text": "general PEPA model"}, {"st": 118, "ed": 120, "text": "performance measures"}]
[{"st": 4, "ed": 8, "text": "Infinite Algebraic Data Structures"}]
[{"st": 0, "ed": 2, "text": "Computational content"}, {"st": 4, "ed": 8, "text": "constructive type theory proofs"}, {"st": 16, "ed": 19, "text": "concrete data structures"}, {"st": 33, "ed": 35, "text": "chain complexes"}, {"st": 36, "ed": 38, "text": "infinite type"}, {"st": 46, "ed": 48, "text": "infinite sets"}, {"st": 59, "ed": 62, "text": "homological algebra structures"}]
[{"st": 0, "ed": 2, "text": "Interface Building"}, {"st": 5, "ed": 7, "text": "Modular Three"}, {"st": 9, "ed": 11, "text": "Abstraction Refinement"}]
[{"st": 2, "ed": 4, "text": "software systems"}, {"st": 7, "ed": 9, "text": "hard problem"}, {"st": 12, "ed": 14, "text": "large size"}, {"st": 15, "ed": 17, "text": "program state"}, {"st": 21, "ed": 23, "text": "traditional techniques"}, {"st": 36, "ed": 38, "text": "whole state"}, {"st": 43, "ed": 46, "text": "library function codes"}, {"st": 47, "ed": 49, "text": "Current research"}, {"st": 55, "ed": 57, "text": "lightweight representation"}, {"st": 64, "ed": 68, "text": "\" interface graph \""}, {"st": 70, "ed": 72, "text": "sequence graph"}, {"st": 80, "ed": 82, "text": "new algorithm"}, {"st": 87, "ed": 90, "text": "permissive interface graph"}, {"st": 93, "ed": 95, "text": "type functions"}, {"st": 98, "ed": 100, "text": "modular analysis"}, {"st": 102, "ed": 104, "text": "function transition"}, {"st": 110, "ed": 112, "text": "abstraction semantics"}, {"st": 123, "ed": 125, "text": "global abstraction"}, {"st": 128, "ed": 130, "text": "global variables"}, {"st": 134, "ed": 136, "text": "local abstraction"}, {"st": 143, "ed": 145, "text": "local variables"}, {"st": 147, "ed": 151, "text": "abstract summary needs refinement"}, {"st": 163, "ed": 165, "text": "TICC tool"}, {"st": 171, "ed": 175, "text": "related interface generation algorithms"}, {"st": 185, "ed": 187, "text": "offline test"}, {"st": 196, "ed": 198, "text": "model program"}, {"st": 213, "ed": 215, "text": "new implementation"}]
[{"st": 0, "ed": 2, "text": "Smart matching"}]
[{"st": 4, "ed": 6, "text": "annoying aspects"}, {"st": 34, "ed": 37, "text": "conspicuous background knowledge"}, {"st": 40, "ed": 42, "text": "scientific domain"}, {"st": 59, "ed": 61, "text": "mathematical discourse"}, {"st": 71, "ed": 73, "text": "similar behavior"}, {"st": 74, "ed": 76, "text": "interactive provers"}, {"st": 90, "ed": 94, "text": "Matita interactive theorem prover"}, {"st": 101, "ed": 105, "text": "called smart application tactic"}, {"st": 107, "ed": 109, "text": "smart matching"}]
[{"st": 1, "ed": 4, "text": "Heap Lambda Machine"}]
[{"st": 4, "ed": 7, "text": "new machine architecture"}, {"st": 9, "ed": 11, "text": "lambda expressions"}, {"st": 15, "ed": 17, "text": "order reduction"}, {"st": 22, "ed": 24, "text": "lambda expression"}, {"st": 32, "ed": 34, "text": "normal form"}, {"st": 38, "ed": 40, "text": "enough memory"}, {"st": 47, "ed": 49, "text": "heap memory"}, {"st": 51, "ed": 53, "text": "Lambda expressions"}, {"st": 64, "ed": 66, "text": "processing unit"}]
[{"st": 1, "ed": 4, "text": "Dimensional Modal Logic"}]
[{"st": 1, "ed": 3, "text": "dimensional automata"}, {"st": 17, "ed": 21, "text": "traditional partial order models"}, {"st": 22, "ed": 24, "text": "Mazurkiewicz traces"}, {"st": 27, "ed": 29, "text": "event structures"}, {"st": 31, "ed": 33, "text": "Petri nets"}, {"st": 34, "ed": 36, "text": "Modal logics"}, {"st": 39, "ed": 41, "text": "Kripke structures"}, {"st": 48, "ed": 50, "text": "sequential behavior"}, {"st": 51, "ed": 53, "text": "interleaved concurrency"}, {"st": 54, "ed": 56, "text": "Modal logic"}, {"st": 59, "ed": 61, "text": "behaved subset"}, {"st": 64, "ed": 66, "text": "order logic"}, {"st": 67, "ed": 69, "text": "many variants"}, {"st": 70, "ed": 72, "text": "modal logic"}, {"st": 87, "ed": 90, "text": "expressive HDA models"}, {"st": 99, "ed": 101, "text": "modal logic"}, {"st": 124, "ed": 127, "text": "dimensional modal logic"}, {"st": 136, "ed": 138, "text": "axiomatic system"}, {"st": 148, "ed": 150, "text": "HDA model"}, {"st": 153, "ed": 155, "text": "Kripke structures"}, {"st": 157, "ed": 159, "text": "syntactic restriction"}, {"st": 163, "ed": 166, "text": "standard modal logic"}, {"st": 176, "ed": 178, "text": "Mazurkiewicz traces"}, {"st": 184, "ed": 186, "text": "natural definitions"}, {"st": 198, "ed": 202, "text": "linear time temporal logic"}, {"st": 203, "ed": 205, "text": "Mazurkiewicz traces"}, {"st": 208, "ed": 211, "text": "branching time ISTL"}, {"st": 219, "ed": 223, "text": "basic HDML language wrt"}]
[{"st": 2, "ed": 4, "text": "Complex Vectors"}, {"st": 7, "ed": 9, "text": "Order Logic"}]
[{"st": 0, "ed": 3, "text": "Complex vector analysis"}, {"st": 8, "ed": 10, "text": "continuous systems"}, {"st": 11, "ed": 13, "text": "many disciplines"}, {"st": 30, "ed": 32, "text": "logic formalization"}, {"st": 34, "ed": 37, "text": "complex vector space"}, {"st": 44, "ed": 46, "text": "sound core"}, {"st": 48, "ed": 50, "text": "theorem prover"}, {"st": 51, "ed": 53, "text": "HOL Light"}, {"st": 57, "ed": 59, "text": "complex vector"}, {"st": 64, "ed": 66, "text": "complex numbers"}, {"st": 67, "ed": 69, "text": "real vectors"}, {"st": 84, "ed": 86, "text": "complex analysis"}, {"st": 87, "ed": 90, "text": "real vector analysis"}, {"st": 94, "ed": 96, "text": "practical usefulness"}, {"st": 104, "ed": 106, "text": "electromagnetic fields"}, {"st": 115, "ed": 117, "text": "planar waves"}]
[{"st": 0, "ed": 2, "text": "Intuitionistic PUC"}, {"st": 5, "ed": 7, "text": "Constructive Counterfactuals"}]
[{"st": 3, "ed": 5, "text": "intuitionistic version"}, {"st": 16, "ed": 18, "text": "constructive approach"}, {"st": 21, "ed": 23, "text": "counterfactual abstraction"}, {"st": 31, "ed": 34, "text": "classical absurd rule"}]
[{"st": 4, "ed": 6, "text": "Regular Languages"}]
[]
[{"st": 2, "ed": 5, "text": "Effective Decision Procedure"}, {"st": 6, "ed": 8, "text": "LTL formulas"}]
[{"st": 4, "ed": 6, "text": "ongoing work"}, {"st": 17, "ed": 19, "text": "final scope"}, {"st": 26, "ed": 29, "text": "LTL formulas w.r.t"}, {"st": 35, "ed": 40, "text": "timed concurrent constraint language tccp"}, {"st": 44, "ed": 48, "text": "logic concurrent constraint language"}, {"st": 51, "ed": 54, "text": "concurrent constraint paradigm"}, {"st": 58, "ed": 60, "text": "inherent notions"}, {"st": 70, "ed": 72, "text": "partial information"}, {"st": 76, "ed": 78, "text": "monotonic evolution"}, {"st": 87, "ed": 89, "text": "LTL property"}, {"st": 99, "ed": 102, "text": "abstract diagnosis technique"}, {"st": 116, "ed": 118, "text": "LTL formula"}, {"st": 124, "ed": 126, "text": "effective way"}, {"st": 134, "ed": 136, "text": "decision method"}, {"st": 140, "ed": 143, "text": "temporal logic formulas"}, {"st": 150, "ed": 153, "text": "abstract diagnosis technique"}]
[{"st": 0, "ed": 2, "text": "Efficient Approximation"}, {"st": 15, "ed": 17, "text": "Extended Version"}]
[{"st": 0, "ed": 4, "text": "Many native ASP solvers"}, {"st": 5, "ed": 7, "text": "unfounded sets"}, {"st": 12, "ed": 14, "text": "logic program"}, {"st": 38, "ed": 40, "text": "computational cost"}, {"st": 51, "ed": 54, "text": "many relevant conditions"}, {"st": 64, "ed": 67, "text": "low computational cost"}, {"st": 89, "ed": 92, "text": "time algorithms exist"}, {"st": 99, "ed": 103, "text": "additional unfounded set inference"}, {"st": 127, "ed": 129, "text": "important classes"}, {"st": 130, "ed": 132, "text": "logic programs"}, {"st": 142, "ed": 144, "text": "extended version"}, {"st": 151, "ed": 153, "text": "International Conference"}, {"st": 154, "ed": 156, "text": "Logic Programming"}, {"st": 157, "ed": 159, "text": "Nonmonotonic Reasoning"}]
[{"st": 4, "ed": 6, "text": "Wireless Networks"}, {"st": 11, "ed": 13, "text": "Calculus Approach"}]
[{"st": 6, "ed": 8, "text": "process calculus"}, {"st": 13, "ed": 15, "text": "wireless networks"}, {"st": 16, "ed": 18, "text": "local broadcast"}, {"st": 22, "ed": 24, "text": "behavioural theory"}, {"st": 25, "ed": 27, "text": "wireless networks"}, {"st": 32, "ed": 34, "text": "reduction semantics"}, {"st": 36, "ed": 39, "text": "labelled transition semantics"}, {"st": 47, "ed": 49, "text": "weak bisimilarity"}, {"st": 68, "ed": 71, "text": "weak bisimilarity implies"}, {"st": 81, "ed": 83, "text": "potential applications"}]
[{"st": 4, "ed": 6, "text": "Parity Objectives"}]
[{"st": 8, "ed": 10, "text": "quantitative objectives"}, {"st": 11, "ed": 13, "text": "reward MDPs"}, {"st": 27, "ed": 29, "text": "parity objective"}, {"st": 33, "ed": 35, "text": "common belief"}, {"st": 55, "ed": 58, "text": "finite memory strategy"}, {"st": 63, "ed": 65, "text": "simple counterexample"}, {"st": 68, "ed": 70, "text": "coB\\\"uchi conditions"}, {"st": 74, "ed": 76, "text": "new class"}, {"st": 81, "ed": 83, "text": "storage objectives"}, {"st": 88, "ed": 90, "text": "parity objectives"}, {"st": 93, "ed": 96, "text": "finite memory property"}, {"st": 110, "ed": 112, "text": "sure energy"}, {"st": 113, "ed": 115, "text": "parity objectives"}, {"st": 125, "ed": 129, "text": "sure storage parity objectives"}, {"st": 133, "ed": 135, "text": "\\mathit{NP}\\cap \\mathit{coNP}$"}, {"st": 142, "ed": 144, "text": "polynomial time"}, {"st": 147, "ed": 149, "text": "parity MDPs"}]
[{"st": 0, "ed": 2, "text": "Automatic verification"}, {"st": 3, "ed": 5, "text": "interactive theorem"}]
[{"st": 0, "ed": 3, "text": "Automatic verification deals"}, {"st": 11, "ed": 13, "text": "correctness certificates"}, {"st": 15, "ed": 17, "text": "related tools"}, {"st": 20, "ed": 22, "text": "proof assistants"}, {"st": 23, "ed": 25, "text": "interactive provers"}, {"st": 28, "ed": 30, "text": "interactive environment"}, {"st": 34, "ed": 36, "text": "formal certificates"}, {"st": 44, "ed": 46, "text": "automatic way"}, {"st": 47, "ed": 49, "text": "Such systems"}, {"st": 64, "ed": 66, "text": "computer science"}]
[{"st": 2, "ed": 4, "text": "Decidable LogicWeb"}]
[{"st": 8, "ed": 10, "text": "intractable queries"}, {"st": 25, "ed": 27, "text": "approximate reasoning"}, {"st": 30, "ed": 32, "text": "\\it length"}, {"st": 60, "ed": 62, "text": "web page"}, {"st": 69, "ed": 72, "text": "n$ proof steps"}]
[{"st": 5, "ed": 7, "text": "Physical Systems"}]
[{"st": 3, "ed": 6, "text": "hybrid process calculus"}, {"st": 13, "ed": 15, "text": "physical systems"}, {"st": 32, "ed": 34, "text": "transition system"}, {"st": 36, "ed": 38, "text": "SOS style"}, {"st": 50, "ed": 52, "text": "behavioural semantics"}, {"st": 54, "ed": 56, "text": "compositional reasonings"}, {"st": 63, "ed": 65, "text": "time properties"}, {"st": 66, "ed": 68, "text": "system equalities"}, {"st": 72, "ed": 75, "text": "trivial case study"}]
[{"st": 1, "ed": 3, "text": "new rule"}, {"st": 6, "ed": 8, "text": "certain termination"}, {"st": 11, "ed": 13, "text": "demonic programs"}]
[{"st": 13, "ed": 15, "text": "probabilistic programs"}, {"st": 21, "ed": 23, "text": "new rule"}, {"st": 35, "ed": 38, "text": "certain termination \""}, {"st": 48, "ed": 50, "text": "super martingales"}, {"st": 62, "ed": 64, "text": "significant cases"}, {"st": 79, "ed": 83, "text": "unbounded symmetric random walk"}, {"st": 120, "ed": 123, "text": "i.e. demonic choice"}]
[{"st": 5, "ed": 7, "text": "Quantified Bit"}, {"st": 8, "ed": 10, "text": "Vector Arithmetic"}, {"st": 11, "ed": 14, "text": "Binary Encoded Bit"}]
[{"st": 7, "ed": 10, "text": "precise computational complexity"}, {"st": 25, "ed": 27, "text": "size bit"}, {"st": 38, "ed": 40, "text": "exponential space"}, {"st": 56, "ed": 59, "text": "complexity class AEXP(poly"}, {"st": 69, "ed": 71, "text": "Turing machine"}, {"st": 72, "ed": 74, "text": "exponential space"}, {"st": 75, "ed": 77, "text": "polynomial number"}, {"st": 82, "ed": 84, "text": "universal states"}]
[{"st": 0, "ed": 2, "text": "Mixed powerdomains"}]
[{"st": 2, "ed": 4, "text": "mixed powerdomains"}, {"st": 5, "ed": 7, "text": "ordinary nondeterminism"}, {"st": 8, "ed": 10, "text": "probabilistic nondeterminism"}, {"st": 15, "ed": 17, "text": "free algebras"}, {"st": 22, "ed": 24, "text": "al theories"}, {"st": 27, "ed": 30, "text": "functional representation theorems"}, {"st": 36, "ed": 38, "text": "state transformers"}, {"st": 40, "ed": 43, "text": "healthy predicate transformers"}, {"st": 45, "ed": 48, "text": "extended nonnegative reals"}, {"st": 79, "ed": 82, "text": "suitable convex sets"}, {"st": 83, "ed": 85, "text": "subprobability valuations"}, {"st": 89, "ed": 91, "text": "nondeterministic choice"}, {"st": 92, "ed": 94, "text": "probabilistic choice"}, {"st": 100, "ed": 104, "text": "probabilistic choice operator distributing"}, {"st": 106, "ed": 109, "text": "nondeterministic choice operator"}, {"st": 112, "ed": 114, "text": "alternative approach"}, {"st": 125, "ed": 127, "text": "probabilistic choice"}, {"st": 134, "ed": 136, "text": "theoretic version"}, {"st": 137, "ed": 139, "text": "random sets"}, {"st": 148, "ed": 150, "text": "algebraic approach"}, {"st": 171, "ed": 173, "text": "analytic approach"}, {"st": 177, "ed": 181, "text": "theoretic abstract convex sets"}, {"st": 189, "ed": 192, "text": "abstract probabilistic algebras"}, {"st": 208, "ed": 210, "text": "power Kegelspitzen"}, {"st": 213, "ed": 215, "text": "free algebras"}, {"st": 216, "ed": 218, "text": "functional representations"}, {"st": 220, "ed": 222, "text": "predicate transformers"}, {"st": 230, "ed": 232, "text": "previous work"}, {"st": 235, "ed": 237, "text": "theoretic cones"}, {"st": 255, "ed": 257, "text": "free d"}, {"st": 258, "ed": 260, "text": "cone construction"}]
[{"st": 2, "ed": 6, "text": "Ordered Binary Decision Diagrams"}, {"st": 9, "ed": 12, "text": "Conjunctive Normal Form"}]
[{"st": 1, "ed": 3, "text": "classical question"}, {"st": 4, "ed": 6, "text": "propositional logic"}, {"st": 17, "ed": 20, "text": "related fundamental problem"}, {"st": 24, "ed": 26, "text": "relative efficiency"}, {"st": 27, "ed": 30, "text": "standard proof systems"}, {"st": 33, "ed": 35, "text": "relative complexity"}, {"st": 41, "ed": 43, "text": "polynomial simulation"}, {"st": 53, "ed": 56, "text": "art satisfiability algorithms"}, {"st": 66, "ed": 70, "text": "Ordered Binary Decision Diagram"}, {"st": 75, "ed": 77, "text": "data structure"}, {"st": 82, "ed": 84, "text": "Boolean functions"}, {"st": 93, "ed": 95, "text": "exponential separation"}, {"st": 99, "ed": 101, "text": "proof system"}, {"st": 103, "ed": 106, "text": "limited OBDD derivations"}, {"st": 109, "ed": 111, "text": "formal comparison"}, {"st": 118, "ed": 120, "text": "OBDDs work"}, {"st": 121, "ed": 123, "text": "arbitrary formulas"}, {"st": 133, "ed": 136, "text": "Conjunctive Normal Form"}, {"st": 142, "ed": 144, "text": "popular belief"}, {"st": 148, "ed": 151, "text": "resolution simulates OBDDs"}, {"st": 163, "ed": 165, "text": "open question"}, {"st": 172, "ed": 174, "text": "unsatisfiable CNFs"}, {"st": 175, "ed": 178, "text": "polynomial OBDD refutations"}, {"st": 181, "ed": 184, "text": "long resolution refutations"}]
[{"st": 3, "ed": 5, "text": "OR Hierarchies"}, {"st": 6, "ed": 8, "text": "Workflow Nets"}]
[{"st": 8, "ed": 10, "text": "OR reduction"}, {"st": 14, "ed": 16, "text": "WF net"}, {"st": 29, "ed": 31, "text": "single nodes"}, {"st": 34, "ed": 36, "text": "such contractions"}, {"st": 44, "ed": 46, "text": "hierarchical structure"}, {"st": 48, "ed": 50, "text": "WF net"}, {"st": 55, "ed": 58, "text": "certain semantical properties"}, {"st": 71, "ed": 73, "text": "WF net"}, {"st": 88, "ed": 90, "text": "WF net"}, {"st": 100, "ed": 102, "text": "WF nets"}, {"st": 110, "ed": 112, "text": "describes nets"}, {"st": 114, "ed": 118, "text": "good hierarchical design principles"}, {"st": 126, "ed": 128, "text": "OR reduction"}, {"st": 139, "ed": 141, "text": "inherent non"}, {"st": 155, "ed": 157, "text": "final result"}, {"st": 183, "ed": 185, "text": "time algorithm"}, {"st": 190, "ed": 192, "text": "unique result"}, {"st": 196, "ed": 198, "text": "OR reduction"}, {"st": 214, "ed": 216, "text": "WF net"}]
[{"st": 0, "ed": 2, "text": "Type homogeneity"}, {"st": 7, "ed": 10, "text": "safe recursion schemes"}]
[{"st": 6, "ed": 8, "text": "safety restriction"}, {"st": 17, "ed": 19, "text": "production rules"}, {"st": 23, "ed": 26, "text": "order recursion scheme"}, {"st": 35, "ed": 37, "text": "expressivity result"}, {"st": 41, "ed": 43, "text": "pushdown automata"}, {"st": 46, "ed": 50, "text": "n safe recursion schemes"}, {"st": 52, "ed": 54, "text": "such devices"}, {"st": 57, "ed": 59, "text": "tree generators"}, {"st": 80, "ed": 82, "text": "syntactic restriction"}, {"st": 90, "ed": 92, "text": "expressivity result"}]
[{"st": 0, "ed": 3, "text": "Constraint Satisfaction Problems"}, {"st": 4, "ed": 8, "text": "semilattice block Mal'tsev algebras"}]
[{"st": 12, "ed": 14, "text": "local propagation"}, {"st": 20, "ed": 22, "text": "solution space"}, {"st": 24, "ed": 26, "text": "several years"}, {"st": 30, "ed": 32, "text": "CSP research"}, {"st": 52, "ed": 54, "text": "new method"}, {"st": 55, "ed": 57, "text": "such hybridization"}, {"st": 62, "ed": 64, "text": "certain CSPs"}, {"st": 83, "ed": 85, "text": "restricted class"}, {"st": 93, "ed": 96, "text": "semilattice block Mal'tsev"}, {"st": 98, "ed": 100, "text": "algebra A"}, {"st": 102, "ed": 105, "text": "semilattice block Mal'tsev"}, {"st": 109, "ed": 112, "text": "binary operation f"}, {"st": 114, "ed": 117, "text": "ternary operation m"}, {"st": 120, "ed": 122, "text": "congruence s"}, {"st": 125, "ed": 129, "text": "quotient A / s"}, {"st": 155, "ed": 157, "text": "Mal'tsev algebra"}, {"st": 158, "ed": 161, "text": "Mal'tsev operation m."}, {"st": 165, "ed": 168, "text": "constraint satisfaction problem"}, {"st": 170, "ed": 174, "text": "semilattice block Mal'tsev algebra"}, {"st": 177, "ed": 179, "text": "polynomial time"}]
[{"st": 6, "ed": 9, "text": "Logic Path Checking"}]
[{"st": 5, "ed": 7, "text": "temporal logic"}, {"st": 14, "ed": 16, "text": "fundamental problem"}, {"st": 26, "ed": 28, "text": "finite word"}, {"st": 52, "ed": 54, "text": "NC algorithm"}, {"st": 70, "ed": 72, "text": "NCC algorithm"}, {"st": 76, "ed": 78, "text": "unary fragment"}, {"st": 91, "ed": 93, "text": "expressive logic"}, {"st": 95, "ed": 97, "text": "NC path"}, {"st": 98, "ed": 100, "text": "checking algorithm"}, {"st": 106, "ed": 108, "text": "expressive fragment"}, {"st": 113, "ed": 115, "text": "efficient path"}, {"st": 120, "ed": 122, "text": "full LTL"}, {"st": 125, "ed": 127, "text": "standard complexity"}, {"st": 128, "ed": 130, "text": "theoretic assumptions"}, {"st": 138, "ed": 141, "text": "LTL path checking"}, {"st": 142, "ed": 144, "text": "planar circuits"}, {"st": 152, "ed": 154, "text": "further progress"}, {"st": 157, "ed": 159, "text": "precise complexity"}, {"st": 160, "ed": 162, "text": "LTL path"}, {"st": 167, "ed": 170, "text": "efficient evaluation algorithms"}, {"st": 175, "ed": 177, "text": "certain class"}, {"st": 178, "ed": 180, "text": "planar circuits"}, {"st": 182, "ed": 185, "text": "connection further implies"}, {"st": 189, "ed": 191, "text": "LTL path"}, {"st": 195, "ed": 197, "text": "Boolean connectives"}, {"st": 205, "ed": 207, "text": "temporal logic"}, {"st": 210, "ed": 212, "text": "complete path"}, {"st": 213, "ed": 215, "text": "checking problem"}]
[]
[{"st": 5, "ed": 7, "text": "order theory"}, {"st": 10, "ed": 12, "text": "integer elements"}, {"st": 17, "ed": 19, "text": "regular constraints"}, {"st": 23, "ed": 25, "text": "significant properties"}, {"st": 26, "ed": 28, "text": "data structures"}, {"st": 37, "ed": 39, "text": "decision procedure"}, {"st": 43, "ed": 45, "text": "free fragment"}, {"st": 54, "ed": 56, "text": "order theory"}, {"st": 62, "ed": 64, "text": "PSPACE complexity"}, {"st": 68, "ed": 70, "text": "free fragment"}, {"st": 87, "ed": 89, "text": "Boolean combinations"}, {"st": 92, "ed": 94, "text": "arithmetic facts"}, {"st": 116, "ed": 118, "text": "position i"}, {"st": 119, "ed": 121, "text": "value i+3"}, {"st": 128, "ed": 130, "text": "expressive power"}, {"st": 137, "ed": 140, "text": "expressive decidable logics"}, {"st": 157, "ed": 159, "text": "manipulating programs"}, {"st": 161, "ed": 163, "text": "standard framework"}, {"st": 164, "ed": 166, "text": "axiomatic semantics"}]
[{"st": 2, "ed": 4, "text": "CTL *"}]
[{"st": 5, "ed": 7, "text": "CTL *"}, {"st": 28, "ed": 30, "text": "certain fragments"}, {"st": 31, "ed": 33, "text": "CTL *"}, {"st": 39, "ed": 41, "text": "positive fragments"}]
[{"st": 2, "ed": 4, "text": "Milner Logic"}, {"st": 5, "ed": 8, "text": "Greatest Fixed Points"}, {"st": 10, "ed": 14, "text": "Complete Behavioural Specification Theory"}]
[{"st": 4, "ed": 6, "text": "different approaches"}, {"st": 15, "ed": 17, "text": "logical approach"}, {"st": 27, "ed": 29, "text": "modal logics"}, {"st": 32, "ed": 34, "text": "efficient model"}, {"st": 38, "ed": 40, "text": "behavioural approach"}, {"st": 41, "ed": 43, "text": "various equivalence"}, {"st": 55, "ed": 57, "text": "same formalism"}, {"st": 68, "ed": 70, "text": "logical formalism"}, {"st": 81, "ed": 83, "text": "behavioural formalism"}, {"st": 84, "ed": 88, "text": "disjunctive modal transition systems"}, {"st": 93, "ed": 95, "text": "new operation"}, {"st": 99, "ed": 102, "text": "above equivalent formalisms"}, {"st": 107, "ed": 109, "text": "structural composition"}, {"st": 116, "ed": 118, "text": "partial implementations"}, {"st": 122, "ed": 124, "text": "substantial generalisation"}, {"st": 128, "ed": 132, "text": "deterministic modal transition systems"}]
[{"st": 0, "ed": 2, "text": "Certified HLints"}, {"st": 3, "ed": 6, "text": "Isabelle / HOLCF"}]
[{"st": 11, "ed": 13, "text": "large part"}, {"st": 16, "ed": 18, "text": "standard prelude"}, {"st": 19, "ed": 22, "text": "Isabelle / HOLCF"}]
[{"st": 1, "ed": 3, "text": "E Prover"}, {"st": 4, "ed": 9, "text": "Similarity Based Clause Selection Strategies"}]
[{"st": 0, "ed": 2, "text": "E prover"}, {"st": 10, "ed": 13, "text": "art theorem prover"}, {"st": 16, "ed": 18, "text": "order logic"}, {"st": 21, "ed": 23, "text": "E prover"}, {"st": 27, "ed": 29, "text": "saturation loop"}, {"st": 31, "ed": 33, "text": "new clauses"}, {"st": 36, "ed": 38, "text": "inference rules"}, {"st": 51, "ed": 53, "text": "main source"}, {"st": 59, "ed": 61, "text": "important choice"}, {"st": 68, "ed": 70, "text": "right choice"}, {"st": 74, "ed": 76, "text": "proof search"}, {"st": 82, "ed": 84, "text": "E Prover"}, {"st": 85, "ed": 90, "text": "several new clause selection strategies"}, {"st": 115, "ed": 118, "text": "implement different strategies"}, {"st": 126, "ed": 128, "text": "different ways"}, {"st": 136, "ed": 138, "text": "selection strategies"}, {"st": 145, "ed": 148, "text": "extensive benchmark set"}]
[{"st": 0, "ed": 2, "text": "Fair Simulation"}, {"st": 5, "ed": 8, "text": "Probabilistic Buechi Automata"}, {"st": 10, "ed": 12, "text": "Coalgebraic Perspective"}]
[{"st": 6, "ed": 8, "text": "other uses"}, {"st": 21, "ed": 23, "text": "proof method"}, {"st": 24, "ed": 26, "text": "language inclusion"}, {"st": 39, "ed": 41, "text": "timed systems"}, {"st": 49, "ed": 51, "text": "\\emph{fair simulation"}, {"st": 67, "ed": 69, "text": "fair simulation"}, {"st": 71, "ed": 73, "text": "different directions"}, {"st": 91, "ed": 93, "text": "word automata"}, {"st": 94, "ed": 97, "text": "finite state spaces"}, {"st": 101, "ed": 104, "text": "B\\\"{u}chi acceptance condition"}, {"st": 106, "ed": 109, "text": "former nondeterministic definition"}, {"st": 118, "ed": 120, "text": "point equations"}, {"st": 137, "ed": 140, "text": "latter probabilistic definition"}, {"st": 142, "ed": 144, "text": "strong ranking"}, {"st": 145, "ed": 147, "text": "function flavor"}, {"st": 166, "ed": 168, "text": "B\\\"{u}chi automata"}, {"st": 172, "ed": 174, "text": "coalgebraic observations"}, {"st": 185, "ed": 187, "text": "language inclusion"}]
[{"st": 0, "ed": 2, "text": "Simple strategies"}, {"st": 5, "ed": 7, "text": "Mazur games"}, {"st": 9, "ed": 11, "text": "correct systems"}]
[{"st": 9, "ed": 11, "text": "finite graphs"}, {"st": 14, "ed": 17, "text": "regular large sets"}, {"st": 21, "ed": 23, "text": "regular sets"}, {"st": 32, "ed": 34, "text": "positional strategies"}, {"st": 36, "ed": 38, "text": "related Banach"}, {"st": 39, "ed": 41, "text": "Mazur games"}, {"st": 58, "ed": 60, "text": "various notions"}, {"st": 61, "ed": 63, "text": "simple strategies"}, {"st": 69, "ed": 71, "text": "recent paper"}, {"st": 85, "ed": 87, "text": "classical Banach"}, {"st": 88, "ed": 90, "text": "Mazur game"}, {"st": 95, "ed": 97, "text": "probabilistic version"}, {"st": 108, "ed": 110, "text": "classical Banach"}, {"st": 111, "ed": 113, "text": "Mazur games"}, {"st": 114, "ed": 116, "text": "large sets"}, {"st": 121, "ed": 123, "text": "determinacy result"}, {"st": 129, "ed": 131, "text": "winning set"}, {"st": 133, "ed": 135, "text": "countable intersection"}, {"st": 136, "ed": 138, "text": "open sets"}]
[{"st": 7, "ed": 9, "text": "Description Logics"}]
[{"st": 6, "ed": 8, "text": "description logics"}, {"st": 12, "ed": 15, "text": "logical consequences \""}, {"st": 21, "ed": 23, "text": "positive concepts"}, {"st": 27, "ed": 30, "text": "positive concept assertions"}, {"st": 32, "ed": 34, "text": "Such comparisons"}, {"st": 57, "ed": 60, "text": "propositional dynamic logic"}, {"st": 68, "ed": 70, "text": "inverse roles"}, {"st": 74, "ed": 76, "text": "number restrictions"}, {"st": 78, "ed": 80, "text": "universal role"}, {"st": 83, "ed": 85, "text": "concept constructor"}, {"st": 88, "ed": 90, "text": "local reflexivity"}, {"st": 95, "ed": 97, "text": "studied problems"}, {"st": 103, "ed": 105, "text": "positive concepts"}, {"st": 113, "ed": 115, "text": "Milner property"}, {"st": 126, "ed": 128, "text": "positive concepts"}]
[{"st": 5, "ed": 9, "text": "Parametric Modal Transition Systems"}]
[{"st": 5, "ed": 8, "text": "modal transition systems"}, {"st": 13, "ed": 15, "text": "Boolean MTS"}, {"st": 16, "ed": 18, "text": "parametric MTS"}, {"st": 22, "ed": 24, "text": "refinement problems"}, {"st": 35, "ed": 37, "text": "modal refinement"}, {"st": 42, "ed": 44, "text": "problem solvable"}, {"st": 46, "ed": 48, "text": "QBF solver"}, {"st": 50, "ed": 52, "text": "experimental results"}, {"st": 65, "ed": 67, "text": "thorough refinement"}, {"st": 89, "ed": 91, "text": "thorough refinement"}, {"st": 99, "ed": 101, "text": "thorough refinement"}, {"st": 106, "ed": 108, "text": "modal refinement"}]
[{"st": 4, "ed": 7, "text": "Verifying Regular Properties"}, {"st": 8, "ed": 11, "text": "Flat Counter Systems"}]
[{"st": 2, "ed": 4, "text": "approximation methods"}, {"st": 8, "ed": 10, "text": "counter systems"}, {"st": 20, "ed": 22, "text": "flat unfoldings"}, {"st": 26, "ed": 28, "text": "complexity characterization"}, {"st": 31, "ed": 33, "text": "checking problems"}, {"st": 34, "ed": 37, "text": "such operational models"}, {"st": 44, "ed": 46, "text": "reachability queries"}, {"st": 48, "ed": 50, "text": "Past LTL"}, {"st": 62, "ed": 64, "text": "checking problems"}, {"st": 65, "ed": 68, "text": "flat counter systems"}, {"st": 75, "ed": 77, "text": "order logic"}, {"st": 83, "ed": 85, "text": "infinite automata"}, {"st": 87, "ed": 89, "text": "related formalisms"}, {"st": 93, "ed": 96, "text": "different complexity classes"}, {"st": 110, "ed": 112, "text": "arithmetical constraints"}, {"st": 113, "ed": 115, "text": "counter values"}, {"st": 123, "ed": 125, "text": "proof techniques"}, {"st": 131, "ed": 133, "text": "uniform approach"}, {"st": 137, "ed": 139, "text": "main issues"}]
[{"st": 1, "ed": 3, "text": "Static Analysis"}, {"st": 4, "ed": 8, "text": "Parameterised Boolean Equation Systems"}, {"st": 9, "ed": 12, "text": "Control Flow Reconstruction"}]
[{"st": 3, "ed": 7, "text": "sound static analysis technique"}, {"st": 10, "ed": 12, "text": "combinatorial explosion"}, {"st": 13, "ed": 17, "text": "parameterised Boolean equation systems"}, {"st": 29, "ed": 31, "text": "point equations"}, {"st": 35, "ed": 38, "text": "order logic formulae"}, {"st": 50, "ed": 53, "text": "control flow graph"}, {"st": 61, "ed": 63, "text": "such parameters"}, {"st": 68, "ed": 70, "text": "naive approach"}, {"st": 73, "ed": 76, "text": "control flow graph"}, {"st": 86, "ed": 88, "text": "exponential blow"}, {"st": 95, "ed": 97, "text": "approximate analysis"}, {"st": 113, "ed": 115, "text": "case studies"}]
[{"st": 2, "ed": 4, "text": "Linear Time"}, {"st": 5, "ed": 8, "text": "Branching Time Spectrum"}, {"st": 9, "ed": 11, "text": "Process Semantics"}]
[{"st": 0, "ed": 2, "text": "Van Glabbeek"}, {"st": 3, "ed": 5, "text": "linear time"}, {"st": 6, "ed": 9, "text": "branching time spectrum"}, {"st": 14, "ed": 16, "text": "relevant work"}, {"st": 17, "ed": 19, "text": "comparative study"}, {"st": 20, "ed": 22, "text": "process semantics"}, {"st": 31, "ed": 33, "text": "discrimination power"}, {"st": 49, "ed": 51, "text": "process semantics"}, {"st": 57, "ed": 59, "text": "uniform way"}, {"st": 64, "ed": 66, "text": "natural concept"}, {"st": 67, "ed": 69, "text": "constrained simulation"}, {"st": 86, "ed": 88, "text": "same layer"}, {"st": 95, "ed": 97, "text": "generic way"}, {"st": 103, "ed": 105, "text": "operational characterizations"}, {"st": 137, "ed": 139, "text": "uniform treatment"}, {"st": 140, "ed": 142, "text": "semantic preorders"}]
[{"st": 0, "ed": 2, "text": "Sequent Calculi"}, {"st": 3, "ed": 5, "text": "procedure calls"}]
[{"st": 7, "ed": 10, "text": "focussed sequent calculi"}, {"st": 25, "ed": 27, "text": "LKF system"}, {"st": 28, "ed": 31, "text": "polarised classical logic"}, {"st": 37, "ed": 39, "text": "sequent calculi"}, {"st": 45, "ed": 47, "text": "decision procedure"}, {"st": 49, "ed": 52, "text": "background theory T"}, {"st": 62, "ed": 64, "text": "fly \""}, {"st": 75, "ed": 77, "text": "other works"}, {"st": 104, "ed": 106, "text": "prove cut"}, {"st": 118, "ed": 120, "text": "empty theory"}, {"st": 134, "ed": 136, "text": "theory T."}, {"st": 138, "ed": 140, "text": "other hand"}, {"st": 169, "ed": 172, "text": "second sequent calculus"}, {"st": 181, "ed": 184, "text": "relaxed focussing discipline"}, {"st": 198, "ed": 201, "text": "restrictive system LK(T"}, {"st": 226, "ed": 229, "text": "ground propositional lemmas"}, {"st": 231, "ed": 234, "text": "background theory T"}]
[{"st": 1, "ed": 4, "text": "simple sequent calculus"}, {"st": 5, "ed": 7, "text": "nominal logic"}]
[{"st": 0, "ed": 2, "text": "Nominal logic"}, {"st": 8, "ed": 10, "text": "order logic"}, {"st": 19, "ed": 21, "text": "abstract syntax"}, {"st": 23, "ed": 25, "text": "key feature"}, {"st": 26, "ed": 28, "text": "nominal logic"}, {"st": 37, "ed": 39, "text": "fresh names"}, {"st": 51, "ed": 53, "text": "Previous attempts"}, {"st": 58, "ed": 60, "text": "convenient rules"}, {"st": 86, "ed": 89, "text": "new sequent calculus"}, {"st": 90, "ed": 92, "text": "nominal logic"}, {"st": 98, "ed": 100, "text": "new- quantifier"}, {"st": 105, "ed": 107, "text": "previous attempts"}, {"st": 114, "ed": 116, "text": "metatheoretic properties"}, {"st": 131, "ed": 133, "text": "nominal logic"}]
[{"st": 1, "ed": 4, "text": "Double Negation Translations"}]
[{"st": 2, "ed": 4, "text": "negation translations"}, {"st": 10, "ed": 12, "text": "classical proofs"}, {"st": 13, "ed": 15, "text": "intuitionistic logic"}, {"st": 24, "ed": 26, "text": "free fragment"}, {"st": 57, "ed": 59, "text": "different connectives"}, {"st": 66, "ed": 68, "text": "embedding results"}, {"st": 73, "ed": 75, "text": "customized version"}, {"st": 77, "ed": 81, "text": "focused classical sequent calculus"}, {"st": 86, "ed": 88, "text": "latter equivalent"}, {"st": 90, "ed": 92, "text": "usual versions"}, {"st": 94, "ed": 96, "text": "sequent calculus"}, {"st": 98, "ed": 100, "text": "polarization process"}, {"st": 114, "ed": 116, "text": "classical connectives"}]
[]
[{"st": 7, "ed": 10, "text": "dependent type theory"}, {"st": 15, "ed": 17, "text": "impredicative feature"}, {"st": 19, "ed": 21, "text": "type theory"}]
[{"st": 0, "ed": 3, "text": "Forward Invariant Cuts"}, {"st": 4, "ed": 6, "text": "Simplify Proofs"}]
[{"st": 3, "ed": 5, "text": "deductive techniques"}, {"st": 8, "ed": 10, "text": "theorem provers"}, {"st": 12, "ed": 14, "text": "several advantages"}, {"st": 15, "ed": 17, "text": "safety verification"}, {"st": 18, "ed": 21, "text": "hybrid sys- tems"}, {"st": 30, "ed": 33, "text": "art theorem provers"}, {"st": 34, "ed": 38, "text": "ex- tensive manual intervention"}, {"st": 53, "ed": 55, "text": "theorem prover"}, {"st": 61, "ed": 63, "text": "proof task"}, {"st": 65, "ed": 67, "text": "assis- tance"}, {"st": 69, "ed": 71, "text": "system designer"}, {"st": 85, "ed": 88, "text": "deductive verification tool"}, {"st": 89, "ed": 92, "text": "differential dynamic logic"}, {"st": 94, "ed": 96, "text": "new technique"}, {"st": 100, "ed": 103, "text": "system designer intuition"}, {"st": 104, "ed": 106, "text": "per- formance"}, {"st": 107, "ed": 109, "text": "particular modes"}, {"st": 113, "ed": 115, "text": "proof task"}, {"st": 120, "ed": 122, "text": "theorem prover"}, {"st": 124, "ed": 127, "text": "for- ward invariants"}, {"st": 130, "ed": 132, "text": "numerical techniques"}, {"st": 144, "ed": 147, "text": "new inference rule"}, {"st": 149, "ed": 151, "text": "proof calculus"}, {"st": 155, "ed": 159, "text": "forward invariant cut rule"}, {"st": 167, "ed": 170, "text": "useful forward invariants"}, {"st": 177, "ed": 180, "text": "new cut rule"}, {"st": 182, "ed": 184, "text": "verification tasks"}, {"st": 189, "ed": 191, "text": "new approach"}, {"st": 196, "ed": 198, "text": "verification tasks"}, {"st": 206, "ed": 208, "text": "deductive approaches"}, {"st": 210, "ed": 212, "text": "several examples"}, {"st": 217, "ed": 221, "text": "automotive powertrain control system"}]
[{"st": 2, "ed": 4, "text": "Degree Predicates"}, {"st": 7, "ed": 9, "text": "Variable First"}, {"st": 10, "ed": 12, "text": "Order Logic"}]
[{"st": 7, "ed": 9, "text": "order logic"}, {"st": 10, "ed": 12, "text": "finite words"}, {"st": 14, "ed": 16, "text": "fixed number"}, {"st": 17, "ed": 19, "text": "quantifier alternations"}, {"st": 27, "ed": 29, "text": "neutral letter"}, {"st": 36, "ed": 38, "text": "degree predicates"}, {"st": 43, "ed": 45, "text": "order predicate"}, {"st": 56, "ed": 58, "text": "alternation hierarchy"}, {"st": 61, "ed": 63, "text": "variable logic"}]
[{"st": 1, "ed": 4, "text": "Improved Decision Procedure"}, {"st": 5, "ed": 8, "text": "Linear Time Mu"}]
[{"st": 1, "ed": 5, "text": "improved Present Future form"}, {"st": 6, "ed": 8, "text": "PF form"}, {"st": 10, "ed": 12, "text": "linear time"}, {"st": 28, "ed": 30, "text": "future part"}, {"st": 32, "ed": 34, "text": "new version"}, {"st": 60, "ed": 63, "text": "new PF form"}, {"st": 69, "ed": 71, "text": "PF form"}, {"st": 76, "ed": 80, "text": "Present Future form Graph"}, {"st": 103, "ed": 106, "text": "efficient decision procedure"}, {"st": 111, "ed": 113, "text": "guarded fragment"}, {"st": 115, "ed": 117, "text": "\\nu$TL formulas"}, {"st": 128, "ed": 131, "text": "new decision procedure"}, {"st": 134, "ed": 136, "text": "time complexity"}, {"st": 144, "ed": 146, "text": "exponential space"}]
[{"st": 4, "ed": 7, "text": "probabilistic justification logic"}]
[{"st": 1, "ed": 3, "text": "logic PJ"}, {"st": 5, "ed": 7, "text": "probabilistic logic"}, {"st": 9, "ed": 13, "text": "basic justification logic J."}, {"st": 29, "ed": 31, "text": "main result"}, {"st": 40, "ed": 42, "text": "logic PJ"}, {"st": 50, "ed": 52, "text": "logic J."}]
[{"st": 4, "ed": 6, "text": "Distributed Systems"}, {"st": 7, "ed": 9, "text": "Stable Grounds"}]
[{"st": 2, "ed": 5, "text": "Declarative Networking paradigm"}, {"st": 14, "ed": 16, "text": "distributed computations"}, {"st": 20, "ed": 22, "text": "operational semantics"}, {"st": 30, "ed": 33, "text": "corresponding declarative semantics"}, {"st": 53, "ed": 55, "text": "distributed computations"}, {"st": 59, "ed": 61, "text": "networking delays"}, {"st": 63, "ed": 65, "text": "asynchronous communication"}, {"st": 87, "ed": 90, "text": "stable model semantics"}, {"st": 102, "ed": 104, "text": "semantics matches"}, {"st": 106, "ed": 109, "text": "formal operational semantics"}]
[{"st": 6, "ed": 8, "text": "n$-ary semigroups"}]
[{"st": 7, "ed": 9, "text": "few years"}, {"st": 17, "ed": 19, "text": "many applications"}, {"st": 26, "ed": 29, "text": "constraint satisfaction problem"}, {"st": 41, "ed": 43, "text": "ary semigroups"}, {"st": 52, "ed": 55, "text": "ary associative operation"}, {"st": 69, "ed": 71, "text": "sufficient condition"}, {"st": 87, "ed": 89, "text": "ary semigroups"}, {"st": 99, "ed": 101, "text": "sufficient condition"}, {"st": 106, "ed": 108, "text": "conjectured condition"}, {"st": 125, "ed": 127, "text": "ary semigroup"}, {"st": 133, "ed": 135, "text": "ary subsemigroup"}, {"st": 156, "ed": 159, "text": "idempotent ternary semigroup"}]
[{"st": 0, "ed": 2, "text": "Quantitative Redundancy"}, {"st": 3, "ed": 5, "text": "Partial Implications"}]
[{"st": 3, "ed": 5, "text": "different properties"}, {"st": 7, "ed": 9, "text": "intuitive notion"}, {"st": 17, "ed": 19, "text": "precise semantics"}, {"st": 24, "ed": 26, "text": "partial implication"}, {"st": 28, "ed": 30, "text": "final version"}, {"st": 44, "ed": 47, "text": "Formal Concept Analysis"}]
[]
[{"st": 6, "ed": 9, "text": "famous IC3 algorithm"}, {"st": 12, "ed": 14, "text": "safety properties"}, {"st": 15, "ed": 18, "text": "finite state systems"}, {"st": 30, "ed": 33, "text": "clause propagation phase"}, {"st": 44, "ed": 46, "text": "respective clauses"}, {"st": 59, "ed": 61, "text": "particular clause"}, {"st": 75, "ed": 77, "text": "trigger test"}]
[{"st": 0, "ed": 2, "text": "Proof search"}, {"st": 3, "ed": 7, "text": "propositional abstract separation logics"}, {"st": 8, "ed": 10, "text": "labelled sequents"}]
[{"st": 0, "ed": 2, "text": "Separation logics"}, {"st": 8, "ed": 10, "text": "Hoare logic"}, {"st": 21, "ed": 24, "text": "\" abstract \""}, {"st": 30, "ed": 34, "text": "particular concrete memory model"}, {"st": 36, "ed": 38, "text": "assertion languages"}, {"st": 40, "ed": 44, "text": "propositional abstract separation logics"}, {"st": 58, "ed": 60, "text": "various ways"}, {"st": 64, "ed": 67, "text": "modular proof theory"}, {"st": 68, "ed": 73, "text": "various propositional abstract separation logics"}, {"st": 78, "ed": 80, "text": "sequent calculi"}, {"st": 89, "ed": 91, "text": "sequent calculus"}, {"st": 103, "ed": 105, "text": "original logic"}, {"st": 106, "ed": 108, "text": "separation algebras"}, {"st": 110, "ed": 112, "text": "sound rules"}, {"st": 134, "ed": 137, "text": "sound intermediate calculus"}, {"st": 156, "ed": 161, "text": "other propositional abstract separation logics"}, {"st": 163, "ed": 165, "text": "sound rules"}, {"st": 166, "ed": 168, "text": "indivisible unit"}, {"st": 178, "ed": 180, "text": "theorem prover"}, {"st": 183, "ed": 185, "text": "labelled calculus"}, {"st": 187, "ed": 191, "text": "propositional abstract separation logics"}]
[]
[{"st": 1, "ed": 3, "text": "paper talk"}, {"st": 11, "ed": 13, "text": "Computational Complexity"}, {"st": 42, "ed": 45, "text": "MUC decision problem"}, {"st": 48, "ed": 51, "text": "truth value assignment"}, {"st": 58, "ed": 60, "text": "inner products"}, {"st": 61, "ed": 65, "text": "\" inner product \""}, {"st": 68, "ed": 70, "text": "harmony \""}, {"st": 90, "ed": 92, "text": "Orthogonalization MUC"}, {"st": 96, "ed": 98, "text": "polynomial size"}, {"st": 101, "ed": 103, "text": "high orthogonal"}, {"st": 104, "ed": 106, "text": "inner harmony"}]
[]
[{"st": 34, "ed": 36, "text": "recursive term"}, {"st": 38, "ed": 42, "text": "X|X = t_X \\rangle$"}, {"st": 48, "ed": 51, "text": "equation w.r.t L\\\"{u}ttgen"}, {"st": 54, "ed": 56, "text": "ready simulation"}]
[{"st": 1, "ed": 3, "text": "MSO+U theory"}]
[{"st": 3, "ed": 5, "text": "logic MSO+U"}, {"st": 11, "ed": 13, "text": "order logic"}, {"st": 20, "ed": 22, "text": "unbounding quantifier"}, {"st": 30, "ed": 32, "text": "finite sets"}, {"st": 37, "ed": 39, "text": "large size"}, {"st": 48, "ed": 50, "text": "infinite words"}, {"st": 53, "ed": 55, "text": "MSO+U theory"}, {"st": 67, "ed": 69, "text": "open problem"}, {"st": 76, "ed": 79, "text": "previous undecidability result"}, {"st": 82, "ed": 84, "text": "infinite trees"}, {"st": 85, "ed": 87, "text": "additional axioms"}]
[{"st": 1, "ed": 5, "text": "Counterexample Guided Quantifier Instantiation"}]
[{"st": 3, "ed": 7, "text": "first program synthesis engine"}, {"st": 10, "ed": 12, "text": "SMT solver"}, {"st": 19, "ed": 21, "text": "solution functions"}, {"st": 22, "ed": 24, "text": "unsatisfiability proofs"}, {"st": 26, "ed": 28, "text": "negated form"}, {"st": 29, "ed": 31, "text": "synthesis conjectures"}, {"st": 35, "ed": 37, "text": "novel counterexample"}, {"st": 48, "ed": 51, "text": "finding such proofs"}, {"st": 56, "ed": 58, "text": "important class"}, {"st": 63, "ed": 65, "text": "invocation properties"}, {"st": 71, "ed": 73, "text": "dedicated algorithm"}, {"st": 76, "ed": 78, "text": "syntax restrictions"}, {"st": 79, "ed": 81, "text": "generated solutions"}, {"st": 94, "ed": 96, "text": "syntactic form"}, {"st": 106, "ed": 109, "text": "evaluation function axioms"}, {"st": 111, "ed": 113, "text": "syntactic restrictions"}, {"st": 116, "ed": 118, "text": "algebraic datatypes"}, {"st": 123, "ed": 127, "text": "algebraic datatype decision procedure"}, {"st": 132, "ed": 134, "text": "experimental evaluation"}, {"st": 138, "ed": 140, "text": "synthesis benchmarks"}, {"st": 146, "ed": 149, "text": "CVC4 SMT solver"}, {"st": 158, "ed": 160, "text": "art tools"}]
[{"st": 3, "ed": 5, "text": "proof nets"}, {"st": 8, "ed": 10, "text": "substructural logics"}]
[{"st": 11, "ed": 14, "text": "\" proof schemes"}, {"st": 16, "ed": 18, "text": "\\emph{matrix method"}, {"st": 20, "ed": 22, "text": "\\emph{proof nets"}, {"st": 34, "ed": 36, "text": "substructural hierarchy"}, {"st": 44, "ed": 47, "text": "nonassociative Lambek system"}, {"st": 49, "ed": 51, "text": "novel treatment"}, {"st": 52, "ed": 54, "text": "proof nets"}, {"st": 62, "ed": 64, "text": "proof nets"}, {"st": 70, "ed": 72, "text": "uniform notation"}, {"st": 85, "ed": 87, "text": "various logics"}]
[{"st": 6, "ed": 8, "text": "Natural Numbers"}]
[{"st": 1, "ed": 4, "text": "provably correct bijection"}, {"st": 7, "ed": 10, "text": "order abstract syntax"}, {"st": 15, "ed": 17, "text": "natural numbers"}, {"st": 34, "ed": 36, "text": "adequate encoding"}, {"st": 45, "ed": 47, "text": "term family"}, {"st": 56, "ed": 58, "text": "many situations"}, {"st": 94, "ed": 96, "text": "natural numbers"}, {"st": 100, "ed": 102, "text": "such bijections"}, {"st": 113, "ed": 116, "text": "\" bijection generator"}, {"st": 118, "ed": 121, "text": "generates such bijections"}]
[{"st": 0, "ed": 3, "text": "Pure Type Systems"}, {"st": 4, "ed": 6, "text": "Explicit Contexts"}]
[{"st": 10, "ed": 12, "text": "typing judgments"}, {"st": 15, "ed": 17, "text": "explicit contexts"}, {"st": 22, "ed": 25, "text": "shape \" Gamma"}, {"st": 28, "ed": 30, "text": "B \""}, {"st": 41, "ed": 43, "text": "B \""}, {"st": 45, "ed": 47, "text": "key feature"}, {"st": 53, "ed": 55, "text": "bound variables"}, {"st": 68, "ed": 74, "text": "\" Pure Type System \" class"}, {"st": 75, "ed": 77, "text": "type theories"}, {"st": 89, "ed": 91, "text": "systems correspond"}, {"st": 93, "ed": 95, "text": "natural way"}, {"st": 98, "ed": 101, "text": "Pure Type Systems"}, {"st": 118, "ed": 120, "text": "traditional presentations"}, {"st": 121, "ed": 123, "text": "type theory"}, {"st": 131, "ed": 133, "text": "type theory"}, {"st": 136, "ed": 139, "text": "type judgments share"}, {"st": 149, "ed": 151, "text": "many variables"}, {"st": 153, "ed": 155, "text": "possible type"}, {"st": 162, "ed": 166, "text": "system \" Gamma_infinity \""}, {"st": 174, "ed": 176, "text": "type judgment"}, {"st": 179, "ed": 181, "text": "B \""}, {"st": 185, "ed": 189, "text": "\" Gamma_infinity |- A"}, {"st": 190, "ed": 192, "text": "B \""}, {"st": 195, "ed": 199, "text": "fixed infinite type context"}, {"st": 201, "ed": 203, "text": "Gamma_infinity \""}]
[]
[{"st": 11, "ed": 13, "text": "logical framework"}, {"st": 18, "ed": 20, "text": "object logics"}, {"st": 28, "ed": 31, "text": "Isabelle logical framework"}, {"st": 37, "ed": 39, "text": "module system"}, {"st": 43, "ed": 45, "text": "major novelty"}, {"st": 55, "ed": 58, "text": "advanced Isabelle features"}, {"st": 59, "ed": 61, "text": "type classes"}, {"st": 67, "ed": 70, "text": "type classes relies"}, {"st": 78, "ed": 81, "text": "LF module system"}, {"st": 82, "ed": 84, "text": "morphism variables"}, {"st": 93, "ed": 95, "text": "present system"}, {"st": 108, "ed": 110, "text": "type classes"}, {"st": 113, "ed": 115, "text": "modular structure"}, {"st": 122, "ed": 124, "text": "necessary extension"}, {"st": 126, "ed": 129, "text": "LF module system"}]
[{"st": 0, "ed": 5, "text": "Tableaux Modulo Theories Using Superdeduction"}]
[{"st": 9, "ed": 12, "text": "tableaux modulo theories"}, {"st": 27, "ed": 29, "text": "deduction system"}, {"st": 30, "ed": 33, "text": "new deduction rules"}, {"st": 45, "ed": 47, "text": "theorem prover"}, {"st": 53, "ed": 55, "text": "set theory"}, {"st": 57, "ed": 59, "text": "B method"}, {"st": 68, "ed": 70, "text": "Atelier B"}, {"st": 77, "ed": 80, "text": "B proof rules"}, {"st": 109, "ed": 111, "text": "Siemens IC"}, {"st": 132, "ed": 135, "text": "first order theory"}, {"st": 143, "ed": 145, "text": "TPTP library"}, {"st": 149, "ed": 151, "text": "large set"}, {"st": 152, "ed": 155, "text": "first order problems"}]
[{"st": 2, "ed": 5, "text": "Cubical Type Theory"}]
[{"st": 0, "ed": 3, "text": "Cubical type theory"}, {"st": 9, "ed": 12, "text": "L\\\"of type theory"}, {"st": 26, "ed": 28, "text": "direct manipulation"}, {"st": 30, "ed": 32, "text": "n$-dimensional cubes"}, {"st": 36, "ed": 38, "text": "Univalence Axiom"}, {"st": 48, "ed": 51, "text": "cubical type theory"}, {"st": 53, "ed": 55, "text": "natural number"}, {"st": 57, "ed": 59, "text": "context build"}, {"st": 61, "ed": 63, "text": "name variables"}, {"st": 78, "ed": 81, "text": "deterministic operational semantics"}, {"st": 84, "ed": 86, "text": "computability argument"}]
[{"st": 1, "ed": 3, "text": "recursion hierarchy"}]
[{"st": 13, "ed": 15, "text": "point operators"}, {"st": 27, "ed": 29, "text": "\\leq k$."}, {"st": 38, "ed": 40, "text": "strict hierarchy"}, {"st": 65, "ed": 67, "text": "observational equivalence"}, {"st": 81, "ed": 83, "text": "substantial use"}, {"st": 87, "ed": 90, "text": "nested sequential procedures"}, {"st": 93, "ed": 96, "text": "PCF B\\\"ohm trees"}, {"st": 101, "ed": 103, "text": "recent book"}]
[{"st": 6, "ed": 8, "text": "combinatory logic"}]
[{"st": 3, "ed": 5, "text": "quantitative basis"}, {"st": 6, "ed": 8, "text": "independent analysis"}, {"st": 9, "ed": 11, "text": "combinatory logic"}, {"st": 14, "ed": 16, "text": "general argument"}, {"st": 17, "ed": 20, "text": "plane binary trees"}, {"st": 21, "ed": 23, "text": "labelled leaves"}, {"st": 42, "ed": 45, "text": "complete combinator bases"}, {"st": 47, "ed": 49, "text": "inter alia"}, {"st": 70, "ed": 73, "text": "order reduction grammars"}, {"st": 94, "ed": 97, "text": "order reduction steps"}, {"st": 98, "ed": 101, "text": "positive asymptotic density"}, {"st": 120, "ed": 122, "text": "significant fractions"}, {"st": 159, "ed": 162, "text": "computer experimental results"}]
[{"st": 0, "ed": 2, "text": "Port Protocols"}, {"st": 7, "ed": 9, "text": "Component Systems"}]
[{"st": 8, "ed": 10, "text": "property verification"}, {"st": 15, "ed": 18, "text": "global system behavior"}, {"st": 20, "ed": 22, "text": "component model"}, {"st": 33, "ed": 35, "text": "local behavior"}, {"st": 36, "ed": 39, "text": "fixed sized subsystems"}, {"st": 56, "ed": 58, "text": "global behavior"}, {"st": 62, "ed": 64, "text": "local behaviors"}, {"st": 73, "ed": 75, "text": "small parts"}, {"st": 77, "ed": 79, "text": "local behaviors"}, {"st": 80, "ed": 82, "text": "port protocols"}]
[{"st": 5, "ed": 7, "text": "loop system"}]
[{"st": 5, "ed": 7, "text": "supervisory controller"}, {"st": 14, "ed": 16, "text": "different theories"}, {"st": 19, "ed": 21, "text": "automatic synthesis"}, {"st": 41, "ed": 43, "text": "asynchronous interaction"}, {"st": 55, "ed": 58, "text": "supervisory control theories"}, {"st": 59, "ed": 61, "text": "synchronous interaction"}, {"st": 66, "ed": 68, "text": "implementation suffer"}, {"st": 73, "ed": 76, "text": "inexact synchronisation problem"}, {"st": 85, "ed": 87, "text": "inexact synchronisation"}, {"st": 89, "ed": 92, "text": "process algebraic setting"}, {"st": 97, "ed": 99, "text": "general problem"}, {"st": 107, "ed": 109, "text": "loop system"}, {"st": 112, "ed": 114, "text": "communication medium"}, {"st": 119, "ed": 121, "text": "loop system"}, {"st": 127, "ed": 129, "text": "sufficient conditions"}, {"st": 134, "ed": 136, "text": "loop system"}, {"st": 144, "ed": 146, "text": "loop system"}]
[{"st": 2, "ed": 5, "text": "Guarantee Controller Synthesis"}, {"st": 8, "ed": 10, "text": "Physical Systems"}]
[{"st": 7, "ed": 9, "text": "physical systems"}, {"st": 14, "ed": 16, "text": "difficult problem"}, {"st": 19, "ed": 22, "text": "different modeling abstractions"}, {"st": 24, "ed": 26, "text": "control components"}, {"st": 28, "ed": 30, "text": "software components"}, {"st": 32, "ed": 34, "text": "recent trend"}, {"st": 51, "ed": 53, "text": "design methodologies"}, {"st": 61, "ed": 63, "text": "design paradigm"}, {"st": 80, "ed": 82, "text": "temporal specifications"}, {"st": 86, "ed": 88, "text": "physical system"}, {"st": 108, "ed": 111, "text": "Linear Temporal Logic"}, {"st": 116, "ed": 118, "text": "physical environment"}, {"st": 122, "ed": 125, "text": "smooth differential equation"}, {"st": 139, "ed": 141, "text": "physical systems"}, {"st": 155, "ed": 157, "text": "interesting properties"}, {"st": 173, "ed": 175, "text": "preliminary implementation"}, {"st": 180, "ed": 182, "text": "tool PESSOALTL"}]
[{"st": 0, "ed": 2, "text": "Proof equivalence"}]
[{"st": 0, "ed": 3, "text": "MLL proof equivalence"}, {"st": 12, "ed": 15, "text": "multiplicative linear logic"}, {"st": 21, "ed": 23, "text": "inference permutations"}, {"st": 30, "ed": 32, "text": "word problem"}, {"st": 35, "ed": 37, "text": "autonomous categories"}, {"st": 38, "ed": 40, "text": "Previous work"}, {"st": 49, "ed": 51, "text": "rewiring problem"}, {"st": 52, "ed": 54, "text": "proof nets"}, {"st": 60, "ed": 62, "text": "full MLL"}, {"st": 73, "ed": 75, "text": "recent work"}, {"st": 76, "ed": 78, "text": "reconfiguration problems"}, {"st": 86, "ed": 89, "text": "MLL proof equivalence"}, {"st": 98, "ed": 101, "text": "Nondeterministic Constraint Logic"}, {"st": 103, "ed": 105, "text": "important consequence"}, {"st": 114, "ed": 116, "text": "satisfactory notion"}, {"st": 117, "ed": 119, "text": "proof nets"}, {"st": 128, "ed": 131, "text": "current complexity assumptions"}, {"st": 136, "ed": 138, "text": "hardness result"}, {"st": 142, "ed": 144, "text": "normal forms"}, {"st": 151, "ed": 153, "text": "weakening rule"}, {"st": 158, "ed": 161, "text": "similar rewiring problem"}]
[{"st": 2, "ed": 4, "text": "checking Liveness"}, {"st": 5, "ed": 7, "text": "Collaborative Processes"}, {"st": 10, "ed": 12, "text": "Unbounded Recursion"}]
[{"st": 3, "ed": 5, "text": "first session"}, {"st": 10, "ed": 13, "text": "response liveness properties"}, {"st": 18, "ed": 20, "text": "communicating processes"}, {"st": 27, "ed": 29, "text": "select types"}, {"st": 31, "ed": 35, "text": "standard binary session types"}, {"st": 39, "ed": 41, "text": "required responses"}, {"st": 46, "ed": 48, "text": "particular label"}, {"st": 54, "ed": 56, "text": "other labels"}, {"st": 77, "ed": 80, "text": "standard session types"}, {"st": 84, "ed": 86, "text": "type system"}, {"st": 88, "ed": 90, "text": "process calculus"}, {"st": 95, "ed": 97, "text": "collaborative BPMN"}, {"st": 114, "ed": 116, "text": "message passing"}, {"st": 119, "ed": 121, "text": "unbounded looping"}, {"st": 126, "ed": 128, "text": "type system"}, {"st": 137, "ed": 139, "text": "response liveness"}, {"st": 142, "ed": 145, "text": "lock free processes"}, {"st": 154, "ed": 156, "text": "type system"}, {"st": 158, "ed": 160, "text": "concrete example"}, {"st": 162, "ed": 165, "text": "infinite state system"}]
[{"st": 4, "ed": 6, "text": "Gap Algebras"}]
[{"st": 4, "ed": 6, "text": "idempotent algebra"}, {"st": 8, "ed": 11, "text": "3-element domain D"}, {"st": 33, "ed": 35, "text": "beta subsets"}, {"st": 80, "ed": 82, "text": "singleton source"}, {"st": 88, "ed": 90, "text": "singleton source"}]
[{"st": 0, "ed": 2, "text": "Characteristic Formulae"}, {"st": 3, "ed": 5, "text": "Session Types"}]
[{"st": 3, "ed": 5, "text": "crucial ingredient"}, {"st": 6, "ed": 9, "text": "session type theory"}, {"st": 16, "ed": 18, "text": "language implementations"}, {"st": 25, "ed": 27, "text": "effective ways"}, {"st": 31, "ed": 33, "text": "session type"}, {"st": 41, "ed": 44, "text": "characteristic formulae approach"}, {"st": 49, "ed": 51, "text": "core contribution"}, {"st": 60, "ed": 62, "text": "calculus formula"}, {"st": 92, "ed": 94, "text": "efficient algorithm"}, {"st": 98, "ed": 100, "text": "session types"}]
[{"st": 7, "ed": 9, "text": "Computability Logic"}]
[{"st": 13, "ed": 15, "text": "recurrence operation"}, {"st": 16, "ed": 18, "text": "Computability Logic"}, {"st": 27, "ed": 31, "text": "\" canonical \" version"}, {"st": 40, "ed": 42, "text": "static property"}]
[{"st": 0, "ed": 2, "text": "Efficient computation"}, {"st": 3, "ed": 5, "text": "exact solutions"}, {"st": 6, "ed": 8, "text": "quantitative model"}]
[{"st": 0, "ed": 3, "text": "Quantitative model checkers"}, {"st": 4, "ed": 7, "text": "Markov Decision Processes"}, {"st": 22, "ed": 24, "text": "rational numbers"}, {"st": 27, "ed": 30, "text": "model checking results"}, {"st": 43, "ed": 45, "text": "exact techniques"}, {"st": 63, "ed": 65, "text": "exact results"}, {"st": 68, "ed": 70, "text": "approximated solution"}, {"st": 94, "ed": 96, "text": "model checker"}, {"st": 97, "ed": 99, "text": "finite precision"}, {"st": 110, "ed": 112, "text": "corresponding basis"}, {"st": 116, "ed": 118, "text": "programming problem"}, {"st": 135, "ed": 137, "text": "case probability"}, {"st": 155, "ed": 157, "text": "undiscounted case"}, {"st": 171, "ed": 173, "text": "programming problem"}, {"st": 195, "ed": 197, "text": "case probability"}, {"st": 204, "ed": 206, "text": "model checker"}, {"st": 217, "ed": 219, "text": "exact solutions"}, {"st": 221, "ed": 223, "text": "candidate scheduler"}, {"st": 231, "ed": 233, "text": "simplex method"}, {"st": 239, "ed": 241, "text": "default basis"}]
[{"st": 0, "ed": 4, "text": "Weak Markovian Bisimulation Congruences"}, {"st": 5, "ed": 7, "text": "Exact CTMC"}, {"st": 8, "ed": 10, "text": "Level Aggregations"}, {"st": 11, "ed": 13, "text": "Concurrent Processes"}]
[{"st": 5, "ed": 9, "text": "weak Markovian bisimulation equivalence"}, {"st": 13, "ed": 15, "text": "time setting"}, {"st": 22, "ed": 24, "text": "internal actions"}, {"st": 28, "ed": 30, "text": "internal actions"}, {"st": 32, "ed": 35, "text": "same average duration"}, {"st": 36, "ed": 38, "text": "execution probability"}, {"st": 40, "ed": 42, "text": "corresponding sequences"}, {"st": 44, "ed": 48, "text": "weak Markovian bisimulation equivalence"}, {"st": 52, "ed": 54, "text": "sequential processes"}, {"st": 62, "ed": 64, "text": "exact CTMC"}, {"st": 65, "ed": 67, "text": "level aggregation"}, {"st": 68, "ed": 70, "text": "steady state"}, {"st": 105, "ed": 107, "text": "reasonable tradeoff"}, {"st": 117, "ed": 119, "text": "concurrent processes"}, {"st": 128, "ed": 130, "text": "abstraction capability"}, {"st": 134, "ed": 136, "text": "concurrent computations"}, {"st": 143, "ed": 145, "text": "congruence property"}, {"st": 156, "ed": 158, "text": "level aggregation"}, {"st": 161, "ed": 163, "text": "steady state"}, {"st": 166, "ed": 168, "text": "certain subset"}]
[{"st": 4, "ed": 9, "text": "Logically Constrained Term Rewriting Systems"}]
[{"st": 36, "ed": 38, "text": "logical constraints"}]
[{"st": 1, "ed": 3, "text": "Trace Abstraction"}, {"st": 4, "ed": 6, "text": "Abstract Interpretation"}]
[{"st": 1, "ed": 3, "text": "CEGAR loop"}, {"st": 4, "ed": 6, "text": "software model"}, {"st": 11, "ed": 14, "text": "abstraction refinement procedure"}, {"st": 18, "ed": 20, "text": "loop invariant"}, {"st": 22, "ed": 25, "text": "abstraction refinement procedure"}, {"st": 28, "ed": 30, "text": "SMT solver"}, {"st": 39, "ed": 41, "text": "restricted form"}, {"st": 56, "ed": 60, "text": "new abstraction refinement procedure"}, {"st": 71, "ed": 73, "text": "abstract interpretation"}, {"st": 97, "ed": 99, "text": "loop invariant"}, {"st": 103, "ed": 105, "text": "SMT solver"}, {"st": 111, "ed": 114, "text": "abstract interpretation returns"}, {"st": 115, "ed": 117, "text": "indefinite answer"}, {"st": 126, "ed": 128, "text": "abstract interpretation"}, {"st": 130, "ed": 132, "text": "SMT solver"}, {"st": 136, "ed": 138, "text": "experimental evaluation"}, {"st": 142, "ed": 144, "text": "trace abstraction"}, {"st": 146, "ed": 148, "text": "practical potential"}]
[{"st": 1, "ed": 4, "text": "Optimization Modulo Theories"}, {"st": 7, "ed": 9, "text": "Sorting Networks"}]
[{"st": 0, "ed": 3, "text": "Optimization Modulo Theories"}, {"st": 25, "ed": 27, "text": "MaxSMT --or"}, {"st": 32, "ed": 35, "text": "Boolean objective functions"}, {"st": 41, "ed": 44, "text": "relevant strict subcase"}, {"st": 73, "ed": 76, "text": "art MAXSAT solvers"}, {"st": 101, "ed": 103, "text": "intrinsic inefficiencies"}, {"st": 104, "ed": 108, "text": "MaxSMT / OMT+PB problems"}, {"st": 112, "ed": 114, "text": "major source"}, {"st": 115, "ed": 117, "text": "such inefficiencies"}, {"st": 140, "ed": 143, "text": "OptiMathSAT OMT solver"}, {"st": 147, "ed": 150, "text": "extensive empirical evaluation"}, {"st": 191, "ed": 193, "text": "interesting insights"}, {"st": 195, "ed": 197, "text": "different approaches"}]
[{"st": 1, "ed": 5, "text": "Complete Quantitative Deduction System"}, {"st": 7, "ed": 9, "text": "Bisimilarity Distance"}, {"st": 10, "ed": 12, "text": "Markov Chains"}]
[{"st": 6, "ed": 8, "text": "complete axiomatization"}, {"st": 10, "ed": 12, "text": "bisimilarity distance"}, {"st": 23, "ed": 25, "text": "Markov chains"}, {"st": 35, "ed": 37, "text": "quantitative extension"}, {"st": 38, "ed": 40, "text": "equational logic"}, {"st": 55, "ed": 57, "text": "equality relations"}, {"st": 58, "ed": 61, "text": "t \\equiv_\\varepsilon s$"}, {"st": 87, "ed": 90, "text": "quantitative deduction system"}, {"st": 93, "ed": 95, "text": "natural way"}, {"st": 96, "ed": 98, "text": "equational system"}, {"st": 99, "ed": 101, "text": "probabilistic bisimilarity"}, {"st": 114, "ed": 116, "text": "Kantorovich distance"}, {"st": 117, "ed": 119, "text": "probability distributions"}, {"st": 128, "ed": 130, "text": "metric extension"}, {"st": 134, "ed": 137, "text": "style representation theorem"}, {"st": 140, "ed": 142, "text": "Markov chains"}, {"st": 150, "ed": 153, "text": "general coalgebraic fashion"}]
[{"st": 3, "ed": 5, "text": "theoretical approach"}, {"st": 6, "ed": 9, "text": "ABox reasoning services"}, {"st": 10, "ed": 12, "text": "Extended Version"}]
[{"st": 7, "ed": 11, "text": "common ABox reasoning services"}, {"st": 33, "ed": 35, "text": "satisfiability problem"}, {"st": 39, "ed": 42, "text": "theoretic fragment \\flqsr"}, {"st": 55, "ed": 57, "text": "various concept"}, {"st": 58, "ed": 60, "text": "role constructs"}, {"st": 62, "ed": 64, "text": "data types"}, {"st": 78, "ed": 80, "text": "Decidability results"}, {"st": 88, "ed": 92, "text": "conjunctive query answering problem"}, {"st": 97, "ed": 101, "text": "Order Conjunctive Query Answering"}, {"st": 110, "ed": 114, "text": "wide\\-spread ABox reasoning tasks"}, {"st": 130, "ed": 132, "text": "knowledge bases"}, {"st": 137, "ed": 139, "text": "conjunctive queries"}, {"st": 162, "ed": 164, "text": "decision procedure"}, {"st": 166, "ed": 168, "text": "CQA problem"}]
[{"st": 2, "ed": 4, "text": "Sensitive Context"}]
[{"st": 12, "ed": 14, "text": "temporal logic"}, {"st": 20, "ed": 22, "text": "state processes"}, {"st": 25, "ed": 28, "text": "biochemical reaction networks"}, {"st": 34, "ed": 38, "text": "Metric Interval Temporal Logic"}, {"st": 44, "ed": 47, "text": "\" context modality"}, {"st": 59, "ed": 61, "text": "external process"}, {"st": 62, "ed": 64, "text": "LBC models"}, {"st": 77, "ed": 79, "text": "process algebra"}, {"st": 80, "ed": 83, "text": "continuous state space"}, {"st": 94, "ed": 96, "text": "many points"}, {"st": 98, "ed": 100, "text": "behavioural trajectory"}, {"st": 107, "ed": 109, "text": "further trajectories"}, {"st": 113, "ed": 115, "text": "such point"}, {"st": 124, "ed": 126, "text": "spatial modalities"}, {"st": 130, "ed": 132, "text": "large number"}, {"st": 136, "ed": 139, "text": "costly numerical solution"}, {"st": 140, "ed": 142, "text": "differential equations"}, {"st": 149, "ed": 151, "text": "intermediate values"}, {"st": 152, "ed": 154, "text": "discrete points"}, {"st": 172, "ed": 175, "text": "signal temporal logic"}, {"st": 177, "ed": 179, "text": "sensitivity analysis"}, {"st": 180, "ed": 182, "text": "Boolean signals"}, {"st": 183, "ed": 186, "text": "compress trace information"}, {"st": 189, "ed": 191, "text": "efficient computation"}, {"st": 193, "ed": 195, "text": "sensitivity analysis"}, {"st": 209, "ed": 211, "text": "sample trajectories"}]
[]
[{"st": 7, "ed": 9, "text": "local lexing"}, {"st": 14, "ed": 16, "text": "separated stages"}, {"st": 28, "ed": 30, "text": "parsing progress"}, {"st": 34, "ed": 36, "text": "simple mechanism"}, {"st": 38, "ed": 40, "text": "lexical ambiguity"}, {"st": 46, "ed": 48, "text": "language design"}, {"st": 59, "ed": 61, "text": "free grammars"}, {"st": 66, "ed": 68, "text": "lexical level"}, {"st": 85, "ed": 87, "text": "language specification"}, {"st": 101, "ed": 103, "text": "level algorithm"}, {"st": 104, "ed": 106, "text": "local lexing"}, {"st": 129, "ed": 132, "text": "local lexing semantics"}, {"st": 133, "ed": 136, "text": "Isabelle / HOL"}]
[{"st": 0, "ed": 2, "text": "Finite Satisfiability"}, {"st": 10, "ed": 12, "text": "Transitive Guards"}]
[{"st": 9, "ed": 12, "text": "variable guarded fragment"}, {"st": 17, "ed": 19, "text": "binary predicates"}, {"st": 31, "ed": 33, "text": "special way"}, {"st": 35, "ed": 37, "text": "transitive relations"}, {"st": 38, "ed": 40, "text": "equivalence relations"}, {"st": 43, "ed": 45, "text": "partial orders"}, {"st": 51, "ed": 53, "text": "only fragment"}, {"st": 60, "ed": 62, "text": "model property"}, {"st": 65, "ed": 67, "text": "equivalence guards"}, {"st": 86, "ed": 89, "text": "minimal finite model"}, {"st": 105, "ed": 107, "text": "finite models"}, {"st": 114, "ed": 116, "text": "multidimensional grids"}, {"st": 119, "ed": 121, "text": "cylindrical surface"}, {"st": 128, "ed": 130, "text": "upper bound"}, {"st": 135, "ed": 138, "text": "finite satisfiability problem"}, {"st": 148, "ed": 150, "text": "optimal ones"}, {"st": 157, "ed": 159, "text": "particular NExpTime"}, {"st": 162, "ed": 164, "text": "equivalence guards"}, {"st": 170, "ed": 172, "text": "transitive guards"}, {"st": 183, "ed": 185, "text": "integer programming"}]
[{"st": 0, "ed": 2, "text": "Compatibility Properties"}, {"st": 5, "ed": 8, "text": "Asynchronously Communicating Components"}]
[{"st": 12, "ed": 14, "text": "asynchronous composition"}, {"st": 26, "ed": 28, "text": "transition systems"}, {"st": 29, "ed": 31, "text": "Synchronous composition"}, {"st": 34, "ed": 36, "text": "simultaneous execution"}, {"st": 40, "ed": 42, "text": "input actions"}, {"st": 46, "ed": 48, "text": "asynchronous composition"}, {"st": 49, "ed": 51, "text": "unbounded FIFO"}, {"st": 54, "ed": 56, "text": "message transfer"}, {"st": 62, "ed": 64, "text": "compatibility notions"}, {"st": 90, "ed": 92, "text": "weak versions"}, {"st": 101, "ed": 103, "text": "internal actions"}, {"st": 111, "ed": 113, "text": "open systems"}, {"st": 119, "ed": 121, "text": "strong /"}, {"st": 123, "ed": 125, "text": "synchronous compatibility"}, {"st": 132, "ed": 134, "text": "strong /"}, {"st": 136, "ed": 138, "text": "asynchronous compatibility"}, {"st": 147, "ed": 149, "text": "duplex systems"}, {"st": 157, "ed": 160, "text": "weak asynchronous compatibility"}, {"st": 162, "ed": 164, "text": "non half"}, {"st": 165, "ed": 167, "text": "duplex systems"}, {"st": 170, "ed": 172, "text": "decidable criterion"}, {"st": 174, "ed": 177, "text": "weak asynchronous compatibility"}, {"st": 196, "ed": 198, "text": "asynchronous system"}, {"st": 224, "ed": 226, "text": "asynchronous case"}]
[{"st": 2, "ed": 5, "text": "Confluence Modulo Equivalence"}, {"st": 6, "ed": 9, "text": "Constraint Handling Rules"}]
[{"st": 0, "ed": 2, "text": "Previous results"}, {"st": 6, "ed": 9, "text": "Constraint Handling Rules"}, {"st": 22, "ed": 24, "text": "realistic class"}, {"st": 25, "ed": 27, "text": "CHR programs"}, {"st": 37, "ed": 39, "text": "relaxed notion"}, {"st": 40, "ed": 43, "text": "confluence modulo equivalence"}, {"st": 49, "ed": 51, "text": "while confluence"}, {"st": 53, "ed": 55, "text": "terminating program"}, {"st": 58, "ed": 60, "text": "alternative derivations"}, {"st": 62, "ed": 64, "text": "query lead"}, {"st": 66, "ed": 70, "text": "exact same final state"}, {"st": 71, "ed": 74, "text": "confluence modulo equivalence"}, {"st": 77, "ed": 79, "text": "final states"}, {"st": 86, "ed": 88, "text": "equivalence relation"}, {"st": 109, "ed": 111, "text": "incomplete ones"}, {"st": 119, "ed": 121, "text": "previous work"}, {"st": 129, "ed": 132, "text": "new operational semantics"}, {"st": 138, "ed": 140, "text": "such predicates"}, {"st": 145, "ed": 147, "text": "semantics differs"}, {"st": 165, "ed": 167, "text": "future studies"}, {"st": 173, "ed": 175, "text": "logical subset"}, {"st": 185, "ed": 187, "text": "order logic"}, {"st": 196, "ed": 198, "text": "present case"}, {"st": 203, "ed": 205, "text": "formal meta"}, {"st": 211, "ed": 213, "text": "abstract states"}, {"st": 218, "ed": 220, "text": "level restrictions"}, {"st": 227, "ed": 229, "text": "incomplete predicates"}, {"st": 240, "ed": 242, "text": "systematic enumeration"}, {"st": 243, "ed": 245, "text": "proof cases"}, {"st": 250, "ed": 252, "text": "mechanical support"}, {"st": 253, "ed": 255, "text": "such proofs"}]
[{"st": 0, "ed": 2, "text": "HoTT formalisation"}, {"st": 5, "ed": 8, "text": "Dependency Graphs \\"}]
[{"st": 6, "ed": 8, "text": "Bas Spitter"}, {"st": 25, "ed": 27, "text": "dependency graphs"}, {"st": 29, "ed": 31, "text": "HoTT library"}, {"st": 40, "ed": 42, "text": "dependency graph"}, {"st": 44, "ed": 46, "text": "main obstacle"}, {"st": 47, "ed": 49, "text": "machine learning"}, {"st": 88, "ed": 90, "text": "HoTT library"}, {"st": 104, "ed": 106, "text": "HoTT library"}, {"st": 115, "ed": 117, "text": "Dependency graphs"}]
[{"st": 0, "ed": 2, "text": "Semantic information"}, {"st": 3, "ed": 5, "text": "artificial intelligence"}]
[{"st": 2, "ed": 4, "text": "computational system"}, {"st": 18, "ed": 20, "text": "basic deductions"}, {"st": 42, "ed": 44, "text": "new information"}, {"st": 46, "ed": 48, "text": "present article"}, {"st": 54, "ed": 56, "text": "semantic informativity"}, {"st": 57, "ed": 59, "text": "valid deductions"}, {"st": 61, "ed": 63, "text": "dynamic setting"}, {"st": 84, "ed": 86, "text": "semantic informativity"}, {"st": 107, "ed": 109, "text": "heuristic principle"}, {"st": 112, "ed": 114, "text": "deductive power"}, {"st": 115, "ed": 117, "text": "computational systems"}]
[{"st": 2, "ed": 4, "text": "Order Pi"}, {"st": 7, "ed": 9, "text": "Spatial Logics"}]
[{"st": 17, "ed": 19, "text": "spatial logic"}, {"st": 25, "ed": 28, "text": "spatial logic SL"}, {"st": 38, "ed": 40, "text": "inference system"}, {"st": 58, "ed": 61, "text": "structure congruence relation"}, {"st": 64, "ed": 67, "text": "step transition relation"}, {"st": 72, "ed": 74, "text": "logical relation"}, {"st": 75, "ed": 77, "text": "SL formulae"}, {"st": 87, "ed": 89, "text": "SL formulae"}, {"st": 101, "ed": 104, "text": "weak semantics version"}, {"st": 122, "ed": 124, "text": "new logic"}, {"st": 138, "ed": 140, "text": "replication operator"}]
[{"st": 5, "ed": 7, "text": "deterministic call"}]
[{"st": 5, "ed": 7, "text": "deterministic extension"}, {"st": 13, "ed": 16, "text": "value lambda calculus"}, {"st": 21, "ed": 23, "text": "additive fragment"}, {"st": 38, "ed": 40, "text": "type system"}, {"st": 43, "ed": 46, "text": "right linearity present"}, {"st": 47, "ed": 49, "text": "such formalisms"}, {"st": 53, "ed": 55, "text": "subject reduction"}, {"st": 57, "ed": 60, "text": "strong normalisation properties"}, {"st": 70, "ed": 72, "text": "System F"}, {"st": 79, "ed": 82, "text": "non linear fragment"}, {"st": 83, "ed": 85, "text": "linear logic"}]
[{"st": 2, "ed": 7, "text": "Consensus Procedures Can Execute Forever"}, {"st": 9, "ed": 11, "text": "Constructive Version"}]
[{"st": 5, "ed": 7, "text": "Paterson theorem"}, {"st": 19, "ed": 22, "text": "asynchronous distributed system"}, {"st": 27, "ed": 29, "text": "binary value"}, {"st": 31, "ed": 33, "text": "single process"}, {"st": 41, "ed": 43, "text": "theoretical result"}, {"st": 65, "ed": 67, "text": "hypothetical construction"}, {"st": 69, "ed": 71, "text": "nonterminating execution"}, {"st": 73, "ed": 75, "text": "main lemma"}, {"st": 82, "ed": 84, "text": "protocol designers"}, {"st": 95, "ed": 97, "text": "important property"}, {"st": 98, "ed": 100, "text": "consensus procedures"}, {"st": 111, "ed": 113, "text": "global state"}, {"st": 120, "ed": 123, "text": "A deterministic fault"}, {"st": 124, "ed": 127, "text": "tolerant consensus protocol"}, {"st": 133, "ed": 136, "text": "reachable global state"}, {"st": 140, "ed": 142, "text": "execution path"}, {"st": 152, "ed": 154, "text": "nonterminating execution"}, {"st": 156, "ed": 158, "text": "such protocol"}, {"st": 165, "ed": 168, "text": "nonblocking protocol P"}, {"st": 170, "ed": 173, "text": "natural number n"}, {"st": 182, "ed": 184, "text": "th step"}, {"st": 186, "ed": 189, "text": "infinitely indecisive computation"}, {"st": 194, "ed": 196, "text": "constructive result"}, {"st": 198, "ed": 200, "text": "classical FLP"}, {"st": 209, "ed": 211, "text": "classical result"}, {"st": 214, "ed": 216, "text": "Strong FLP"}, {"st": 225, "ed": 227, "text": "important role"}, {"st": 230, "ed": 232, "text": "protocol design"}, {"st": 234, "ed": 236, "text": "interesting consequence"}, {"st": 238, "ed": 240, "text": "constructive proof"}, {"st": 250, "ed": 252, "text": "undefeatable attacker"}, {"st": 254, "ed": 256, "text": "consensus protocol"}, {"st": 275, "ed": 277, "text": "certain kinds"}]
[{"st": 2, "ed": 4, "text": "Coalgebraic Interpretation"}, {"st": 5, "ed": 8, "text": "Propositional Dynamic Logic"}]
[{"st": 3, "ed": 6, "text": "propositional dynamic logic"}, {"st": 10, "ed": 12, "text": "Kripke models"}, {"st": 17, "ed": 20, "text": "interpreting Kripke model"}, {"st": 27, "ed": 29, "text": "modal operators"}, {"st": 33, "ed": 35, "text": "significant challenge"}, {"st": 41, "ed": 44, "text": "stochastic Kripke models"}, {"st": 55, "ed": 57, "text": "natural counterpart"}, {"st": 61, "ed": 63, "text": "stochastic relations"}, {"st": 66, "ed": 68, "text": "rewrite rules"}, {"st": 86, "ed": 89, "text": "unique irreducible tree"}, {"st": 96, "ed": 98, "text": "predicate lifting"}, {"st": 107, "ed": 109, "text": "paper establishes"}, {"st": 119, "ed": 121, "text": "probabilistic models"}, {"st": 129, "ed": 131, "text": "behavioral equivalence"}, {"st": 135, "ed": 137, "text": "corresponding properties"}, {"st": 139, "ed": 141, "text": "Kripke model"}, {"st": 147, "ed": 149, "text": "dynamic logic"}, {"st": 153, "ed": 155, "text": "Milner type"}]
[{"st": 1, "ed": 3, "text": "Refined Calculus"}, {"st": 4, "ed": 6, "text": "Inductive Construction"}]
[{"st": 8, "ed": 10, "text": "Inductive Constructions"}, {"st": 19, "ed": 21, "text": "relational parametricity"}, {"st": 25, "ed": 27, "text": "new way"}, {"st": 32, "ed": 35, "text": "interactive theorem prover"}]
[{"st": 0, "ed": 3, "text": "Average Case Analysis"}, {"st": 5, "ed": 7, "text": "Classical Algorithm"}, {"st": 8, "ed": 10, "text": "Markov Decision"}, {"st": 12, "ed": 14, "text": "Buchi Objectives"}]
[{"st": 2, "ed": 5, "text": "Markov decision processes"}, {"st": 10, "ed": 12, "text": "\\omega$-regular specifications"}, {"st": 14, "ed": 16, "text": "parity objectives"}, {"st": 51, "ed": 54, "text": "sure winning set"}, {"st": 55, "ed": 57, "text": "parity objectives"}, {"st": 65, "ed": 68, "text": "sure winning set"}, {"st": 69, "ed": 71, "text": "B\\\"uchi objectives"}, {"st": 73, "ed": 75, "text": "special case"}, {"st": 76, "ed": 78, "text": "parity objectives"}, {"st": 84, "ed": 86, "text": "first time"}, {"st": 87, "ed": 90, "text": "average case complexity"}, {"st": 92, "ed": 94, "text": "classical algorithm"}, {"st": 104, "ed": 106, "text": "B\\\"uchi objectives"}, {"st": 126, "ed": 128, "text": "expected number"}, {"st": 136, "ed": 138, "text": "average case"}, {"st": 148, "ed": 151, "text": "case linear number"}, {"st": 154, "ed": 157, "text": "quadratic time complexity"}, {"st": 165, "ed": 167, "text": "general MDPs"}, {"st": 168, "ed": 170, "text": "expected number"}, {"st": 176, "ed": 178, "text": "average case"}, {"st": 189, "ed": 192, "text": "case linear number"}, {"st": 195, "ed": 198, "text": "quadratic time complexity"}, {"st": 216, "ed": 218, "text": "classical algorithm"}, {"st": 221, "ed": 223, "text": "constant number"}]
[{"st": 0, "ed": 3, "text": "Exponential Lower Bounds"}, {"st": 6, "ed": 8, "text": "Query Rewriting"}]
[{"st": 11, "ed": 14, "text": "monotone Boolean functions"}, {"st": 22, "ed": 25, "text": "nonrecursive Datalog rewritings"}, {"st": 26, "ed": 28, "text": "conjunctive queries"}, {"st": 31, "ed": 33, "text": "QL ontologies"}, {"st": 40, "ed": 42, "text": "separation results"}, {"st": 43, "ed": 45, "text": "circuit complexity"}, {"st": 47, "ed": 49, "text": "similar results"}, {"st": 60, "ed": 62, "text": "signature constants"}, {"st": 75, "ed": 77, "text": "positive existential"}, {"st": 78, "ed": 81, "text": "nonrecursive Datalog rewritings"}, {"st": 86, "ed": 88, "text": "original queries"}, {"st": 89, "ed": 92, "text": "nonrecursive Datalog rewritings"}, {"st": 99, "ed": 102, "text": "positive existential rewritings"}, {"st": 106, "ed": 108, "text": "order rewritings"}, {"st": 114, "ed": 117, "text": "positive existential rewritings"}]
[{"st": 1, "ed": 3, "text": "Categorical Model"}, {"st": 5, "ed": 7, "text": "Lambda Calculus"}]
[{"st": 1, "ed": 3, "text": "lambda calculus"}, {"st": 10, "ed": 12, "text": "lambda calculus"}, {"st": 13, "ed": 15, "text": "variadic constructors"}, {"st": 23, "ed": 25, "text": "la ML"}, {"st": 27, "ed": 29, "text": "case analysis"}, {"st": 33, "ed": 35, "text": "commutation rule"}, {"st": 38, "ed": 40, "text": "application constructs"}, {"st": 43, "ed": 45, "text": "commutation rule"}, {"st": 50, "ed": 53, "text": "usual computing intuitions"}, {"st": 65, "ed": 67, "text": "simple syntax"}, {"st": 74, "ed": 76, "text": "sound notion"}, {"st": 77, "ed": 79, "text": "categorical model"}, {"st": 81, "ed": 83, "text": "lambda calculus"}, {"st": 110, "ed": 113, "text": "partial equivalence relations"}]
[{"st": 1, "ed": 3, "text": "General Form"}, {"st": 4, "ed": 6, "text": "Attribute Exploration"}]
[{"st": 3, "ed": 5, "text": "general form"}, {"st": 6, "ed": 8, "text": "attribute exploration"}, {"st": 10, "ed": 13, "text": "knowledge completion algorithm"}, {"st": 14, "ed": 17, "text": "Formal Concept Analysis"}, {"st": 31, "ed": 33, "text": "attribute exploration"}, {"st": 35, "ed": 37, "text": "general description"}, {"st": 48, "ed": 50, "text": "attribute exploration"}, {"st": 54, "ed": 56, "text": "general form"}, {"st": 60, "ed": 62, "text": "theoretical considerations"}]
[{"st": 2, "ed": 4, "text": "Linear Programs"}, {"st": 5, "ed": 7, "text": "Nonlinear Constraints"}]
[{"st": 5, "ed": 7, "text": "linear programs"}, {"st": 10, "ed": 13, "text": "linear loop conditions"}, {"st": 22, "ed": 24, "text": "Jordan forms"}, {"st": 25, "ed": 27, "text": "eigenvectors computation"}, {"st": 50, "ed": 53, "text": "polynomial loop conditions"}, {"st": 54, "ed": 56, "text": "linear updates"}, {"st": 70, "ed": 72, "text": "such loops"}, {"st": 87, "ed": 89, "text": "complete algorithm"}, {"st": 97, "ed": 99, "text": "such programs"}, {"st": 115, "ed": 117, "text": "different techniques"}, {"st": 126, "ed": 128, "text": "linear programs"}, {"st": 129, "ed": 132, "text": "polynomial loop conditions"}, {"st": 150, "ed": 152, "text": "decision problem"}, {"st": 154, "ed": 156, "text": "number theory"}, {"st": 157, "ed": 159, "text": "ergodic theory"}]
[{"st": 1, "ed": 4, "text": "Machine Checked Model"}, {"st": 5, "ed": 8, "text": "Idempotent MGU Axioms"}, {"st": 11, "ed": 13, "text": "Equational Constraints"}]
[{"st": 9, "ed": 12, "text": "order unification algorithm"}, {"st": 16, "ed": 18, "text": "satisfiable constraints"}, {"st": 21, "ed": 23, "text": "general unifier"}, {"st": 43, "ed": 46, "text": "Coq theorem prover"}, {"st": 48, "ed": 50, "text": "proofs show"}, {"st": 51, "ed": 53, "text": "finite maps"}, {"st": 65, "ed": 67, "text": "idempotent MGUs"}, {"st": 108, "ed": 110, "text": "simple types"}, {"st": 116, "ed": 118, "text": "finite maps"}, {"st": 120, "ed": 123, "text": "Coq library Coq"}, {"st": 132, "ed": 134, "text": "functional induction"}, {"st": 136, "ed": 139, "text": "main proof technique"}]
[{"st": 0, "ed": 2, "text": "Recursive Definitions"}, {"st": 3, "ed": 5, "text": "Monadic Functions"}]
[{"st": 1, "ed": 3, "text": "standard domain"}, {"st": 15, "ed": 17, "text": "recursive functions"}, {"st": 21, "ed": 23, "text": "monadic style"}, {"st": 30, "ed": 33, "text": "simple option monad"}, {"st": 37, "ed": 39, "text": "exception monad"}, {"st": 40, "ed": 43, "text": "Isabelle / HOL"}, {"st": 44, "ed": 47, "text": "imperative programming extension"}, {"st": 52, "ed": 55, "text": "convenient definition principle"}, {"st": 56, "ed": 58, "text": "imperative programs"}, {"st": 67, "ed": 70, "text": "such monadic functions"}, {"st": 72, "ed": 74, "text": "recursion equation"}, {"st": 96, "ed": 99, "text": "convenient induction principles"}]
[{"st": 7, "ed": 9, "text": "Proof System"}]
[{"st": 0, "ed": 2, "text": "Term rewriting"}, {"st": 4, "ed": 6, "text": "significant presence"}, {"st": 7, "ed": 9, "text": "various areas"}, {"st": 13, "ed": 15, "text": "automated theorem"}, {"st": 22, "ed": 24, "text": "proof technique"}, {"st": 25, "ed": 28, "text": "Many theorem provers"}, {"st": 30, "ed": 32, "text": "proof tactics"}, {"st": 56, "ed": 59, "text": "supports partial functions"}, {"st": 70, "ed": 72, "text": "defined terms"}, {"st": 86, "ed": 89, "text": "deductive proof system"}, {"st": 106, "ed": 108, "text": "theoretical foundations"}, {"st": 121, "ed": 125, "text": "set theoretical formalism Event"}]
[{"st": 0, "ed": 2, "text": "General Recursion"}, {"st": 3, "ed": 5, "text": "Formal Topology"}]
[{"st": 5, "ed": 7, "text": "general recursion"}, {"st": 16, "ed": 18, "text": "type theory"}, {"st": 19, "ed": 21, "text": "various approaches"}, {"st": 37, "ed": 39, "text": "typable terms"}, {"st": 46, "ed": 48, "text": "new approach"}, {"st": 58, "ed": 60, "text": "formal topologies"}]
[{"st": 1, "ed": 3, "text": "Buchi Automata"}, {"st": 6, "ed": 8, "text": "Data Values"}]
[{"st": 1, "ed": 3, "text": "data trees"}, {"st": 4, "ed": 6, "text": "data words"}, {"st": 8, "ed": 10, "text": "considerable amount"}, {"st": 18, "ed": 20, "text": "system verification"}, {"st": 34, "ed": 36, "text": "finite alphabet"}, {"st": 38, "ed": 40, "text": "data values"}, {"st": 42, "ed": 44, "text": "infinite alphabet"}, {"st": 58, "ed": 60, "text": "data words"}, {"st": 70, "ed": 72, "text": "reasonable complexity"}, {"st": 74, "ed": 76, "text": "satisfiability problem"}, {"st": 87, "ed": 89, "text": "B\\\"uchi automata"}, {"st": 100, "ed": 102, "text": "emptiness problem"}, {"st": 103, "ed": 105, "text": "such extension"}, {"st": 108, "ed": 110, "text": "elementary complexity"}, {"st": 135, "ed": 137, "text": "variable fragment"}, {"st": 140, "ed": 142, "text": "order logic"}, {"st": 146, "ed": 150, "text": "classical linear temporal logic"}]
[{"st": 3, "ed": 6, "text": "natural deduction proofs"}]
[{"st": 1, "ed": 3, "text": "formal proof"}, {"st": 15, "ed": 17, "text": "mathematical formulas"}, {"st": 29, "ed": 31, "text": "accepted formalizations"}, {"st": 40, "ed": 42, "text": "witness validity"}, {"st": 47, "ed": 49, "text": "computer programs"}, {"st": 50, "ed": 53, "text": "such proof scripts"}, {"st": 71, "ed": 73, "text": "formal proofs"}, {"st": 91, "ed": 93, "text": "proof readability"}, {"st": 97, "ed": 99, "text": "First Law"}, {"st": 100, "ed": 102, "text": "sentence structure"}, {"st": 109, "ed": 111, "text": "local references"}, {"st": 118, "ed": 120, "text": "proof linearisation"}, {"st": 126, "ed": 128, "text": "optimization method"}]
[{"st": 2, "ed": 4, "text": "Probabilistic Components"}]
[{"st": 3, "ed": 5, "text": "automatic construction"}, {"st": 13, "ed": 16, "text": "classical synthesis algorithms"}, {"st": 28, "ed": 30, "text": "scratch \""}, {"st": 34, "ed": 36, "text": "reusable components"}, {"st": 45, "ed": 47, "text": "real life"}, {"st": 53, "ed": 57, "text": "trivial commercial software system"}, {"st": 63, "ed": 65, "text": "reusable components"}, {"st": 68, "ed": 70, "text": "other contexts"}, {"st": 75, "ed": 77, "text": "service orchestration"}, {"st": 102, "ed": 104, "text": "flow synthesis"}, {"st": 107, "ed": 109, "text": "reusable components"}, {"st": 113, "ed": 115, "text": "dataflow synthesis"}, {"st": 121, "ed": 123, "text": "flow synthesis"}, {"st": 137, "ed": 139, "text": "flow synthesis"}, {"st": 142, "ed": 144, "text": "probabilistic components"}, {"st": 150, "ed": 152, "text": "general problem"}]
[{"st": 8, "ed": 10, "text": "Logic Programs"}, {"st": 11, "ed": 13, "text": "Function Symbols"}]
[{"st": 18, "ed": 20, "text": "logic programs"}, {"st": 21, "ed": 23, "text": "complex terms"}, {"st": 27, "ed": 29, "text": "function symbols"}, {"st": 35, "ed": 38, "text": "ground instantiation infinite"}, {"st": 47, "ed": 49, "text": "evaluation procedure"}, {"st": 52, "ed": 54, "text": "general case"}, {"st": 62, "ed": 65, "text": "program termination problem"}, {"st": 69, "ed": 71, "text": "general case"}, {"st": 72, "ed": 75, "text": "several decidable criteria"}, {"st": 77, "ed": 80, "text": "program termination criteria"}, {"st": 88, "ed": 90, "text": "current conditions"}, {"st": 96, "ed": 98, "text": "simple programs"}, {"st": 110, "ed": 113, "text": "new decidable criteria"}, {"st": 117, "ed": 119, "text": "logic programs"}, {"st": 120, "ed": 122, "text": "function symbols"}, {"st": 132, "ed": 134, "text": "program structure"}, {"st": 142, "ed": 144, "text": "complex terms"}, {"st": 150, "ed": 152, "text": "extended version"}, {"st": 154, "ed": 156, "text": "argument graph"}, {"st": 157, "ed": 159, "text": "propagation graph"}, {"st": 173, "ed": 175, "text": "decidable criteria"}, {"st": 193, "ed": 195, "text": "powerful criterion"}, {"st": 206, "ed": 208, "text": "safety function"}, {"st": 247, "ed": 249, "text": "safety criterion"}, {"st": 255, "ed": 257, "text": "relevant classes"}, {"st": 260, "ed": 262, "text": "bound queries"}, {"st": 284, "ed": 286, "text": "safe class"}, {"st": 290, "ed": 292, "text": "k-1)-safe class"}, {"st": 302, "ed": 304, "text": "Logic Programming"}]
[{"st": 2, "ed": 4, "text": "Global Constraints"}, {"st": 5, "ed": 8, "text": "Answer Set Programming"}]
[{"st": 3, "ed": 5, "text": "global constraints"}, {"st": 6, "ed": 8, "text": "finite domains"}, {"st": 27, "ed": 29, "text": "range consistency"}, {"st": 36, "ed": 38, "text": "other advantages"}, {"st": 43, "ed": 45, "text": "global propagators"}, {"st": 47, "ed": 49, "text": "set programming"}, {"st": 55, "ed": 57, "text": "other constraints"}, {"st": 69, "ed": 71, "text": "Such sharing"}]
[{"st": 0, "ed": 3, "text": "Propositional Logics Complexity"}, {"st": 7, "ed": 9, "text": "Formula Property"}]
[{"st": 2, "ed": 4, "text": "Richard Statman"}, {"st": 14, "ed": 16, "text": "implicational fragment"}, {"st": 17, "ed": 19, "text": "Intuitionistic Logic"}, {"st": 36, "ed": 40, "text": "full Intuitionistic Propositional Logic"}, {"st": 42, "ed": 44, "text": "implicational fragment"}, {"st": 59, "ed": 61, "text": "Goedel translation"}, {"st": 64, "ed": 66, "text": "Intuitionistic Logic"}, {"st": 68, "ed": 70, "text": "PSPACE- completeness"}, {"st": 80, "ed": 82, "text": "formula principle"}, {"st": 84, "ed": 86, "text": "deductive system"}, {"st": 88, "ed": 91, "text": "logic L states"}, {"st": 106, "ed": 108, "text": "formula occurrence"}, {"st": 127, "ed": 129, "text": "Statman result"}, {"st": 142, "ed": 144, "text": "particular formulation"}, {"st": 148, "ed": 150, "text": "formula principle"}, {"st": 161, "ed": 163, "text": "implicational logic"}, {"st": 176, "ed": 179, "text": "complete propositional logics"}, {"st": 187, "ed": 190, "text": "knowledge epistemic logic"}, {"st": 197, "ed": 199, "text": "particular sub"}, {"st": 200, "ed": 202, "text": "formula principle"}, {"st": 208, "ed": 211, "text": "PSPACE = EXPTIME"}]
[{"st": 1, "ed": 3, "text": "Equivalent Presentation"}, {"st": 9, "ed": 11, "text": "Huber Category"}, {"st": 12, "ed": 14, "text": "Cubical Sets"}]
[{"st": 19, "ed": 21, "text": "finite sets"}, {"st": 22, "ed": 24, "text": "partial bijections"}, {"st": 28, "ed": 31, "text": "nominal restriction sets"}, {"st": 56, "ed": 58, "text": "cubical sets"}, {"st": 67, "ed": 69, "text": "nominal sets"}, {"st": 72, "ed": 76, "text": "\" 01-substitution \" operation"}, {"st": 89, "ed": 91, "text": "01-substitution sets"}, {"st": 93, "ed": 95, "text": "cubical sets"}, {"st": 115, "ed": 118, "text": "intended univalent model"}, {"st": 119, "ed": 123, "text": "intentional constructive type theory"}]
[{"st": 1, "ed": 4, "text": "Hybrid Linear Logic"}, {"st": 5, "ed": 8, "text": "Constrained Transition Systems"}]
[{"st": 0, "ed": 2, "text": "Linear implication"}, {"st": 4, "ed": 6, "text": "state transitions"}, {"st": 8, "ed": 11, "text": "real transition systems"}, {"st": 17, "ed": 19, "text": "probabilistic constraints"}, {"st": 25, "ed": 28, "text": "ordinary linear logic"}, {"st": 32, "ed": 35, "text": "general modal extension"}, {"st": 36, "ed": 39, "text": "intuitionistic linear logic"}, {"st": 40, "ed": 42, "text": "logical truth"}, {"st": 47, "ed": 49, "text": "hybrid connectives"}, {"st": 53, "ed": 55, "text": "logical reasoning"}, {"st": 63, "ed": 66, "text": "free sequent calculus"}, {"st": 75, "ed": 79, "text": "particular constrained transition systems"}, {"st": 85, "ed": 87, "text": "adequate encoding"}, {"st": 89, "ed": 92, "text": "synchronous stochastic pi"}]
[{"st": 2, "ed": 5, "text": "Recursive Probabilistic Programs"}]
[{"st": 6, "ed": 8, "text": "style calculus"}, {"st": 19, "ed": 21, "text": "probabilistic programs"}, {"st": 24, "ed": 27, "text": "several proof rules"}, {"st": 36, "ed": 38, "text": "such expectations"}, {"st": 52, "ed": 56, "text": "probabilistic pushdown automaton semantics"}, {"st": 63, "ed": 65, "text": "style calculus"}, {"st": 70, "ed": 72, "text": "expected runtime"}, {"st": 73, "ed": 75, "text": "recursive programs"}, {"st": 90, "ed": 92, "text": "such programs"}]
[]
[{"st": 3, "ed": 5, "text": "type system"}, {"st": 14, "ed": 17, "text": "type system accounts"}, {"st": 21, "ed": 23, "text": "algebraic aspects"}, {"st": 37, "ed": 39, "text": "linear combinations"}, {"st": 55, "ed": 58, "text": "original type theory"}, {"st": 63, "ed": 65, "text": "same way"}, {"st": 72, "ed": 74, "text": "linear combinations"}, {"st": 88, "ed": 91, "text": "weak subject reduction"}, {"st": 105, "ed": 107, "text": "typed calculus"}]
[{"st": 0, "ed": 2, "text": "Coalgebraic Characterizations"}, {"st": 5, "ed": 7, "text": "Free Languages"}]
[{"st": 7, "ed": 9, "text": "coalgebraic characterizations"}, {"st": 15, "ed": 17, "text": "free languages"}, {"st": 25, "ed": 27, "text": "coalgebraic structure"}, {"st": 30, "ed": 32, "text": "algebraic structure"}, {"st": 36, "ed": 38, "text": "derivative pairs"}, {"st": 39, "ed": 42, "text": "Final coalgebra semantics"}, {"st": 45, "ed": 47, "text": "interpretation function"}, {"st": 49, "ed": 51, "text": "final coalgebra"}, {"st": 56, "ed": 58, "text": "usual output"}, {"st": 59, "ed": 61, "text": "derivative operations"}, {"st": 63, "ed": 65, "text": "first characterization"}, {"st": 77, "ed": 79, "text": "finite language"}, {"st": 86, "ed": 88, "text": "second characterization"}, {"st": 104, "ed": 106, "text": "third characterization"}, {"st": 110, "ed": 112, "text": "coalgebraic structure"}, {"st": 121, "ed": 123, "text": "point expressions"}, {"st": 137, "ed": 140, "text": "formal power series"}, {"st": 148, "ed": 151, "text": "generalized powerset construction"}]
[{"st": 2, "ed": 4, "text": "Pattern Recognition"}, {"st": 5, "ed": 7, "text": "Lemma Discovery"}]
[{"st": 3, "ed": 5, "text": "novel technique"}, {"st": 7, "ed": 9, "text": "statistical machine"}, {"st": 13, "ed": 15, "text": "pattern recognition"}, {"st": 16, "ed": 18, "text": "symbolic methods"}, {"st": 19, "ed": 21, "text": "lemma discovery"}, {"st": 34, "ed": 36, "text": "statistical pattern"}, {"st": 49, "ed": 51, "text": "auxiliary lemmas"}, {"st": 52, "ed": 54, "text": "new proofs"}, {"st": 70, "ed": 72, "text": "theoretical descriptions"}, {"st": 76, "ed": 78, "text": "pattern recognition"}, {"st": 79, "ed": 82, "text": "lemma discovery methods"}]
[{"st": 3, "ed": 5, "text": "Abstract Algorithm"}, {"st": 6, "ed": 10, "text": "Translating Hierarchical Block Diagrams"}]
[{"st": 6, "ed": 8, "text": "nondeterministic algorithm"}, {"st": 10, "ed": 13, "text": "hierarchical block diagrams"}, {"st": 18, "ed": 20, "text": "abstract algebra"}, {"st": 24, "ed": 27, "text": "basic composition operations"}, {"st": 53, "ed": 55, "text": "internal nondeterminism"}, {"st": 67, "ed": 70, "text": "possible algebra expressions"}, {"st": 83, "ed": 85, "text": "different determinizations"}, {"st": 87, "ed": 89, "text": "algorithm result"}, {"st": 90, "ed": 93, "text": "different translation strategies"}, {"st": 109, "ed": 111, "text": "various criteria"}, {"st": 133, "ed": 135, "text": "translation strategies"}, {"st": 139, "ed": 141, "text": "previous work"}, {"st": 148, "ed": 150, "text": "abstract algorithm"}, {"st": 161, "ed": 163, "text": "open question"}]
[{"st": 3, "ed": 5, "text": "Variable Logic"}]
[{"st": 1, "ed": 4, "text": "finite satisfiability problem"}, {"st": 8, "ed": 10, "text": "variable fragment"}, {"st": 13, "ed": 15, "text": "order logic"}, {"st": 40, "ed": 43, "text": "additional binary symbols"}, {"st": 56, "ed": 59, "text": "finite satisfiability problem"}, {"st": 69, "ed": 71, "text": "binary symbols"}, {"st": 86, "ed": 88, "text": "expressive power"}, {"st": 92, "ed": 94, "text": "variable fragment"}, {"st": 119, "ed": 121, "text": "expressive power"}, {"st": 123, "ed": 125, "text": "restricted case"}, {"st": 126, "ed": 128, "text": "unordered trees"}]
[{"st": 3, "ed": 5, "text": "behavioral equivalences"}, {"st": 10, "ed": 12, "text": "noisy channels"}]
[{"st": 5, "ed": 7, "text": "process algebra"}, {"st": 12, "ed": 14, "text": "communication links"}, {"st": 18, "ed": 21, "text": "noiseless communication channels"}, {"st": 28, "ed": 30, "text": "noisy channels"}, {"st": 55, "ed": 58, "text": "early transitional semantics"}, {"st": 72, "ed": 74, "text": "late semantics"}, {"st": 84, "ed": 86, "text": "behavioral equivalences"}, {"st": 88, "ed": 90, "text": "reduction bisimilarity"}, {"st": 103, "ed": 105, "text": "full bisimilarity"}, {"st": 110, "ed": 113, "text": "Such behavioral equivalences"}, {"st": 124, "ed": 126, "text": "behavioral equivalence"}, {"st": 139, "ed": 141, "text": "noisy nature"}, {"st": 158, "ed": 160, "text": "full bisimilarity"}]
[{"st": 1, "ed": 3, "text": "Characterising Distributability"}]
[{"st": 3, "ed": 5, "text": "general concept"}, {"st": 6, "ed": 8, "text": "distributed systems"}, {"st": 9, "ed": 11, "text": "sequential components"}, {"st": 17, "ed": 19, "text": "corresponding class"}, {"st": 20, "ed": 22, "text": "Petri nets"}, {"st": 24, "ed": 26, "text": "LSGA nets"}, {"st": 31, "ed": 33, "text": "system specifications"}, {"st": 47, "ed": 49, "text": "explicit divergence"}]
[]
[{"st": 4, "ed": 8, "text": "new logic RoCTL *"}, {"st": 12, "ed": 14, "text": "concurrent systems"}, {"st": 15, "ed": 17, "text": "RoCTL *"}, {"st": 18, "ed": 20, "text": "CTL *"}, {"st": 26, "ed": 28, "text": "Robustly operators"}, {"st": 34, "ed": 36, "text": "free paths"}, {"st": 54, "ed": 56, "text": "RoCTL *"}, {"st": 61, "ed": 63, "text": "core result"}, {"st": 70, "ed": 72, "text": "RoCTL *"}, {"st": 76, "ed": 78, "text": "CTL *"}, {"st": 91, "ed": 93, "text": "RoCTL *"}, {"st": 94, "ed": 96, "text": "CTL *"}, {"st": 105, "ed": 107, "text": "elementary growth"}, {"st": 112, "ed": 114, "text": "translated formula"}, {"st": 123, "ed": 126, "text": "extra exponential blowup"}, {"st": 147, "ed": 150, "text": "extra exponential growth"}, {"st": 157, "ed": 159, "text": "RoCTL *"}, {"st": 160, "ed": 163, "text": "Quantified CTL *"}, {"st": 164, "ed": 166, "text": "QCTL *"}, {"st": 168, "ed": 170, "text": "hybrid logics"}]
[{"st": 1, "ed": 3, "text": "abstract normalisation"}]
[{"st": 4, "ed": 6, "text": "multistep strategies"}, {"st": 23, "ed": 25, "text": "necessary sets"}, {"st": 43, "ed": 45, "text": "normal form"}, {"st": 56, "ed": 59, "text": "sequential rewrite systems"}, {"st": 67, "ed": 69, "text": "normal form"}, {"st": 80, "ed": 82, "text": "normalisation theorem"}, {"st": 83, "ed": 86, "text": "abstract rewrite systems"}, {"st": 91, "ed": 94, "text": "general rewriting framework"}, {"st": 105, "ed": 107, "text": "PhD thesis"}, {"st": 112, "ed": 114, "text": "multistep strategies"}, {"st": 138, "ed": 140, "text": "abstract property"}, {"st": 146, "ed": 148, "text": "order substitution"}, {"st": 156, "ed": 158, "text": "particular case"}]
[{"st": 1, "ed": 3, "text": "Intuitionistic Set"}, {"st": 4, "ed": 6, "text": "theoretical Model"}, {"st": 8, "ed": 10, "text": "Extended Calculus"}]
[{"st": 4, "ed": 6, "text": "theoretical model"}, {"st": 11, "ed": 13, "text": "intuitive models"}, {"st": 19, "ed": 21, "text": "functional view"}, {"st": 22, "ed": 24, "text": "predicative universes"}, {"st": 26, "ed": 28, "text": "collapsed view"}, {"st": 30, "ed": 33, "text": "impredicative sort Prop"}, {"st": 46, "ed": 48, "text": "excluded middle"}, {"st": 59, "ed": 61, "text": "topological space"}, {"st": 63, "ed": 65, "text": "special case"}, {"st": 66, "ed": 68, "text": "Heyting algebra"}]
[{"st": 3, "ed": 5, "text": "Order Formulation"}]
[{"st": 3, "ed": 5, "text": "termination /"}, {"st": 7, "ed": 9, "text": "termination property"}, {"st": 15, "ed": 17, "text": "Such loops"}, {"st": 19, "ed": 21, "text": "used abstractions"}, {"st": 22, "ed": 25, "text": "real program pieces"}, {"st": 28, "ed": 30, "text": "order logic"}, {"st": 32, "ed": 34, "text": "convenient language"}, {"st": 43, "ed": 45, "text": "such property"}, {"st": 57, "ed": 59, "text": "decidable cases"}, {"st": 62, "ed": 64, "text": "new classes"}]
[{"st": 1, "ed": 3, "text": "Logical Study"}, {"st": 5, "ed": 7, "text": "Common Principles"}, {"st": 8, "ed": 10, "text": "Inductive Definition"}, {"st": 14, "ed": 16, "text": "Knowledge Representation"}]
[{"st": 4, "ed": 6, "text": "common form"}, {"st": 7, "ed": 10, "text": "human expert knowledge"}, {"st": 12, "ed": 14, "text": "building block"}, {"st": 15, "ed": 17, "text": "formal science"}, {"st": 23, "ed": 25, "text": "database theory"}, {"st": 29, "ed": 31, "text": "various forms"}, {"st": 32, "ed": 35, "text": "many knowledge representation"}, {"st": 36, "ed": 39, "text": "formal specification languages"}, {"st": 46, "ed": 48, "text": "formal study"}, {"st": 53, "ed": 55, "text": "common forms"}, {"st": 56, "ed": 58, "text": "inductive definitions"}, {"st": 60, "ed": 62, "text": "scientific text"}, {"st": 63, "ed": 66, "text": "monotone inductive definition"}, {"st": 77, "ed": 80, "text": "iterated inductive definitions"}, {"st": 89, "ed": 92, "text": "uniform formal syntax"}, {"st": 97, "ed": 99, "text": "different sorts"}, {"st": 107, "ed": 109, "text": "faithful formalization"}, {"st": 111, "ed": 113, "text": "induction process"}, {"st": 114, "ed": 117, "text": "Several fundamental properties"}, {"st": 120, "ed": 122, "text": "induction emerge"}, {"st": 129, "ed": 131, "text": "induction process"}, {"st": 135, "ed": 137, "text": "induction processes"}, {"st": 142, "ed": 144, "text": "induction order"}, {"st": 149, "ed": 151, "text": "inductive rules"}, {"st": 154, "ed": 156, "text": "induction order"}, {"st": 158, "ed": 160, "text": "induction process"}, {"st": 166, "ed": 168, "text": "induction order"}, {"st": 172, "ed": 174, "text": "defined set"}, {"st": 179, "ed": 181, "text": "induction order"}, {"st": 185, "ed": 188, "text": "inductive construction capable"}, {"st": 196, "ed": 198, "text": "induction order"}, {"st": 201, "ed": 203, "text": "borderline definitions"}, {"st": 209, "ed": 211, "text": "definitional paradoxes"}]
[{"st": 0, "ed": 2, "text": "Relational Convolution"}, {"st": 6, "ed": 8, "text": "Incidence Algebras"}]
[{"st": 3, "ed": 5, "text": "ubiquitous operation"}, {"st": 11, "ed": 13, "text": "Kripke semantics"}, {"st": 16, "ed": 18, "text": "interval logics"}, {"st": 28, "ed": 30, "text": "ternary relations"}, {"st": 32, "ed": 34, "text": "resulting notion"}, {"st": 35, "ed": 37, "text": "relational convolution"}, {"st": 42, "ed": 45, "text": "unary modal operators"}, {"st": 48, "ed": 50, "text": "quantitative models"}, {"st": 54, "ed": 56, "text": "conventional variants"}, {"st": 58, "ed": 60, "text": "ternary relations"}, {"st": 64, "ed": 66, "text": "partial semigroups"}, {"st": 88, "ed": 90, "text": "qualitative applications"}, {"st": 91, "ed": 93, "text": "Quantitative examples"}, {"st": 98, "ed": 100, "text": "mean values"}, {"st": 102, "ed": 104, "text": "duration calculus"}]
[{"st": 0, "ed": 2, "text": "Towards M"}, {"st": 3, "ed": 5, "text": "Adhesive Categories"}, {"st": 6, "ed": 8, "text": "Corecursive Graphs"}]
[{"st": 5, "ed": 7, "text": "several extensions"}, {"st": 31, "ed": 33, "text": "nested nodes"}, {"st": 47, "ed": 49, "text": "coalgebraic constructions"}, {"st": 55, "ed": 57, "text": "corecursive graphs"}, {"st": 72, "ed": 74, "text": "\\mathcal{M}$-adhesive categories"}, {"st": 77, "ed": 79, "text": "basic categories"}, {"st": 81, "ed": 84, "text": "\\mathcal{M}$-adhesive transformation systems"}, {"st": 96, "ed": 98, "text": "\\mathcal{M}$-adhesive categories"}, {"st": 102, "ed": 105, "text": "F:\\mathbf{Sets}_F \\to \\mathbf{Sets}_F$"}]
[{"st": 6, "ed": 8, "text": "Formal analysis"}, {"st": 12, "ed": 14, "text": "\" programs"}]
[{"st": 5, "ed": 7, "text": "software manufacturer"}, {"st": 23, "ed": 25, "text": "main objectives"}, {"st": 39, "ed": 41, "text": "technological reasons"}, {"st": 44, "ed": 46, "text": "manufacturer become"}, {"st": 54, "ed": 56, "text": "main objective"}, {"st": 57, "ed": 59, "text": "dubious reasons"}, {"st": 69, "ed": 72, "text": "\\mathrm{NO}_x$ emission scandals"}, {"st": 73, "ed": 75, "text": "automotive industry"}, {"st": 82, "ed": 84, "text": "software doping"}, {"st": 99, "ed": 101, "text": "daily use"}, {"st": 103, "ed": 105, "text": "primary contribution"}, {"st": 116, "ed": 119, "text": "solid formal definitions"}, {"st": 140, "ed": 142, "text": "immediate framework"}, {"st": 148, "ed": 150, "text": "verification techniques"}, {"st": 160, "ed": 162, "text": "sequential programs"}, {"st": 163, "ed": 165, "text": "model checking"}, {"st": 166, "ed": 168, "text": "HyperLTL formulas"}, {"st": 169, "ed": 171, "text": "reactive models"}]
[{"st": 2, "ed": 4, "text": "theoretic Model"}]
[{"st": 1, "ed": 3, "text": "present paper"}, {"st": 5, "ed": 7, "text": "intrinsic notion"}, {"st": 15, "ed": 17, "text": "game semantics"}, {"st": 24, "ed": 26, "text": "game semantics"}, {"st": 37, "ed": 40, "text": "extrinsic sense \""}, {"st": 47, "ed": 50, "text": "partial recursive functions"}, {"st": 59, "ed": 61, "text": "game semantics"}, {"st": 63, "ed": 65, "text": "autonomous foundation"}, {"st": 76, "ed": 78, "text": "general notion"}, {"st": 86, "ed": 88, "text": "effective strategies"}, {"st": 93, "ed": 95, "text": "mathematical model"}, {"st": 99, "ed": 101, "text": "same sense"}, {"st": 108, "ed": 110, "text": "natural numbers"}, {"st": 131, "ed": 134, "text": "programming language PCF"}, {"st": 140, "ed": 143, "text": "particular Turing complete"}, {"st": 146, "ed": 148, "text": "effective strategies"}, {"st": 150, "ed": 152, "text": "natural notion"}, {"st": 173, "ed": 176, "text": "partial recursive functions"}, {"st": 187, "ed": 189, "text": "combinatory logic"}, {"st": 218, "ed": 221, "text": "\" classical ones"}, {"st": 224, "ed": 226, "text": "fundamental level"}, {"st": 231, "ed": 233, "text": "game semantics"}, {"st": 237, "ed": 239, "text": "theoretic model"}, {"st": 246, "ed": 248, "text": "mathematical foundation"}]
[{"st": 0, "ed": 2, "text": "Local Redundancy"}, {"st": 7, "ed": 9, "text": "Blocked Clauses"}]
[{"st": 2, "ed": 4, "text": "elimination procedures"}, {"st": 8, "ed": 11, "text": "conjunctive normal form"}, {"st": 13, "ed": 15, "text": "important role"}, {"st": 16, "ed": 19, "text": "modern SAT solving"}, {"st": 24, "ed": 27, "text": "actual solving process"}, {"st": 28, "ed": 30, "text": "such procedures"}, {"st": 50, "ed": 52, "text": "redundancy properties"}, {"st": 66, "ed": 68, "text": "satisfiability status"}, {"st": 74, "ed": 77, "text": "successful redundancy property"}, {"st": 80, "ed": 82, "text": "blocked clauses"}, {"st": 86, "ed": 90, "text": "several other redundancy properties"}, {"st": 102, "ed": 104, "text": "redundant ---"}, {"st": 110, "ed": 112, "text": "resolution environment"}, {"st": 129, "ed": 131, "text": "redundancy property"}, {"st": 132, "ed": 134, "text": "blocked clauses"}, {"st": 149, "ed": 152, "text": "local redundancy properties"}, {"st": 158, "ed": 160, "text": "blocked clauses"}, {"st": 168, "ed": 170, "text": "semantic notion"}, {"st": 179, "ed": 183, "text": "general local redundancy property"}, {"st": 208, "ed": 211, "text": "semantic blocking notion"}, {"st": 218, "ed": 220, "text": "semantic blocking"}, {"st": 229, "ed": 231, "text": "\" rule"}, {"st": 233, "ed": 235, "text": "atomic formulas"}, {"st": 242, "ed": 245, "text": "detailed complexity analysis"}, {"st": 248, "ed": 251, "text": "novel redundancy properties"}, {"st": 252, "ed": 255, "text": "prominent redundancy properties"}]
[{"st": 4, "ed": 6, "text": "variable logic"}, {"st": 9, "ed": 12, "text": "ordered data values"}]
[{"st": 0, "ed": 2, "text": "Data trees"}, {"st": 15, "ed": 17, "text": "finite alphabet"}, {"st": 21, "ed": 23, "text": "data value"}, {"st": 25, "ed": 27, "text": "infinite domain"}, {"st": 34, "ed": 36, "text": "abstraction model"}, {"st": 56, "ed": 58, "text": "equality test"}, {"st": 63, "ed": 65, "text": "data values"}, {"st": 71, "ed": 73, "text": "data trees"}, {"st": 76, "ed": 78, "text": "data values"}, {"st": 89, "ed": 91, "text": "equality test"}, {"st": 97, "ed": 99, "text": "data value"}, {"st": 114, "ed": 116, "text": "automata model"}, {"st": 123, "ed": 126, "text": "data tree automata"}, {"st": 132, "ed": 134, "text": "logical characterisation"}, {"st": 141, "ed": 143, "text": "emptiness problem"}, {"st": 155, "ed": 157, "text": "variable logic"}, {"st": 158, "ed": 160, "text": "unranked trees"}, {"st": 177, "ed": 179, "text": "special subclass"}, {"st": 181, "ed": 183, "text": "automata model"}, {"st": 197, "ed": 199, "text": "weak ODTA"}, {"st": 203, "ed": 205, "text": "logical characterisation"}, {"st": 212, "ed": 214, "text": "emptiness problem"}, {"st": 236, "ed": 238, "text": "weak ODTA"}, {"st": 257, "ed": 259, "text": "data values"}]
[{"st": 1, "ed": 3, "text": "Unsatisfiable Cores"}, {"st": 6, "ed": 8, "text": "Temporal Resolution"}]
[{"st": 0, "ed": 2, "text": "Unsatisfiable cores"}, {"st": 14, "ed": 16, "text": "declarative setting"}, {"st": 21, "ed": 23, "text": "few tools"}, {"st": 32, "ed": 34, "text": "Existing tools"}, {"st": 39, "ed": 41, "text": "unsatisfiable subset"}, {"st": 47, "ed": 49, "text": "level conjuncts"}, {"st": 51, "ed": 53, "text": "LTL formula"}, {"st": 55, "ed": 57, "text": "resolution graphs"}, {"st": 63, "ed": 65, "text": "other domains"}, {"st": 76, "ed": 78, "text": "resolution graphs"}, {"st": 79, "ed": 81, "text": "temporal resolution"}, {"st": 85, "ed": 87, "text": "temporal resolution"}, {"st": 89, "ed": 91, "text": "solver TRP++"}, {"st": 100, "ed": 102, "text": "propositional LTL"}, {"st": 119, "ed": 121, "text": "UC extraction"}, {"st": 125, "ed": 127, "text": "level conjuncts"}, {"st": 132, "ed": 134, "text": "atomic entities"}, {"st": 140, "ed": 143, "text": "unsatisfiable LTL formula"}, {"st": 147, "ed": 149, "text": "\\phi \\equiv"}, {"st": 158, "ed": 160, "text": "\\bf F"}, {"st": 169, "ed": 171, "text": "UC irrespective"}, {"st": 230, "ed": 232, "text": "experimental evaluation"}, {"st": 248, "ed": 250, "text": "input formula"}, {"st": 252, "ed": 254, "text": "acceptable overhead"}, {"st": 275, "ed": 277, "text": "run time"}, {"st": 278, "ed": 280, "text": "memory usage"}, {"st": 282, "ed": 284, "text": "source code"}]
[{"st": 0, "ed": 5, "text": "Towards Approximate Model Checking DC"}, {"st": 6, "ed": 8, "text": "PDC Specifications"}]
[{"st": 6, "ed": 8, "text": "promising tool"}, {"st": 14, "ed": 16, "text": "functional requirements"}, {"st": 23, "ed": 25, "text": "time systems"}, {"st": 26, "ed": 28, "text": "Many works"}, {"st": 32, "ed": 34, "text": "effective techniques"}, {"st": 42, "ed": 44, "text": "time systems"}, {"st": 45, "ed": 47, "text": "DC specifications"}, {"st": 48, "ed": 50, "text": "DC model"}, {"st": 60, "ed": 62, "text": "available tools"}, {"st": 63, "ed": 65, "text": "practical verifications"}, {"st": 68, "ed": 70, "text": "high undecidability"}, {"st": 74, "ed": 76, "text": "great complexity"}, {"st": 77, "ed": 79, "text": "model checking"}, {"st": 80, "ed": 82, "text": "Present situation"}, {"st": 83, "ed": 86, "text": "PDC model checking"}, {"st": 93, "ed": 95, "text": "DC model"}, {"st": 111, "ed": 113, "text": "approximate model"}, {"st": 118, "ed": 120, "text": "PDC specifications"}, {"st": 127, "ed": 129, "text": "approximate techniques"}, {"st": 130, "ed": 132, "text": "automata models"}, {"st": 136, "ed": 138, "text": "time systems"}, {"st": 141, "ed": 143, "text": "PDC specifications"}, {"st": 145, "ed": 147, "text": "previous works"}, {"st": 151, "ed": 153, "text": "decidable formulas"}, {"st": 158, "ed": 160, "text": "approximate techniques"}, {"st": 161, "ed": 163, "text": "whole DC"}, {"st": 164, "ed": 166, "text": "PDC formulas"}, {"st": 168, "ed": 170, "text": "first results"}, {"st": 176, "ed": 178, "text": "approximate techniques"}, {"st": 181, "ed": 184, "text": "time automata models"}, {"st": 189, "ed": 191, "text": "PLDI specifications"}]
[{"st": 0, "ed": 2, "text": "Interactive verification"}, {"st": 3, "ed": 5, "text": "Markov chains"}, {"st": 8, "ed": 11, "text": "protocol case studies"}]
[{"st": 0, "ed": 3, "text": "Probabilistic model checkers"}, {"st": 7, "ed": 9, "text": "probabilistic systems"}, {"st": 11, "ed": 13, "text": "fixed size"}, {"st": 17, "ed": 19, "text": "desired properties"}, {"st": 21, "ed": 23, "text": "arbitrary size"}, {"st": 24, "ed": 26, "text": "mathematical analysis"}, {"st": 33, "ed": 35, "text": "case studies"}, {"st": 42, "ed": 48, "text": "interactive proof assistant Isabelle / HOL"}, {"st": 50, "ed": 53, "text": "first case study"}, {"st": 55, "ed": 57, "text": "detailed description"}, {"st": 64, "ed": 66, "text": "ZeroConf protocol"}, {"st": 68, "ed": 72, "text": "decentral address allocation protocol"}, {"st": 74, "ed": 77, "text": "second case study"}, {"st": 80, "ed": 82, "text": "involved verification"}, {"st": 83, "ed": 85, "text": "anonymity properties"}, {"st": 87, "ed": 89, "text": "Crowds protocol"}]
[{"st": 0, "ed": 2, "text": "Parameterized Metatheory"}, {"st": 3, "ed": 6, "text": "Continuous Markovian Logic"}]
[{"st": 5, "ed": 8, "text": "classic metalogical framework"}, {"st": 11, "ed": 13, "text": "Boolean operators"}, {"st": 23, "ed": 26, "text": "metric behavioural theory"}, {"st": 27, "ed": 29, "text": "Markov processes"}, {"st": 33, "ed": 35, "text": "intuitionistic frameworks"}, {"st": 40, "ed": 42, "text": "logical implication"}, {"st": 57, "ed": 60, "text": "continuous Markovian logic"}, {"st": 68, "ed": 70, "text": "stochastic bisimulation"}, {"st": 75, "ed": 79, "text": "arbitrary measurable state space"}, {"st": 82, "ed": 84, "text": "time transitions"}, {"st": 91, "ed": 93, "text": "observational error"}, {"st": 99, "ed": 101, "text": "parameterized metatheory"}, {"st": 121, "ed": 123, "text": "complete axiomatization"}, {"st": 130, "ed": 132, "text": "\" metatheorems"}, {"st": 135, "ed": 137, "text": "weak completeness"}, {"st": 138, "ed": 141, "text": "finite model property"}, {"st": 150, "ed": 152, "text": "metalogical concepts"}, {"st": 154, "ed": 156, "text": "different parameters"}, {"st": 166, "ed": 169, "text": "stochastic bisimulation relation"}, {"st": 170, "ed": 173, "text": "various observational preorders"}, {"st": 175, "ed": 177, "text": "behavioural pseudometrics"}, {"st": 179, "ed": 181, "text": "main contribution"}, {"st": 196, "ed": 200, "text": "unified complete Boolean framework"}, {"st": 217, "ed": 220, "text": "propose intuitionistic contexts"}, {"st": 230, "ed": 233, "text": "Boolean logical implication"}]
[{"st": 1, "ed": 3, "text": "generic judgments"}, {"st": 4, "ed": 6, "text": "recursive definitions"}]
[{"st": 0, "ed": 3, "text": "Many semantical aspects"}, {"st": 10, "ed": 12, "text": "operational semantics"}, {"st": 14, "ed": 17, "text": "type assignment calculi"}, {"st": 22, "ed": 25, "text": "appropriate proof systems"}, {"st": 26, "ed": 28, "text": "Recent research"}, {"st": 33, "ed": 35, "text": "theoretic features"}, {"st": 44, "ed": 46, "text": "such descriptions"}, {"st": 50, "ed": 52, "text": "atomic judgments"}, {"st": 53, "ed": 55, "text": "fixed points"}, {"st": 56, "ed": 58, "text": "recursive definitions"}, {"st": 66, "ed": 68, "text": "generic judgments"}, {"st": 97, "ed": 99, "text": "logic properties"}, {"st": 104, "ed": 106, "text": "intrinsic treatment"}, {"st": 114, "ed": 116, "text": "simple integration"}, {"st": 121, "ed": 123, "text": "intuitionistic logic"}, {"st": 127, "ed": 129, "text": "natural numbers"}, {"st": 140, "ed": 142, "text": "pivotal benefit"}, {"st": 149, "ed": 151, "text": "recursive definitions"}, {"st": 157, "ed": 159, "text": "traditional forms"}, {"st": 160, "ed": 162, "text": "atomic judgments"}, {"st": 166, "ed": 168, "text": "generic properties"}, {"st": 170, "ed": 172, "text": "such judgments"}, {"st": 186, "ed": 188, "text": "elegant treatments"}, {"st": 191, "ed": 193, "text": "logic contexts"}, {"st": 210, "ed": 212, "text": "reducibility arguments"}]
[{"st": 0, "ed": 2, "text": "Order effects"}, {"st": 3, "ed": 5, "text": "dynamic semantics"}]
[{"st": 2, "ed": 4, "text": "target article"}, {"st": 9, "ed": 13, "text": "quantum question order model"}, {"st": 15, "ed": 17, "text": "empirical tests"}, {"st": 22, "ed": 24, "text": "precise prediction"}, {"st": 27, "ed": 29, "text": "Cognitive Science"}, {"st": 30, "ed": 35, "text": "] discuss question order effects"}, {"st": 38, "ed": 40, "text": "incompatible projectors"}, {"st": 42, "ed": 44, "text": "Hilbert space"}, {"st": 47, "ed": 49, "text": "similar vein"}, {"st": 54, "ed": 57, "text": "orthoalgebraic query language"}, {"st": 60, "ed": 63, "text": "dynamic update semantics"}, {"st": 71, "ed": 73, "text": "interesting analogies"}, {"st": 75, "ed": 77, "text": "different variants"}, {"st": 78, "ed": 80, "text": "dynamic semantics"}, {"st": 82, "ed": 84, "text": "quantum theory"}, {"st": 86, "ed": 88, "text": "other kinds"}, {"st": 89, "ed": 91, "text": "order effects"}, {"st": 92, "ed": 94, "text": "human cognition"}, {"st": 97, "ed": 99, "text": "belief revision"}, {"st": 106, "ed": 108, "text": "default reasoning"}, {"st": 112, "ed": 114, "text": "crucial non"}, {"st": 117, "ed": 119, "text": "mental operations"}, {"st": 121, "ed": 123, "text": "belief state"}, {"st": 125, "ed": 127, "text": "cognitive agent"}]
[{"st": 1, "ed": 3, "text": "Past LTL"}, {"st": 4, "ed": 7, "text": "Flat Counter Systems"}]
[{"st": 2, "ed": 4, "text": "LTL model"}, {"st": 5, "ed": 7, "text": "checking problems"}, {"st": 8, "ed": 11, "text": "flat counter systems"}, {"st": 19, "ed": 21, "text": "reachability problem"}, {"st": 29, "ed": 33, "text": "known complexity upper bound"}, {"st": 35, "ed": 37, "text": "latter problem"}, {"st": 43, "ed": 45, "text": "several exponentials"}, {"st": 64, "ed": 66, "text": "time operators"}, {"st": 67, "ed": 69, "text": "arithmetical constraints"}, {"st": 75, "ed": 78, "text": "NP upper bound"}, {"st": 84, "ed": 87, "text": "new stuttering theorem"}, {"st": 88, "ed": 90, "text": "Past LTL"}, {"st": 94, "ed": 97, "text": "small integer solutions"}, {"st": 100, "ed": 103, "text": "free Presburger formulae"}, {"st": 104, "ed": 107, "text": "Other complexity results"}, {"st": 113, "ed": 115, "text": "restricted classes"}, {"st": 116, "ed": 119, "text": "flat counter systems"}]
[{"st": 0, "ed": 2, "text": "Disjunctive form"}, {"st": 6, "ed": 9, "text": "m$ alternation hierarchy"}]
[{"st": 1, "ed": 3, "text": "paper studies"}, {"st": 6, "ed": 8, "text": "disjunctive form"}, {"st": 10, "ed": 13, "text": "syntactic normal form"}, {"st": 15, "ed": 18, "text": "modal mu calculus"}, {"st": 21, "ed": 23, "text": "alternation hierarchy"}, {"st": 29, "ed": 31, "text": "disjunctive formulas"}, {"st": 37, "ed": 41, "text": "same syntactic alternation depth"}, {"st": 44, "ed": 46, "text": "tableau equivalence"}, {"st": 48, "ed": 50, "text": "alternation depth"}, {"st": 52, "ed": 54, "text": "disjunctive fragment"}, {"st": 57, "ed": 59, "text": "disjunctive formulas"}, {"st": 61, "ed": 64, "text": "high alternation depth"}, {"st": 74, "ed": 76, "text": "disjunctive formulas"}, {"st": 83, "ed": 85, "text": "disjunctive formulas"}, {"st": 87, "ed": 90, "text": "high alternation depth"}, {"st": 106, "ed": 108, "text": "open question"}, {"st": 110, "ed": 112, "text": "disjunctive form"}, {"st": 113, "ed": 115, "text": "alternation depth"}, {"st": 125, "ed": 127, "text": "undocumented type"}, {"st": 128, "ed": 131, "text": "avoidable syntactic complexity"}, {"st": 141, "ed": 143, "text": "alternation hierarchy"}, {"st": 146, "ed": 148, "text": "open problem"}]
[{"st": 1, "ed": 3, "text": "Arity Hierarchy"}]
[{"st": 1, "ed": 3, "text": "polyadic mu"}, {"st": 7, "ed": 10, "text": "modal fixpoint logic"}, {"st": 11, "ed": 14, "text": "formulas define relations"}, {"st": 21, "ed": 24, "text": "labelled transition systems"}, {"st": 37, "ed": 39, "text": "invariant queries"}, {"st": 40, "ed": 42, "text": "finite graphs"}, {"st": 49, "ed": 51, "text": "hierarchy result"}, {"st": 54, "ed": 56, "text": "expressive power"}, {"st": 58, "ed": 60, "text": "polyadic mu"}, {"st": 67, "ed": 69, "text": "fixpoint alternation"}, {"st": 78, "ed": 80, "text": "expressive power"}, {"st": 85, "ed": 87, "text": "diagonalisation argument"}]
[{"st": 0, "ed": 2, "text": "Weak Completeness"}, {"st": 3, "ed": 6, "text": "Coalgebraic Dynamic Logics"}]
[{"st": 3, "ed": 5, "text": "coalgebraic generalisation"}, {"st": 10, "ed": 13, "text": "Propositional Dynamic Logic"}, {"st": 19, "ed": 21, "text": "Game Logic"}, {"st": 32, "ed": 36, "text": "generic strong completeness result"}, {"st": 37, "ed": 40, "text": "coalgebraic dynamic logics"}, {"st": 44, "ed": 46, "text": "coalgebraic semantics"}, {"st": 47, "ed": 49, "text": "such programs"}, {"st": 53, "ed": 55, "text": "monad T"}, {"st": 62, "ed": 65, "text": "predicate lifting \\^I"}, {"st": 69, "ed": 71, "text": "monad morphism"}, {"st": 75, "ed": 77, "text": "neighbourhood monad"}, {"st": 87, "ed": 89, "text": "monad T"}, {"st": 91, "ed": 94, "text": "complete semilattice structure"}, {"st": 100, "ed": 102, "text": "iteration construct"}, {"st": 104, "ed": 106, "text": "suitable notions"}, {"st": 125, "ed": 127, "text": "axiomatisation parametric"}, {"st": 133, "ed": 135, "text": "chosen set"}, {"st": 136, "ed": 139, "text": "pointwise program operations"}, {"st": 142, "ed": 144, "text": "main result"}, {"st": 150, "ed": 152, "text": "pointwise operations"}, {"st": 153, "ed": 155, "text": "\" negation"}, {"st": 156, "ed": 158, "text": "free \""}, {"st": 159, "ed": 161, "text": "Kleisli composition"}, {"st": 166, "ed": 168, "text": "induced join"}, {"st": 169, "ed": 171, "text": "Kleisli arrows"}, {"st": 184, "ed": 186, "text": "standard models"}, {"st": 188, "ed": 190, "text": "special instances"}, {"st": 194, "ed": 196, "text": "weak completeness"}, {"st": 202, "ed": 205, "text": "free Game Logic"}, {"st": 208, "ed": 211, "text": "modest new result"}, {"st": 217, "ed": 219, "text": "free GL"}, {"st": 223, "ed": 225, "text": "demonic choice"}]
[{"st": 0, "ed": 3, "text": "Partial Model Checking"}, {"st": 6, "ed": 9, "text": "Labelled Transition Systems"}, {"st": 12, "ed": 14, "text": "Equation Systems"}]
[{"st": 0, "ed": 3, "text": "Partial model checking"}, {"st": 12, "ed": 15, "text": "temporal logic formula"}, {"st": 31, "ed": 33, "text": "behavioural information"}, {"st": 46, "ed": 48, "text": "new formula"}, {"st": 59, "ed": 61, "text": "incorporated process"}, {"st": 84, "ed": 86, "text": "tractable size"}, {"st": 93, "ed": 95, "text": "partial model"}, {"st": 106, "ed": 110, "text": "labelled transition systems model"}, {"st": 114, "ed": 117, "text": "parallel composition operators"}, {"st": 123, "ed": 125, "text": "n synchronisation"}, {"st": 126, "ed": 128, "text": "parallel composition"}, {"st": 129, "ed": 131, "text": "synchronisation interfaces"}, {"st": 135, "ed": 137, "text": "ELOTOS standard"}, {"st": 147, "ed": 150, "text": "simple synchronous product"}, {"st": 152, "ed": 154, "text": "graph representation"}, {"st": 201, "ed": 204, "text": "Boolean equation systems"}, {"st": 208, "ed": 210, "text": "formula graph"}, {"st": 213, "ed": 215, "text": "formula simplifications"}, {"st": 235, "ed": 237, "text": "Distributed Processes"}, {"st": 242, "ed": 244, "text": "experimental results"}, {"st": 246, "ed": 248, "text": "partial model"}, {"st": 249, "ed": 251, "text": "uses hundreds"}, {"st": 260, "ed": 263, "text": "fly model checking"}]
[{"st": 1, "ed": 3, "text": "Modal Logics"}, {"st": 4, "ed": 7, "text": "Partial Recursive Functions"}]
[{"st": 1, "ed": 4, "text": "classical propositional logic"}, {"st": 15, "ed": 17, "text": "set semantics"}, {"st": 27, "ed": 29, "text": "propositional language"}, {"st": 31, "ed": 34, "text": "new binary modality"}, {"st": 37, "ed": 42, "text": "partial recursive function type constructor"}, {"st": 44, "ed": 46, "text": "above interpretation"}, {"st": 54, "ed": 56, "text": "deterministic functions"}, {"st": 64, "ed": 67, "text": "complete modal logics"}]
[{"st": 4, "ed": 6, "text": "Schema Aided"}, {"st": 7, "ed": 10, "text": "Automated Theorem Proving"}, {"st": 12, "ed": 18, "text": "Case Study [ Extended Paper ]"}]
[{"st": 1, "ed": 4, "text": "schematic CERES method"}, {"st": 13, "ed": 15, "text": "cut elimination"}, {"st": 16, "ed": 18, "text": "proof schemata"}, {"st": 27, "ed": 29, "text": "recursive construction"}, {"st": 30, "ed": 32, "text": "Proof schemata"}, {"st": 43, "ed": 45, "text": "induction rule"}, {"st": 58, "ed": 60, "text": "schematic version"}, {"st": 62, "ed": 65, "text": "infinitary pigeonhole principle"}, {"st": 72, "ed": 75, "text": "injectivity Assertion schema"}, {"st": 110, "ed": 113, "text": "schematic CERES method"}, {"st": 124, "ed": 127, "text": "first appli- cation"}, {"st": 132, "ed": 134, "text": "proof analysis"}, {"st": 135, "ed": 137, "text": "proof schemata"}, {"st": 139, "ed": 141, "text": "mathematical argument"}, {"st": 150, "ed": 153, "text": "Automated Theorem Proving"}, {"st": 157, "ed": 160, "text": "schematic proof analysis"}, {"st": 168, "ed": 171, "text": "schematic CERES method"}, {"st": 183, "ed": 185, "text": "expressive power"}, {"st": 187, "ed": 190, "text": "schematic resolution calculus"}, {"st": 202, "ed": 205, "text": "schematic proof analysis"}]
[{"st": 0, "ed": 4, "text": "Towards Efficient Axiom Pinpointing"}, {"st": 5, "ed": 7, "text": "EL+ Ontologies"}]
[{"st": 1, "ed": 3, "text": "EL family"}, {"st": 4, "ed": 6, "text": "Description Logics"}, {"st": 16, "ed": 18, "text": "recent years"}, {"st": 35, "ed": 37, "text": "other hand"}, {"st": 45, "ed": 47, "text": "different classes"}, {"st": 55, "ed": 57, "text": "medical domain"}, {"st": 71, "ed": 74, "text": "inferable subsumption relations"}, {"st": 81, "ed": 83, "text": "recent years"}, {"st": 87, "ed": 89, "text": "axiom pinpointing"}, {"st": 97, "ed": 99, "text": "minimal sets"}, {"st": 103, "ed": 106, "text": "unintended subsumption relations"}, {"st": 109, "ed": 111, "text": "concrete case"}, {"st": 118, "ed": 121, "text": "efficient approaches consist"}, {"st": 126, "ed": 128, "text": "propositional logic"}, {"st": 132, "ed": 134, "text": "Horn formula"}, {"st": 141, "ed": 143, "text": "dedicated algorithm"}, {"st": 155, "ed": 157, "text": "important relationship"}, {"st": 158, "ed": 161, "text": "minimal axioms sets"}, {"st": 162, "ed": 165, "text": "minimal unsatisfiable subformulas"}, {"st": 167, "ed": 169, "text": "propositional domain"}, {"st": 178, "ed": 180, "text": "vast body"}, {"st": 181, "ed": 183, "text": "recent work"}, {"st": 185, "ed": 187, "text": "propositional domain"}, {"st": 189, "ed": 191, "text": "concrete case"}, {"st": 202, "ed": 204, "text": "practical perspective"}, {"st": 213, "ed": 215, "text": "several orders"}, {"st": 221, "ed": 223, "text": "current state"}, {"st": 227, "ed": 229, "text": "axiom pinpointing"}, {"st": 231, "ed": 233, "text": "EL family"}]
[{"st": 1, "ed": 4, "text": "partial order semantics"}, {"st": 5, "ed": 8, "text": "SAT / SMT"}, {"st": 10, "ed": 12, "text": "symbolic encodings"}, {"st": 13, "ed": 16, "text": "weak memory concurrency"}]
[{"st": 0, "ed": 2, "text": "Concurrent systems"}, {"st": 9, "ed": 11, "text": "technological advances"}, {"st": 13, "ed": 16, "text": "weak memory architectures"}, {"st": 26, "ed": 29, "text": "partial order semantics"}, {"st": 31, "ed": 33, "text": "theoretical foundation"}, {"st": 34, "ed": 37, "text": "formal verification techniques"}, {"st": 41, "ed": 43, "text": "symbolic techniques"}, {"st": 62, "ed": 64, "text": "decision procedures"}, {"st": 66, "ed": 70, "text": "SAT / SMT solvers"}, {"st": 74, "ed": 77, "text": "new fundamental results"}, {"st": 78, "ed": 81, "text": "partial order semantics"}, {"st": 82, "ed": 85, "text": "SAT / SMT"}, {"st": 87, "ed": 89, "text": "symbolic encodings"}, {"st": 90, "ed": 93, "text": "weak memory concurrency"}, {"st": 100, "ed": 102, "text": "theoretical basis"}, {"st": 104, "ed": 106, "text": "decision procedure"}, {"st": 112, "ed": 114, "text": "concurrent programs"}, {"st": 117, "ed": 120, "text": "fixed point operators"}, {"st": 128, "ed": 132, "text": "certain partial order semantics"}, {"st": 133, "ed": 136, "text": "relaxed sequential consistency"}, {"st": 144, "ed": 148, "text": "studied weak memory axioms"}, {"st": 154, "ed": 156, "text": "important consequence"}, {"st": 163, "ed": 165, "text": "symbolic encoding"}, {"st": 166, "ed": 168, "text": "bounded model"}, {"st": 173, "ed": 175, "text": "quadratic number"}, {"st": 176, "ed": 179, "text": "partial order constraints"}, {"st": 191, "ed": 193, "text": "size encoding"}]
[{"st": 0, "ed": 2, "text": "Quantitative Approximation"}, {"st": 4, "ed": 6, "text": "Probability Distribution"}, {"st": 8, "ed": 10, "text": "Markov Process"}, {"st": 11, "ed": 13, "text": "Formal Abstractions"}]
[{"st": 10, "ed": 12, "text": "Markov process"}, {"st": 14, "ed": 16, "text": "discrete time"}, {"st": 18, "ed": 21, "text": "general state space"}, {"st": 25, "ed": 28, "text": "state Markov chain"}, {"st": 36, "ed": 39, "text": "state probability distribution"}, {"st": 54, "ed": 56, "text": "Markov chain"}, {"st": 62, "ed": 64, "text": "formal abstractions"}, {"st": 67, "ed": 70, "text": "arbitrary finite partition"}, {"st": 72, "ed": 74, "text": "state space"}, {"st": 76, "ed": 78, "text": "Markov process"}, {"st": 83, "ed": 86, "text": "average transition probabilities"}, {"st": 87, "ed": 89, "text": "partition sets"}, {"st": 91, "ed": 93, "text": "abstraction technique"}, {"st": 104, "ed": 106, "text": "introduced approximation"}, {"st": 133, "ed": 136, "text": "unbounded state spaces"}, {"st": 143, "ed": 145, "text": "state space"}, {"st": 147, "ed": 149, "text": "compact set"}, {"st": 155, "ed": 157, "text": "error bound"}, {"st": 161, "ed": 163, "text": "asymptotic properties"}, {"st": 165, "ed": 167, "text": "transition kernel"}, {"st": 169, "ed": 171, "text": "original process"}, {"st": 173, "ed": 176, "text": "overall abstraction algorithm"}, {"st": 181, "ed": 184, "text": "piecewise constant approximations"}, {"st": 186, "ed": 188, "text": "density functions"}, {"st": 190, "ed": 192, "text": "Markov process"}, {"st": 198, "ed": 201, "text": "order function approximations"}, {"st": 207, "ed": 209, "text": "error bounds"}, {"st": 212, "ed": 214, "text": "computational requirements"}, {"st": 222, "ed": 224, "text": "probabilistic invariance"}, {"st": 226, "ed": 228, "text": "Markov process"}, {"st": 237, "ed": 239, "text": "alternative approach"}]
[{"st": 0, "ed": 2, "text": "Dynamic Causality"}, {"st": 3, "ed": 5, "text": "Event Structures"}, {"st": 6, "ed": 8, "text": "Technical Report"}]
[{"st": 9, "ed": 12, "text": "Prime Event Structures"}, {"st": 20, "ed": 22, "text": "causal relation"}, {"st": 39, "ed": 41, "text": "causal dependencies"}, {"st": 46, "ed": 48, "text": "expressive power"}, {"st": 50, "ed": 54, "text": "resulting Event Structures w.r.t"}, {"st": 60, "ed": 62, "text": "Event Structures"}, {"st": 67, "ed": 69, "text": "technical report"}, {"st": 71, "ed": 73, "text": "additional information"}]
[{"st": 0, "ed": 2, "text": "Temporal Logics"}]
[{"st": 1, "ed": 3, "text": "new logics"}, {"st": 12, "ed": 14, "text": "security policies"}, {"st": 25, "ed": 27, "text": "computation paths"}, {"st": 28, "ed": 31, "text": "Standard temporal logics"}, {"st": 38, "ed": 40, "text": "CTL *"}, {"st": 45, "ed": 47, "text": "single path"}, {"st": 55, "ed": 57, "text": "many hyperproperties"}, {"st": 67, "ed": 69, "text": "HyperCTL *"}, {"st": 73, "ed": 75, "text": "simultaneous quantification"}, {"st": 76, "ed": 78, "text": "multiple paths"}, {"st": 86, "ed": 89, "text": "quantification enables expression"}, {"st": 110, "ed": 113, "text": "prototype model checker"}]
[{"st": 4, "ed": 6, "text": "Full Completeness"}]
[{"st": 19, "ed": 21, "text": "full abstraction"}, {"st": 24, "ed": 27, "text": "other programming languages"}, {"st": 30, "ed": 32, "text": "full completeness"}, {"st": 33, "ed": 35, "text": "various logics"}, {"st": 36, "ed": 38, "text": "type theories"}, {"st": 48, "ed": 50, "text": "full abstraction"}, {"st": 60, "ed": 62, "text": "recent results"}, {"st": 65, "ed": 67, "text": "full abstraction"}, {"st": 68, "ed": 70, "text": "game semantics"}, {"st": 77, "ed": 79, "text": "Full completeness"}]
[{"st": 4, "ed": 6, "text": "Process Algebra"}]
[{"st": 2, "ed": 5, "text": "traced monoidal categories"}, {"st": 8, "ed": 11, "text": "precise general version"}, {"st": 12, "ed": 14, "text": "\" geometry"}, {"st": 15, "ed": 17, "text": "interaction \""}, {"st": 26, "ed": 28, "text": "\" particle"}, {"st": 29, "ed": 31, "text": "style \""}, {"st": 35, "ed": 38, "text": "style \" instances"}]
[{"st": 3, "ed": 5, "text": "Linear Loops"}]
[{"st": 3, "ed": 5, "text": "new method"}, {"st": 12, "ed": 14, "text": "termination arguments"}, {"st": 15, "ed": 18, "text": "linear loop programs"}, {"st": 20, "ed": 23, "text": "linear ranking templates"}, {"st": 24, "ed": 27, "text": "Linear ranking templates"}, {"st": 45, "ed": 47, "text": "ranking function"}, {"st": 67, "ed": 69, "text": "linear components"}, {"st": 79, "ed": 82, "text": "lexicographic ranking functions"}, {"st": 85, "ed": 87, "text": "ranking templates"}, {"st": 93, "ed": 95, "text": "strict inequalities"}, {"st": 100, "ed": 102, "text": "Transposition Theorem"}, {"st": 104, "ed": 106, "text": "Farkas Lemma"}]
[{"st": 0, "ed": 2, "text": "Linear Ranking"}, {"st": 3, "ed": 6, "text": "Linear Lasso Programs"}]
[{"st": 1, "ed": 3, "text": "general setting"}, {"st": 13, "ed": 15, "text": "termination arguments"}, {"st": 19, "ed": 21, "text": "restricted class"}, {"st": 24, "ed": 26, "text": "lasso programs"}, {"st": 28, "ed": 30, "text": "termination argument"}, {"st": 32, "ed": 34, "text": "lasso program"}, {"st": 39, "ed": 41, "text": "ranking function"}, {"st": 54, "ed": 56, "text": "knowledge ---"}, {"st": 60, "ed": 62, "text": "termination arguments"}, {"st": 63, "ed": 65, "text": "lasso programs"}, {"st": 73, "ed": 75, "text": "completeness theorem"}, {"st": 77, "ed": 79, "text": "completeness theorem"}, {"st": 104, "ed": 106, "text": "termination arguments"}, {"st": 107, "ed": 110, "text": "several interesting cases"}, {"st": 119, "ed": 121, "text": "constraint transformation"}]
[{"st": 1, "ed": 3, "text": "Function Synthesis"}, {"st": 4, "ed": 7, "text": "Linear Lasso Programs"}]
[{"st": 12, "ed": 14, "text": "termination arguments"}, {"st": 16, "ed": 18, "text": "restricted class"}, {"st": 21, "ed": 24, "text": "linear lasso programs"}, {"st": 26, "ed": 28, "text": "termination argument"}, {"st": 31, "ed": 33, "text": "ranking function"}, {"st": 47, "ed": 49, "text": "several ways"}, {"st": 56, "ed": 58, "text": "Transposition Theorem"}, {"st": 69, "ed": 72, "text": "linear lasso programs"}, {"st": 76, "ed": 78, "text": "strict inequalities"}, {"st": 86, "ed": 88, "text": "strict inequalities"}, {"st": 95, "ed": 97, "text": "several kinds"}, {"st": 107, "ed": 110, "text": "lexicographic ranking functions"}, {"st": 116, "ed": 118, "text": "novel kind"}, {"st": 122, "ed": 125, "text": "multiphase ranking function"}, {"st": 129, "ed": 131, "text": "fixed number"}, {"st": 144, "ed": 147, "text": "linear ranking function"}, {"st": 164, "ed": 166, "text": "function template"}, {"st": 173, "ed": 175, "text": "ranking functions"}, {"st": 177, "ed": 179, "text": "unified way"}, {"st": 181, "ed": 183, "text": "method relies"}, {"st": 186, "ed": 189, "text": "linear algebraic constraint"}, {"st": 200, "ed": 202, "text": "large problems"}, {"st": 231, "ed": 233, "text": "linear constraints"}, {"st": 246, "ed": 248, "text": "termination argument"}, {"st": 255, "ed": 258, "text": "ranking function template"}, {"st": 260, "ed": 262, "text": "fixed number"}, {"st": 275, "ed": 277, "text": "termination argument"}, {"st": 289, "ed": 291, "text": "powerful technique"}, {"st": 297, "ed": 299, "text": "termination arguments"}, {"st": 300, "ed": 303, "text": "linear lasso programs"}, {"st": 306, "ed": 309, "text": "enhances several methods"}]
[{"st": 0, "ed": 2, "text": "Game Semantics"}, {"st": 3, "ed": 5, "text": "Access Control"}]
[{"st": 3, "ed": 5, "text": "semantic approach"}, {"st": 11, "ed": 13, "text": "access control"}, {"st": 14, "ed": 16, "text": "dependency analysis"}, {"st": 19, "ed": 21, "text": "Game Semantics"}, {"st": 27, "ed": 29, "text": "AJM games"}, {"st": 30, "ed": 32, "text": "explicit justification"}, {"st": 47, "ed": 49, "text": "intuitive model"}, {"st": 51, "ed": 57, "text": "information flow constraints underlying access control"}, {"st": 64, "ed": 66, "text": "simple proofs"}, {"st": 69, "ed": 71, "text": "interference theorems"}, {"st": 75, "ed": 77, "text": "semantic versions"}]
[{"st": 1, "ed": 3, "text": "Temporal Properties"}, {"st": 4, "ed": 6, "text": "Interval Analysis"}]
[{"st": 2, "ed": 5, "text": "temporal logic properties"}, {"st": 7, "ed": 9, "text": "crucial role"}, {"st": 12, "ed": 14, "text": "desired behaviors"}, {"st": 15, "ed": 17, "text": "continuous systems"}, {"st": 25, "ed": 27, "text": "interval method"}, {"st": 34, "ed": 38, "text": "bounded signal temporal logic"}, {"st": 47, "ed": 49, "text": "verification process"}, {"st": 54, "ed": 56, "text": "prescribed precision"}, {"st": 60, "ed": 62, "text": "inconclusive result"}, {"st": 71, "ed": 74, "text": "rigorous monitoring algorithm"}, {"st": 79, "ed": 81, "text": "forward simulation"}, {"st": 85, "ed": 88, "text": "time dynamical system"}, {"st": 93, "ed": 95, "text": "time intervals"}, {"st": 98, "ed": 100, "text": "atomic propositions"}, {"st": 109, "ed": 111, "text": "time intervals"}, {"st": 117, "ed": 119, "text": "continuous state"}, {"st": 121, "ed": 123, "text": "certain time"}, {"st": 127, "ed": 129, "text": "interval vector"}, {"st": 135, "ed": 137, "text": "unique solution"}, {"st": 148, "ed": 150, "text": "formal analysis"}, {"st": 153, "ed": 156, "text": "complex continuous systems"}]
[{"st": 0, "ed": 2, "text": "Ioco Theory"}, {"st": 3, "ed": 5, "text": "Probabilistic Automata"}]
[{"st": 17, "ed": 21, "text": "automatic test case generation"}, {"st": 30, "ed": 32, "text": "functional properties"}, {"st": 36, "ed": 39, "text": "test MBT frameworks"}, {"st": 50, "ed": 52, "text": "continuous behaviour"}, {"st": 53, "ed": 55, "text": "symbolic data"}, {"st": 56, "ed": 59, "text": "quantitative system aspects"}, {"st": 72, "ed": 77, "text": "classical input / output conformance"}, {"st": 88, "ed": 90, "text": "test theory"}, {"st": 91, "ed": 93, "text": "probabilistic behaviour"}, {"st": 103, "ed": 106, "text": "many different systems"}, {"st": 107, "ed": 110, "text": "unreliable communication channels"}, {"st": 114, "ed": 116, "text": "communication protocols"}, {"st": 117, "ed": 120, "text": "service level agreements"}, {"st": 124, "ed": 126, "text": "time percentages"}, {"st": 132, "ed": 135, "text": "probabilistic test theory"}, {"st": 137, "ed": 140, "text": "great practical importance"}, {"st": 147, "ed": 149, "text": "probabilistic variant"}, {"st": 155, "ed": 157, "text": "\\pi}oco relation"}, {"st": 169, "ed": 171, "text": "test case"}]
[{"st": 0, "ed": 2, "text": "Cellular Automata"}]
[{"st": 13, "ed": 15, "text": "machine axiomatization"}, {"st": 16, "ed": 18, "text": "classical algorithms"}, {"st": 22, "ed": 25, "text": "arbitrary unordered domain"}, {"st": 30, "ed": 33, "text": "dynamic cellular automaton"}, {"st": 42, "ed": 44, "text": "cellular automaton"}, {"st": 45, "ed": 47, "text": "unconstrained topology"}, {"st": 53, "ed": 55, "text": "new cells"}, {"st": 65, "ed": 67, "text": "physical reality"}]
[{"st": 1, "ed": 3, "text": "A Theory"}, {"st": 4, "ed": 6, "text": "Quantum Computability"}]
[{"st": 5, "ed": 8, "text": "quantum computable functions"}, {"st": 13, "ed": 15, "text": "natural numbers"}, {"st": 16, "ed": 18, "text": "probability distributions"}, {"st": 19, "ed": 21, "text": "natural numbers"}, {"st": 31, "ed": 33, "text": "infinite computation"}, {"st": 35, "ed": 38, "text": "quantum Turing machine"}, {"st": 42, "ed": 45, "text": "quantum computable functions"}, {"st": 55, "ed": 58, "text": "quantum computability theory"}, {"st": 64, "ed": 66, "text": "classical developments"}]
[{"st": 0, "ed": 4, "text": "Linear Intransitive Temporal Logic"}, {"st": 5, "ed": 7, "text": "Knowledge LTK_r"}, {"st": 8, "ed": 10, "text": "Decision Algorithms"}, {"st": 11, "ed": 13, "text": "Inference Rules"}]
[{"st": 4, "ed": 6, "text": "linear logic"}, {"st": 9, "ed": 11, "text": "time LTK_r"}, {"st": 12, "ed": 16, "text": "reflexive intransitive time relation"}, {"st": 33, "ed": 35, "text": "special frames"}, {"st": 38, "ed": 42, "text": "reflexive time binary relation"}, {"st": 44, "ed": 46, "text": "LTK_r -frames"}, {"st": 47, "ed": 49, "text": "linear chains"}, {"st": 54, "ed": 57, "text": "reflexive intransitive relation"}, {"st": 58, "ed": 60, "text": "R_T$. Elements"}, {"st": 66, "ed": 69, "text": "several equivalence relations"}, {"st": 73, "ed": 75, "text": "different agents"}, {"st": 79, "ed": 81, "text": "decidability problem"}, {"st": 84, "ed": 86, "text": "inference rules"}, {"st": 92, "ed": 94, "text": "decidability w.r.t"}, {"st": 95, "ed": 98, "text": "admissible inference rules"}, {"st": 106, "ed": 110, "text": "special constructive Kripke models"}, {"st": 116, "ed": 118, "text": "inference rules"}, {"st": 121, "ed": 123, "text": "special technique"}, {"st": 124, "ed": 126, "text": "definable valuations"}, {"st": 131, "ed": 134, "text": "admissible inference rules"}, {"st": 144, "ed": 146, "text": "logic LTK_r"}, {"st": 155, "ed": 157, "text": "inference rules"}]
[{"st": 0, "ed": 3, "text": "Morphoid Type Theory"}]
[{"st": 0, "ed": 3, "text": "Morphoid type theory"}, {"st": 8, "ed": 10, "text": "typed foundation"}, {"st": 13, "ed": 16, "text": "classical predicate calculus"}, {"st": 17, "ed": 20, "text": "Platonic compositional semantics"}, {"st": 30, "ed": 32, "text": "formal account"}, {"st": 41, "ed": 43, "text": "general functions"}, {"st": 44, "ed": 46, "text": "natural maps"}, {"st": 48, "ed": 50, "text": "\" Voldemort"}, {"st": 51, "ed": 53, "text": "theorem \""}, {"st": 55, "ed": 57, "text": "certain objects"}, {"st": 70, "ed": 72, "text": "natural point"}, {"st": 74, "ed": 76, "text": "geometric circle"}, {"st": 81, "ed": 83, "text": "geometric circle"}, {"st": 101, "ed": 103, "text": "particular basis"}, {"st": 105, "ed": 107, "text": "vector space"}, {"st": 109, "ed": 111, "text": "particular isomorphism"}, {"st": 113, "ed": 117, "text": "finite dimensional vector space"}, {"st": 121, "ed": 124, "text": "Homotopy type theory"}, {"st": 130, "ed": 132, "text": "formal account"}, {"st": 136, "ed": 138, "text": "constructive logic"}, {"st": 140, "ed": 143, "text": "classical predicate calculus"}, {"st": 146, "ed": 150, "text": "classical approach avoids HoTT"}, {"st": 157, "ed": 159, "text": "path induction"}, {"st": 163, "ed": 165, "text": "order isomorphisms"}, {"st": 176, "ed": 179, "text": "Platonic mathematical thought"}]
[{"st": 9, "ed": 11, "text": "Conjunctive Guards"}, {"st": 12, "ed": 14, "text": "Extended Version"}]
[{"st": 13, "ed": 15, "text": "process skeletons"}, {"st": 16, "ed": 18, "text": "conjunctive guards"}, {"st": 19, "ed": 21, "text": "Parameterized Networks"}, {"st": 22, "ed": 24, "text": "Timed Automata"}, {"st": 32, "ed": 34, "text": "unknown number"}, {"st": 35, "ed": 37, "text": "Timed Automata"}, {"st": 40, "ed": 42, "text": "finite set"}, {"st": 49, "ed": 52, "text": "Timed Automata templates"}, {"st": 65, "ed": 67, "text": "software systems"}, {"st": 69, "ed": 71, "text": "unknown number"}, {"st": 72, "ed": 74, "text": "software components"}, {"st": 75, "ed": 77, "text": "i.e. processes"}, {"st": 80, "ed": 84, "text": "continuous time temporal constraints"}, {"st": 95, "ed": 97, "text": "algorithms show"}, {"st": 98, "ed": 100, "text": "heterogeneous nature"}, {"st": 102, "ed": 104, "text": "dynamic aspects"}, {"st": 107, "ed": 109, "text": "time aspects"}, {"st": 125, "ed": 127, "text": "special variables"}, {"st": 134, "ed": 136, "text": "i.e. PIDs"}, {"st": 138, "ed": 140, "text": "Timed Automata"}, {"st": 141, "ed": 143, "text": "conjunctive guards"}, {"st": 155, "ed": 157, "text": "verification problem"}, {"st": 171, "ed": 173, "text": "other side"}]
[{"st": 4, "ed": 6, "text": "Algebraic Theory"}]
[{"st": 10, "ed": 12, "text": "algebraic theory"}, {"st": 19, "ed": 21, "text": "effect constructors"}, {"st": 22, "ed": 24, "text": "effect deconstructors"}, {"st": 31, "ed": 33, "text": "functional programming"}, {"st": 40, "ed": 43, "text": "seminal monadic point"}, {"st": 49, "ed": 52, "text": "natural algebraic theory"}, {"st": 56, "ed": 59, "text": "free algebra functor"}, {"st": 71, "ed": 73, "text": "initial algebras"}, {"st": 80, "ed": 83, "text": "stable failures model"}, {"st": 115, "ed": 117, "text": "choice operators"}, {"st": 139, "ed": 142, "text": "deterministic external choice"}, {"st": 146, "ed": 149, "text": "general external choice"}, {"st": 152, "ed": 154, "text": "binary deconstructors"}, {"st": 158, "ed": 161, "text": "CSP concurrency operator"}, {"st": 163, "ed": 165, "text": "unresolved difficulties"}, {"st": 207, "ed": 209, "text": "similar ideas"}, {"st": 210, "ed": 213, "text": "other process calculi"}]
[{"st": 1, "ed": 5, "text": "Coarsest Precongruences Respecting Safety"}, {"st": 6, "ed": 8, "text": "Liveness Properties"}]
[{"st": 5, "ed": 7, "text": "refinement preorders"}, {"st": 8, "ed": 11, "text": "labelled transition systems"}, {"st": 18, "ed": 21, "text": "synchronous interleaving operators"}, {"st": 30, "ed": 33, "text": "conditional liveness properties"}]
[{"st": 0, "ed": 3, "text": "Sequential Convex Programming"}, {"st": 5, "ed": 7, "text": "Efficient Verification"}, {"st": 8, "ed": 10, "text": "Parametric MDPs"}]
[{"st": 2, "ed": 5, "text": "objective verification problems"}, {"st": 6, "ed": 9, "text": "parametric Markov decision"}, {"st": 11, "ed": 13, "text": "optimality criteria"}, {"st": 18, "ed": 20, "text": "nonlinear programs"}, {"st": 35, "ed": 37, "text": "signomial programs"}, {"st": 43, "ed": 46, "text": "sequential optimization algorithm"}, {"st": 52, "ed": 54, "text": "suboptimal solutions"}, {"st": 62, "ed": 65, "text": "geometric programming problem"}, {"st": 67, "ed": 69, "text": "geometric programs"}, {"st": 74, "ed": 76, "text": "nonconvex constraints"}, {"st": 78, "ed": 80, "text": "original problem"}, {"st": 81, "ed": 83, "text": "Direct applications"}, {"st": 87, "ed": 90, "text": "nonlinear pro- grams"}, {"st": 91, "ed": 93, "text": "model repair"}, {"st": 94, "ed": 96, "text": "parameter synthesis"}]
[{"st": 0, "ed": 2, "text": "Blocked Clauses"}, {"st": 5, "ed": 7, "text": "Order Logic"}]
[{"st": 26, "ed": 29, "text": "simple syntactic criterion"}, {"st": 50, "ed": 52, "text": "blocked clauses"}, {"st": 55, "ed": 57, "text": "order logic"}, {"st": 63, "ed": 65, "text": "blocked clauses"}, {"st": 70, "ed": 72, "text": "order logic"}, {"st": 80, "ed": 82, "text": "order logic"}, {"st": 96, "ed": 98, "text": "polynomial algorithm"}, {"st": 109, "ed": 111, "text": "new notions"}, {"st": 131, "ed": 133, "text": "order problems"}, {"st": 135, "ed": 138, "text": "TPTP library contain"}, {"st": 139, "ed": 141, "text": "large number"}, {"st": 142, "ed": 144, "text": "blocked clauses"}, {"st": 157, "ed": 160, "text": "modern theorem provers"}, {"st": 163, "ed": 166, "text": "satisfiable problem instances"}]
[{"st": 5, "ed": 7, "text": "Sequential Logics"}]
[{"st": 2, "ed": 4, "text": "sequential logics"}, {"st": 13, "ed": 15, "text": "propositional terms"}, {"st": 16, "ed": 18, "text": "atomic propositions"}, {"st": 21, "ed": 23, "text": "side effects"}, {"st": 33, "ed": 36, "text": "Such propositional terms"}, {"st": 59, "ed": 61, "text": "sequential logics"}, {"st": 69, "ed": 71, "text": "Sequential Logic"}, {"st": 75, "ed": 78, "text": "full evaluation strategy"}, {"st": 89, "ed": 91, "text": "atomic propositions"}, {"st": 95, "ed": 98, "text": "possible side effects"}, {"st": 117, "ed": 120, "text": "[ BP10b ]"}, {"st": 142, "ed": 144, "text": "atomic propositions"}, {"st": 152, "ed": 154, "text": "evaluation trees"}, {"st": 156, "ed": 158, "text": "natural semantics"}, {"st": 167, "ed": 169, "text": "identifying variant"}, {"st": 184, "ed": 187, "text": "full evaluation strategy"}, {"st": 196, "ed": 199, "text": "circuit evaluation strategy"}]
[{"st": 3, "ed": 5, "text": "Reverse Modalities"}, {"st": 8, "ed": 10, "text": "preserving Bisimulations"}]
[{"st": 2, "ed": 5, "text": "event identifier logic"}, {"st": 12, "ed": 14, "text": "Milner logic"}, {"st": 25, "ed": 27, "text": "forward modalities"}, {"st": 53, "ed": 55, "text": "bisimulation equivalence"}, {"st": 60, "ed": 62, "text": "concurrency model"}, {"st": 64, "ed": 67, "text": "stable configuration structures"}, {"st": 72, "ed": 74, "text": "natural sublogics"}, {"st": 75, "ed": 77, "text": "EIL correspond"}, {"st": 85, "ed": 87, "text": "logical characterisations"}, {"st": 88, "ed": 90, "text": "weak history"}, {"st": 109, "ed": 111, "text": "H bisimulation"}, {"st": 119, "ed": 121, "text": "WH bisimulation"}, {"st": 137, "ed": 140, "text": "present characteristic formulas"}, {"st": 142, "ed": 144, "text": "individual structures"}, {"st": 149, "ed": 151, "text": "preserving equivalences"}]
[{"st": 0, "ed": 3, "text": "Synchrony vs Causality"}, {"st": 5, "ed": 7, "text": "Asynchronous Pi"}]
[{"st": 5, "ed": 7, "text": "process calculi"}, {"st": 14, "ed": 17, "text": "asynchronous interaction mechanism"}, {"st": 28, "ed": 30, "text": "synchronous interaction"}, {"st": 35, "ed": 37, "text": "asynchronous interactions"}, {"st": 48, "ed": 50, "text": "minimal conditions"}, {"st": 58, "ed": 61, "text": "\" good \""}, {"st": 68, "ed": 70, "text": "reflect computations"}, {"st": 91, "ed": 93, "text": "synchronous interactions"}, {"st": 95, "ed": 98, "text": "additional causal dependencies"}]
[{"st": 0, "ed": 2, "text": "Graphical representation"}, {"st": 5, "ed": 8, "text": "contravariant modal formulae"}]
[{"st": 2, "ed": 4, "text": "contravariant simulation"}, {"st": 15, "ed": 17, "text": "contravariant counterpart"}, {"st": 25, "ed": 27, "text": "logical characterization"}, {"st": 33, "ed": 36, "text": "contravariant modal logic"}, {"st": 50, "ed": 53, "text": "modal transition systems"}, {"st": 76, "ed": 78, "text": "simple framework"}, {"st": 87, "ed": 89, "text": "transition models"}, {"st": 92, "ed": 94, "text": "classic paper"}, {"st": 100, "ed": 102, "text": "precise connection"}, {"st": 104, "ed": 106, "text": "graphical approach"}, {"st": 110, "ed": 113, "text": "modal transition systems"}, {"st": 116, "ed": 118, "text": "logical approach"}, {"st": 129, "ed": 131, "text": "system specification"}, {"st": 138, "ed": 140, "text": "representation theorem"}, {"st": 174, "ed": 176, "text": "contravariant modal"}, {"st": 180, "ed": 184, "text": "\" graphical \" representation"}, {"st": 193, "ed": 196, "text": "contravariant simulation preorder"}, {"st": 202, "ed": 204, "text": "prime ones"}, {"st": 210, "ed": 214, "text": "desired graphical representation result"}, {"st": 225, "ed": 227, "text": "contravariant systems"}, {"st": 228, "ed": 230, "text": "bivariant actions"}, {"st": 231, "ed": 233, "text": "Bivariant actions"}, {"st": 245, "ed": 247, "text": "bivariant action"}, {"st": 252, "ed": 254, "text": "contravariant parts"}]
[{"st": 1, "ed": 4, "text": "normal logic program"}, {"st": 6, "ed": 10, "text": "2-valued Minimal Hypotheses semantics"}]
[{"st": 6, "ed": 8, "text": "unifying approach"}, {"st": 11, "ed": 13, "text": "hypotheses assumption"}, {"st": 23, "ed": 26, "text": "Normal Logic Programs"}, {"st": 31, "ed": 33, "text": "Minimal Hypotheses"}, {"st": 42, "ed": 46, "text": "positive hypotheses assumption approach"}, {"st": 52, "ed": 54, "text": "desirable properties"}, {"st": 55, "ed": 57, "text": "model existence"}, {"st": 66, "ed": 68, "text": "Stable Models"}, {"st": 79, "ed": 82, "text": "fundamental semantic concept"}, {"st": 85, "ed": 88, "text": "assumed positive hypotheses"}, {"st": 91, "ed": 93, "text": "MH semantics"}, {"st": 105, "ed": 108, "text": "abductive Logic Programming"}, {"st": 129, "ed": 131, "text": "Argumentation perspective"}, {"st": 132, "ed": 134, "text": "Logic Programs"}, {"st": 144, "ed": 146, "text": "assumption approach"}, {"st": 147, "ed": 149, "text": "Previous works"}, {"st": 166, "ed": 168, "text": "assumable hypotheses"}, {"st": 175, "ed": 177, "text": "general view"}, {"st": 181, "ed": 183, "text": "NLP semantics"}, {"st": 185, "ed": 187, "text": "positive hypotheses"}]
[{"st": 4, "ed": 6, "text": "argumentation frameworks"}, {"st": 9, "ed": 12, "text": "A preliminary report"}]
[{"st": 11, "ed": 13, "text": "argumentation frameworks"}, {"st": 26, "ed": 28, "text": "length cycles"}, {"st": 30, "ed": 32, "text": "main motivation"}, {"st": 45, "ed": 47, "text": "argumetation frameworks"}, {"st": 50, "ed": 52, "text": "length cycles"}, {"st": 58, "ed": 60, "text": "length cycles"}, {"st": 61, "ed": 63, "text": "default negation"}, {"st": 65, "ed": 67, "text": "developed construction"}, {"st": 74, "ed": 76, "text": "logic program"}, {"st": 77, "ed": 79, "text": "argumentation framework"}, {"st": 92, "ed": 94, "text": "argumentation framework"}, {"st": 100, "ed": 102, "text": "logic program"}, {"st": 103, "ed": 105, "text": "Weak points"}, {"st": 112, "ed": 114, "text": "future continuations"}]
[{"st": 4, "ed": 7, "text": "Ordered Model Transformations"}]
[{"st": 3, "ed": 5, "text": "driven development"}, {"st": 7, "ed": 10, "text": "ordered model transformation"}, {"st": 12, "ed": 14, "text": "nested set"}, {"st": 19, "ed": 21, "text": "target classes"}, {"st": 30, "ed": 32, "text": "own pre"}, {"st": 33, "ed": 35, "text": "post- conditions"}, {"st": 62, "ed": 65, "text": "Constructive Type Theory"}, {"st": 71, "ed": 73, "text": "model transformation"}, {"st": 78, "ed": 80, "text": "correctness proofs"}, {"st": 84, "ed": 86, "text": "model transformations"}]
[{"st": 1, "ed": 4, "text": "Labelled Sequent Calculus"}, {"st": 7, "ed": 9, "text": "Proof Theory"}, {"st": 10, "ed": 12, "text": "Proof Search"}]
[{"st": 3, "ed": 6, "text": "labelled sequent calculus"}, {"st": 7, "ed": 9, "text": "Boolean BI"}, {"st": 11, "ed": 13, "text": "classical variant"}, {"st": 20, "ed": 22, "text": "Bunched Implication"}, {"st": 43, "ed": 45, "text": "structural rules"}, {"st": 47, "ed": 49, "text": "proof system"}, {"st": 63, "ed": 66, "text": "certain logical rules"}, {"st": 75, "ed": 77, "text": "proof search"}, {"st": 85, "ed": 88, "text": "free variable calculus"}, {"st": 92, "ed": 94, "text": "structural rules"}, {"st": 97, "ed": 99, "text": "constraint system"}, {"st": 101, "ed": 103, "text": "heuristic method"}, {"st": 115, "ed": 117, "text": "experimental results"}]
[{"st": 1, "ed": 3, "text": "Proof Procedure"}, {"st": 4, "ed": 6, "text": "Hybrid Logic"}, {"st": 11, "ed": 13, "text": "Relation Hierarchies"}]
[{"st": 1, "ed": 3, "text": "previous works"}, {"st": 5, "ed": 7, "text": "tableau calculus"}, {"st": 14, "ed": 16, "text": "decision procedure"}, {"st": 17, "ed": 19, "text": "hybrid logic"}, {"st": 23, "ed": 25, "text": "global modalities"}, {"st": 45, "ed": 47, "text": "modal logic"}, {"st": 53, "ed": 55, "text": "description logics"}, {"st": 58, "ed": 61, "text": "relation inclusion assertions"}, {"st": 63, "ed": 65, "text": "separate addition"}, {"st": 67, "ed": 69, "text": "transitive relations"}, {"st": 70, "ed": 72, "text": "relation hierarchies"}, {"st": 75, "ed": 77, "text": "decidable fragment"}, {"st": 80, "ed": 83, "text": "modal hybrid logic"}, {"st": 103, "ed": 105, "text": "such results"}, {"st": 129, "ed": 131, "text": "complete calculus"}, {"st": 134, "ed": 136, "text": "logic proves"}, {"st": 140, "ed": 142, "text": "transitive relations"}, {"st": 143, "ed": 145, "text": "relation hierarchies"}, {"st": 148, "ed": 151, "text": "expressive decidable fragment"}, {"st": 152, "ed": 154, "text": "hybrid logic"}, {"st": 160, "ed": 162, "text": "further result"}, {"st": 178, "ed": 180, "text": "graded modalities"}, {"st": 182, "ed": 184, "text": "modal counterpart"}, {"st": 185, "ed": 187, "text": "number restrictions"}, {"st": 188, "ed": 190, "text": "description logics"}, {"st": 193, "ed": 196, "text": "undecidable satisfiability problem"}, {"st": 198, "ed": 201, "text": "further syntactical restrictions"}]
[{"st": 0, "ed": 2, "text": "Interpolation Properties"}, {"st": 6, "ed": 8, "text": "Model Checking"}]
[{"st": 0, "ed": 2, "text": "Craig interpolation"}, {"st": 4, "ed": 6, "text": "widespread method"}, {"st": 10, "ed": 12, "text": "important applications"}, {"st": 14, "ed": 16, "text": "Predicate Abstraction"}, {"st": 17, "ed": 21, "text": "CounterExample Guided Abstraction Refinement"}, {"st": 22, "ed": 24, "text": "Lazy Abstraction"}, {"st": 34, "ed": 36, "text": "art model"}, {"st": 40, "ed": 43, "text": "interpolation require collections"}, {"st": 47, "ed": 49, "text": "particular properties"}, {"st": 55, "ed": 57, "text": "\" collectives"}, {"st": 67, "ed": 69, "text": "interpolation systems"}, {"st": 76, "ed": 78, "text": "particular system"}, {"st": 79, "ed": 81, "text": "verification environment"}, {"st": 85, "ed": 87, "text": "systematic approach"}, {"st": 91, "ed": 94, "text": "individual interpolation systems"}, {"st": 97, "ed": 99, "text": "necessary collectives"}, {"st": 104, "ed": 106, "text": "uniform framework"}, {"st": 115, "ed": 117, "text": "common collectives"}, {"st": 126, "ed": 128, "text": "systematic study"}, {"st": 138, "ed": 141, "text": "propositional interpolation systems"}, {"st": 146, "ed": 148, "text": "model checking"}]
[]
[{"st": 8, "ed": 11, "text": "structural proof theory"}, {"st": 18, "ed": 21, "text": "paradigmatic computational primitives"}, {"st": 25, "ed": 27, "text": "new ones"}, {"st": 51, "ed": 53, "text": "logical system"}, {"st": 57, "ed": 59, "text": "process algebra"}, {"st": 64, "ed": 66, "text": "logical account"}, {"st": 68, "ed": 71, "text": "process algebra operation"}, {"st": 83, "ed": 85, "text": "Milner CCS"}, {"st": 91, "ed": 93, "text": "logical system"}, {"st": 99, "ed": 101, "text": "Deep Inference"}, {"st": 106, "ed": 108, "text": "dual quantifier"}, {"st": 116, "ed": 118, "text": "free proofs"}, {"st": 121, "ed": 123, "text": "logical system"}, {"st": 128, "ed": 130, "text": "reachability problems"}, {"st": 132, "ed": 134, "text": "process algebra"}, {"st": 137, "ed": 139, "text": "significant fragment"}, {"st": 140, "ed": 142, "text": "Milner CCS"}]
[{"st": 12, "ed": 14, "text": "dual quantifier"}]
[{"st": 6, "ed": 8, "text": "proof system"}, {"st": 13, "ed": 15, "text": "deep inference"}, {"st": 17, "ed": 20, "text": "multiplicative linear logic"}, {"st": 27, "ed": 31, "text": "commutative logical operator Seq"}, {"st": 43, "ed": 46, "text": "dual quantifier Sdq"}, {"st": 48, "ed": 50, "text": "system SBVQ"}, {"st": 61, "ed": 63, "text": "cut elimination"}, {"st": 68, "ed": 72, "text": "new logical operator Sdq"}, {"st": 101, "ed": 104, "text": "free subsystem BVQ"}, {"st": 108, "ed": 111, "text": "long term aim"}, {"st": 122, "ed": 125, "text": "pure logical accounts"}, {"st": 126, "ed": 128, "text": "computational primitives"}, {"st": 136, "ed": 138, "text": "computation analogy"}, {"st": 145, "ed": 147, "text": "incremental extensions"}]
[{"st": 4, "ed": 6, "text": "Probabilistic Automata"}]
[{"st": 1, "ed": 3, "text": "paper studies"}, {"st": 4, "ed": 6, "text": "difference operator"}, {"st": 7, "ed": 9, "text": "stochastic systems"}, {"st": 14, "ed": 17, "text": "Abstract Probabilistic Automata"}, {"st": 23, "ed": 26, "text": "case refinement fails"}, {"st": 39, "ed": 41, "text": "specification APA"}, {"st": 44, "ed": 46, "text": "witness PAs"}, {"st": 65, "ed": 67, "text": "arbitrary precision"}, {"st": 69, "ed": 71, "text": "technique relies"}, {"st": 72, "ed": 75, "text": "new quantitative notions"}, {"st": 94, "ed": 96, "text": "depth inspection"}, {"st": 98, "ed": 100, "text": "refinement relation"}, {"st": 114, "ed": 116, "text": "refinement checking"}]
[{"st": 3, "ed": 5, "text": "Impredicative Sort"}]
[{"st": 2, "ed": 4, "text": "abstraction theorem"}, {"st": 13, "ed": 15, "text": "large class"}, {"st": 16, "ed": 18, "text": "type systems"}, {"st": 25, "ed": 27, "text": "relational parametricity"}, {"st": 32, "ed": 34, "text": "abstraction theorem"}, {"st": 38, "ed": 40, "text": "Inductive Constructions"}, {"st": 46, "ed": 48, "text": "formal language"}, {"st": 53, "ed": 55, "text": "parametricity relations"}, {"st": 59, "ed": 61, "text": "impredicative sort"}, {"st": 76, "ed": 78, "text": "sort hierarchy"}, {"st": 80, "ed": 82, "text": "informative terms"}, {"st": 85, "ed": 87, "text": "informative terms"}, {"st": 105, "ed": 107, "text": "informative terms"}, {"st": 109, "ed": 111, "text": "many applications"}, {"st": 113, "ed": 115, "text": "natural encoding"}, {"st": 121, "ed": 123, "text": "theoretical purposes"}, {"st": 133, "ed": 135, "text": "logical system"}, {"st": 139, "ed": 141, "text": "practical aspirations"}, {"st": 145, "ed": 148, "text": "finite algebraic structures"}, {"st": 166, "ed": 170, "text": "new reflexive Coq tactic"}, {"st": 172, "ed": 174, "text": "proof terms"}]
[{"st": 3, "ed": 7, "text": "Distributed Goal Evaluation Algorithm"}, {"st": 8, "ed": 10, "text": "Trust Management"}]
[{"st": 0, "ed": 2, "text": "Trust management"}, {"st": 6, "ed": 8, "text": "access control"}, {"st": 9, "ed": 11, "text": "distributed systems"}, {"st": 12, "ed": 14, "text": "access decisions"}, {"st": 17, "ed": 19, "text": "policy statements"}, {"st": 21, "ed": 23, "text": "multiple principals"}, {"st": 27, "ed": 29, "text": "distributed manner"}, {"st": 31, "ed": 33, "text": "trust management"}, {"st": 35, "ed": 37, "text": "policy statements"}, {"st": 43, "ed": 45, "text": "other principals"}, {"st": 55, "ed": 57, "text": "access request"}, {"st": 67, "ed": 70, "text": "\" chain \""}, {"st": 71, "ed": 73, "text": "policy statements"}, {"st": 83, "ed": 87, "text": "existing goal evaluation algorithms"}, {"st": 88, "ed": 90, "text": "trust management"}, {"st": 94, "ed": 97, "text": "centralized evaluation strategy"}, {"st": 104, "ed": 107, "text": "relevant policy statements"}, {"st": 109, "ed": 111, "text": "single location"}, {"st": 121, "ed": 123, "text": "intensional policies"}, {"st": 152, "ed": 154, "text": "present GEM"}, {"st": 156, "ed": 160, "text": "distributed goal evaluation algorithm"}, {"st": 161, "ed": 164, "text": "trust management systems"}, {"st": 169, "ed": 172, "text": "free logic programming"}, {"st": 176, "ed": 178, "text": "policy statements"}, {"st": 185, "ed": 187, "text": "distributed way"}, {"st": 189, "ed": 191, "text": "intensional policies"}, {"st": 201, "ed": 203, "text": "algorithm terminates"}, {"st": 212, "ed": 214, "text": "standard semantics"}, {"st": 215, "ed": 217, "text": "logic programs"}]
[{"st": 1, "ed": 4, "text": "TLA+ Proof System"}]
[{"st": 6, "ed": 9, "text": "TLA+ specification language"}, {"st": 16, "ed": 18, "text": "proof environment"}, {"st": 21, "ed": 23, "text": "Proof Manager"}, {"st": 36, "ed": 38, "text": "PM support"}, {"st": 39, "ed": 41, "text": "incremental development"}, {"st": 57, "ed": 60, "text": "independent proof obligations"}, {"st": 68, "ed": 70, "text": "end provers"}, {"st": 74, "ed": 76, "text": "Different provers"}, {"st": 81, "ed": 83, "text": "different obligations"}, {"st": 92, "ed": 95, "text": "tableau prover Zenon"}, {"st": 96, "ed": 99, "text": "Isabelle / TLA+"}, {"st": 105, "ed": 108, "text": "Isabelle / Pure"}, {"st": 110, "ed": 112, "text": "proof obligations"}, {"st": 114, "ed": 117, "text": "complete TLA+ proof"}, {"st": 126, "ed": 129, "text": "Isabelle / TLA+"}]
[{"st": 0, "ed": 2, "text": "Bounded Variability"}, {"st": 3, "ed": 6, "text": "Metric Temporal Logic"}]
[{"st": 0, "ed": 2, "text": "Previous work"}, {"st": 9, "ed": 12, "text": "time temporal logics"}, {"st": 20, "ed": 23, "text": "bounded variability ---"}, {"st": 27, "ed": 29, "text": "v events"}, {"st": 32, "ed": 35, "text": "V time units"}, {"st": 54, "ed": 56, "text": "simpler techniques"}, {"st": 59, "ed": 61, "text": "bounded variability"}, {"st": 94, "ed": 97, "text": "Metric Temporal Logic"}, {"st": 108, "ed": 110, "text": "MTL formulas"}, {"st": 115, "ed": 117, "text": "time models"}, {"st": 121, "ed": 123, "text": "undecidability degree"}, {"st": 125, "ed": 127, "text": "generic dense"}, {"st": 128, "ed": 131, "text": "time MTL satisfiability"}, {"st": 135, "ed": 137, "text": "time models"}, {"st": 149, "ed": 151, "text": "space complexity"}, {"st": 157, "ed": 159, "text": "negative results"}, {"st": 164, "ed": 166, "text": "small fragments"}]
[{"st": 5, "ed": 7, "text": "Combinatory Logic"}, {"st": 8, "ed": 10, "text": "Boolean Constants"}]
[{"st": 5, "ed": 7, "text": "conditional term"}, {"st": 8, "ed": 10, "text": "system CL"}, {"st": 19, "ed": 21, "text": "Combinatory Logic"}, {"st": 22, "ed": 24, "text": "Boolean constants"}, {"st": 31, "ed": 33, "text": "RTA list"}, {"st": 34, "ed": 36, "text": "open problems"}, {"st": 45, "ed": 48, "text": "Coq proof assistant"}]
[{"st": 1, "ed": 3, "text": "MMT API"}, {"st": 5, "ed": 8, "text": "Generic MKM System"}]
[{"st": 1, "ed": 3, "text": "MMT language"}, {"st": 8, "ed": 10, "text": "scalable representation"}, {"st": 11, "ed": 13, "text": "interchange language"}, {"st": 14, "ed": 17, "text": "formal mathematical knowledge"}, {"st": 20, "ed": 22, "text": "natural representations"}, {"st": 30, "ed": 32, "text": "declarative languages"}, {"st": 37, "ed": 39, "text": "MKM services"}, {"st": 52, "ed": 55, "text": "specific formal languages"}, {"st": 57, "ed": 59, "text": "MMT API"}, {"st": 61, "ed": 63, "text": "MMT language"}, {"st": 65, "ed": 67, "text": "multiple backends"}, {"st": 68, "ed": 70, "text": "persistent storage"}, {"st": 75, "ed": 77, "text": "user access"}, {"st": 83, "ed": 85, "text": "wide variety"}, {"st": 89, "ed": 92, "text": "knowledge management services"}, {"st": 111, "ed": 114, "text": "A plugin interface"}, {"st": 118, "ed": 120, "text": "semantic idiosyncrasies"}, {"st": 121, "ed": 124, "text": "individual formal languages"}]
[{"st": 4, "ed": 7, "text": "free dynamic complexity"}]
[{"st": 1, "ed": 3, "text": "dynamic complexity"}, {"st": 5, "ed": 7, "text": "reachability query"}, {"st": 11, "ed": 14, "text": "dynamic complexity framework"}, {"st": 23, "ed": 26, "text": "free update formulas"}, {"st": 37, "ed": 39, "text": "reachability query"}, {"st": 47, "ed": 50, "text": "binary auxiliary relations"}, {"st": 52, "ed": 55, "text": "unary auxiliary functions"}, {"st": 58, "ed": 61, "text": "ternary auxiliary relations"}, {"st": 70, "ed": 73, "text": "binary auxiliary relations"}, {"st": 74, "ed": 77, "text": "Further inexpressibility results"}, {"st": 81, "ed": 83, "text": "reachability query"}, {"st": 85, "ed": 87, "text": "different setting"}, {"st": 92, "ed": 94, "text": "syntactical restriction"}, {"st": 97, "ed": 100, "text": "free update formulas"}, {"st": 102, "ed": 104, "text": "inexpressibility results"}, {"st": 106, "ed": 108, "text": "other queries"}]
[{"st": 0, "ed": 3, "text": "Propositional Dynamic Logic"}]
[{"st": 1, "ed": 4, "text": "model checking problem"}, {"st": 5, "ed": 8, "text": "propositional dynamic logic"}, {"st": 12, "ed": 15, "text": "message sequence charts"}, {"st": 20, "ed": 23, "text": "finite state machines"}, {"st": 36, "ed": 38, "text": "PDL formula"}, {"st": 50, "ed": 52, "text": "B$-bounded MSC"}, {"st": 57, "ed": 59, "text": "\\mathcal{C}$ satisfies"}, {"st": 76, "ed": 78, "text": "present work"}, {"st": 109, "ed": 112, "text": "single path expression"}, {"st": 114, "ed": 116, "text": "latter allows"}, {"st": 120, "ed": 122, "text": "path expression"}, {"st": 131, "ed": 134, "text": "model checking problem"}, {"st": 140, "ed": 144, "text": "message sequence chart automata"}, {"st": 153, "ed": 155, "text": "parity automata"}, {"st": 162, "ed": 164, "text": "new concept"}, {"st": 165, "ed": 167, "text": "concatenation states"}, {"st": 201, "ed": 204, "text": "model checking problem"}]
[]
[{"st": 21, "ed": 23, "text": "classical notions"}, {"st": 24, "ed": 26, "text": "concurrency theory"}, {"st": 37, "ed": 40, "text": "Petri net theory"}, {"st": 64, "ed": 66, "text": "l /"}, {"st": 72, "ed": 74, "text": "second \""}, {"st": 85, "ed": 87, "text": "delayed persistence"}, {"st": 90, "ed": 93, "text": "e / l"}, {"st": 102, "ed": 104, "text": "precise notion"}, {"st": 106, "ed": 108, "text": "e /"}, {"st": 126, "ed": 129, "text": "specified number k"}, {"st": 130, "ed": 133, "text": "single sequential steps"}, {"st": 138, "ed": 140, "text": "infinite hie\\-rarchy"}, {"st": 141, "ed": 145, "text": "such e / l"}, {"st": 146, "ed": 148, "text": "k persistencies"}, {"st": 194, "ed": 196, "text": "reachable markings"}, {"st": 218, "ed": 220, "text": "decision problems"}, {"st": 221, "ed": 224, "text": "e / l"}, {"st": 225, "ed": 227, "text": "k persistencies"}, {"st": 235, "ed": 238, "text": "e / l"}, {"st": 239, "ed": 241, "text": "k persistencies"}]
[{"st": 0, "ed": 3, "text": "Horn Linear Logic"}, {"st": 4, "ed": 6, "text": "Minsky Machines"}]
[{"st": 4, "ed": 6, "text": "detailed proof"}, {"st": 8, "ed": 10, "text": "crucial point"}, {"st": 12, "ed": 15, "text": "Minsky machine simulation"}, {"st": 18, "ed": 21, "text": "linear logic derivation"}, {"st": 23, "ed": 26, "text": "specific Horn sequent"}, {"st": 31, "ed": 33, "text": "Minsky computation"}, {"st": 36, "ed": 38, "text": "initial configuration"}, {"st": 40, "ed": 42, "text": "halting configuration"}, {"st": 44, "ed": 46, "text": "other things"}, {"st": 48, "ed": 50, "text": "presentation advantage"}, {"st": 52, "ed": 54, "text": "3-step program"}, {"st": 59, "ed": 62, "text": "trivial tricky points"}, {"st": 66, "ed": 68, "text": "independent parts"}, {"st": 75, "ed": 78, "text": "own intrinsic methodology"}, {"st": 88, "ed": 90, "text": "opposite directions"}, {"st": 105, "ed": 107, "text": "theoretic arguments"}, {"st": 114, "ed": 116, "text": "Horn programs"}, {"st": 121, "ed": 123, "text": "HLL derivations"}, {"st": 131, "ed": 133, "text": "same shape"}, {"st": 140, "ed": 142, "text": "Horn programs"}, {"st": 143, "ed": 145, "text": "Minsky computations"}, {"st": 149, "ed": 151, "text": "computational arguments"}]
[{"st": 0, "ed": 2, "text": "Typed realizability"}, {"st": 5, "ed": 8, "text": "order classical analysis"}]
[{"st": 3, "ed": 5, "text": "realizability framework"}, {"st": 9, "ed": 11, "text": "order logic"}, {"st": 28, "ed": 30, "text": "direct interpretation"}, {"st": 31, "ed": 33, "text": "classical proofs"}, {"st": 36, "ed": 39, "text": "usual negative translation"}, {"st": 40, "ed": 42, "text": "intuitionistic logic"}, {"st": 47, "ed": 49, "text": "usual terms"}, {"st": 52, "ed": 54, "text": "system T"}, {"st": 68, "ed": 70, "text": "computational model"}, {"st": 72, "ed": 75, "text": "bar recursion operator"}, {"st": 79, "ed": 81, "text": "dependent choice"}, {"st": 86, "ed": 88, "text": "proper analysis"}, {"st": 95, "ed": 97, "text": "technical proofs"}, {"st": 107, "ed": 110, "text": "\\Pi}02 formulas relies"}, {"st": 112, "ed": 114, "text": "novel implementation"}, {"st": 120, "ed": 122, "text": "control possibilities"}, {"st": 133, "ed": 135, "text": "simpler types"}, {"st": 140, "ed": 142, "text": "negative translation"}, {"st": 144, "ed": 146, "text": "intuitionistic realizability"}]
[{"st": 1, "ed": 3, "text": "Foundational View"}, {"st": 4, "ed": 6, "text": "Integration Problems"}]
[{"st": 5, "ed": 7, "text": "computation services"}, {"st": 10, "ed": 12, "text": "language boundaries"}, {"st": 17, "ed": 19, "text": "computer science"}, {"st": 54, "ed": 56, "text": "engineering perspective"}, {"st": 60, "ed": 62, "text": "foundational view"}, {"st": 66, "ed": 70, "text": "generic declarative language MMT"}, {"st": 74, "ed": 76, "text": "theoretical framework"}, {"st": 77, "ed": 79, "text": "system integration"}, {"st": 82, "ed": 85, "text": "partial theory morphisms"}, {"st": 94, "ed": 96, "text": "logical foundations"}, {"st": 108, "ed": 111, "text": "unsafe integration schemes"}, {"st": 114, "ed": 116, "text": "general form"}, {"st": 117, "ed": 119, "text": "safe integration"}]
[{"st": 0, "ed": 4, "text": "Weak Affine Light Typing"}, {"st": 5, "ed": 8, "text": "Polytime intensional expressivity"}]
[{"st": 0, "ed": 3, "text": "Weak affine light"}, {"st": 8, "ed": 12, "text": "light affine linear formulae"}, {"st": 22, "ed": 25, "text": "System F. WALT"}, {"st": 28, "ed": 30, "text": "time sound"}, {"st": 35, "ed": 37, "text": "term M"}, {"st": 48, "ed": 50, "text": "polynomial cost"}, {"st": 74, "ed": 76, "text": "rewriting relation"}, {"st": 87, "ed": 90, "text": "name / call"}, {"st": 130, "ed": 132, "text": "Light Systems"}, {"st": 138, "ed": 140, "text": "logical systems"}, {"st": 143, "ed": 145, "text": "Linear logic"}, {"st": 153, "ed": 155, "text": "Polynomial functions"}, {"st": 164, "ed": 166, "text": "compositional embedding"}, {"st": 170, "ed": 173, "text": "linear fragment QlSRN"}, {"st": 174, "ed": 176, "text": "Safe recursion"}, {"st": 193, "ed": 195, "text": "theoretical system"}, {"st": 201, "ed": 203, "text": "composition scheme"}, {"st": 207, "ed": 209, "text": "safe variables"}, {"st": 224, "ed": 226, "text": "Light Systems"}, {"st": 244, "ed": 246, "text": "safe arguments"}, {"st": 266, "ed": 268, "text": "theoretical sense"}]
[{"st": 0, "ed": 2, "text": "Finite Automata"}, {"st": 4, "ed": 6, "text": "Quantum Logic"}, {"st": 7, "ed": 9, "text": "Their Determinization"}]
[{"st": 3, "ed": 6, "text": "quantum subset construction"}, {"st": 7, "ed": 9, "text": "orthomodular lattice"}, {"st": 11, "ed": 13, "text": "finite automata"}, {"st": 20, "ed": 22, "text": "orthomodular lattice"}, {"st": 24, "ed": 26, "text": "finite automata"}, {"st": 27, "ed": 29, "text": "orthomodular lattice"}, {"st": 31, "ed": 34, "text": "deterministic finite automata"}, {"st": 35, "ed": 37, "text": "orthomodular lattice"}, {"st": 39, "ed": 41, "text": "finite automata"}, {"st": 55, "ed": 57, "text": "algebraic operations"}, {"st": 58, "ed": 60, "text": "orthomodular lattice"}, {"st": 62, "ed": 64, "text": "regular languages"}, {"st": 68, "ed": 70, "text": "Kleene theorem"}, {"st": 74, "ed": 76, "text": "quantum logic"}]
[{"st": 5, "ed": 8, "text": "quantifier structure hierarchy"}, {"st": 11, "ed": 13, "text": "order logic"}]
[{"st": 3, "ed": 5, "text": "natural hierarchy"}, {"st": 8, "ed": 10, "text": "order logic"}, {"st": 13, "ed": 16, "text": "quantifier structure hierarchy"}, {"st": 20, "ed": 22, "text": "systematic classification"}, {"st": 25, "ed": 27, "text": "order formulas"}, {"st": 40, "ed": 42, "text": "Fraisse games"}, {"st": 57, "ed": 59, "text": "finite structures"}, {"st": 61, "ed": 63, "text": "strategy compositions"}, {"st": 76, "ed": 78, "text": "finite structures"}, {"st": 86, "ed": 88, "text": "descriptive complexity"}]
[{"st": 3, "ed": 6, "text": "Priority Channel Systems"}]
[{"st": 2, "ed": 5, "text": "Priority Channel Systems"}, {"st": 7, "ed": 9, "text": "new class"}, {"st": 10, "ed": 12, "text": "channel systems"}, {"st": 16, "ed": 18, "text": "numeric priority"}, {"st": 22, "ed": 24, "text": "priority messages"}, {"st": 28, "ed": 30, "text": "priority messages"}, {"st": 34, "ed": 37, "text": "fifo communication buffers"}, {"st": 43, "ed": 45, "text": "inevitability properties"}, {"st": 52, "ed": 54, "text": "priority embedding"}, {"st": 77, "ed": 80, "text": "Priority Channel Systems"}, {"st": 90, "ed": 93, "text": "aforementioned verification problems"}]
[{"st": 3, "ed": 5, "text": "Theoretic Approach"}, {"st": 6, "ed": 8, "text": "Structural Resolution"}]
[{"st": 0, "ed": 2, "text": "Structural resolution"}, {"st": 20, "ed": 22, "text": "systematic separation"}, {"st": 29, "ed": 31, "text": "unification steps"}, {"st": 32, "ed": 35, "text": "Productive logic programs"}, {"st": 50, "ed": 52, "text": "productive programs"}, {"st": 53, "ed": 55, "text": "coinductive meaning"}, {"st": 56, "ed": 58, "text": "finite term"}, {"st": 70, "ed": 72, "text": "infinite derivation"}, {"st": 79, "ed": 81, "text": "productive way"}, {"st": 83, "ed": 86, "text": "attractive computational feature"}, {"st": 97, "ed": 99, "text": "first steps"}, {"st": 102, "ed": 104, "text": "conceptual understanding"}, {"st": 105, "ed": 107, "text": "operational properties"}, {"st": 125, "ed": 127, "text": "type system"}, {"st": 150, "ed": 152, "text": "reduction systems"}, {"st": 156, "ed": 158, "text": "soundness relative"}, {"st": 160, "ed": 162, "text": "type system"}, {"st": 166, "ed": 168, "text": "central methods"}, {"st": 172, "ed": 174, "text": "realizability transformation"}, {"st": 177, "ed": 179, "text": "logic programs"}]
[{"st": 0, "ed": 3, "text": "Abstract Model Repair"}]
[{"st": 2, "ed": 5, "text": "Kripke structure M"}, {"st": 22, "ed": 24, "text": "Model Repair"}, {"st": 28, "ed": 31, "text": "new model M"}, {"st": 57, "ed": 59, "text": "such M"}, {"st": 63, "ed": 65, "text": "model checking"}, {"st": 66, "ed": 68, "text": "state explosion"}, {"st": 76, "ed": 78, "text": "model repair"}, {"st": 84, "ed": 87, "text": "large state spaces"}, {"st": 97, "ed": 99, "text": "model repair"}, {"st": 101, "ed": 103, "text": "abstraction refinement"}, {"st": 105, "ed": 107, "text": "state explosion"}, {"st": 113, "ed": 116, "text": "Kripke Structure models"}, {"st": 119, "ed": 124, "text": "Kripke Modal Transition System abstraction"}, {"st": 126, "ed": 128, "text": "3-valued semantics"}, {"st": 138, "ed": 140, "text": "repair algorithm"}, {"st": 154, "ed": 156, "text": "complexity class"}, {"st": 160, "ed": 162, "text": "prototype implementation"}, {"st": 167, "ed": 169, "text": "practical utility"}, {"st": 177, "ed": 182, "text": "Automatic Door Opener system model"}, {"st": 187, "ed": 190, "text": "Andrew File System"}]
[{"st": 0, "ed": 2, "text": "Applicative Bisimulation"}, {"st": 7, "ed": 9, "text": "Long Version"}]
[{"st": 0, "ed": 2, "text": "Applicative bisimulation"}, {"st": 4, "ed": 6, "text": "coinductive technique"}, {"st": 8, "ed": 10, "text": "program equivalence"}, {"st": 13, "ed": 16, "text": "order functional languages"}, {"st": 40, "ed": 42, "text": "applicative bisimulation"}, {"st": 46, "ed": 48, "text": "underlying language"}, {"st": 63, "ed": 66, "text": "probabilistic binary choice"}, {"st": 69, "ed": 71, "text": "quantum data"}, {"st": 85, "ed": 87, "text": "main results"}, {"st": 93, "ed": 95, "text": "obtained notions"}]
[{"st": 0, "ed": 2, "text": "Partial functions"}]
[{"st": 1, "ed": 3, "text": "current work"}, {"st": 7, "ed": 9, "text": "pdominant sets"}, {"st": 14, "ed": 16, "text": "theoretic properties"}, {"st": 19, "ed": 21, "text": "set A"}, {"st": 23, "ed": 25, "text": "pdominant iff"}, {"st": 28, "ed": 30, "text": "partial A"}, {"st": 31, "ed": 33, "text": "recursive function"}, {"st": 40, "ed": 43, "text": "partial recursive function"}, {"st": 69, "ed": 71, "text": "y<= x"}, {"st": 88, "ed": 90, "text": "nonrecursive sets"}, {"st": 103, "ed": 105, "text": "pdominant sets"}, {"st": 107, "ed": 110, "text": "weakly 2-generic set"}, {"st": 115, "ed": 118, "text": "pdominant 1-generic sets"}, {"st": 139, "ed": 141, "text": "L\\\"of random"}, {"st": 147, "ed": 149, "text": "low r.e"}, {"st": 156, "ed": 158, "text": "high r.e"}]
[{"st": 1, "ed": 4, "text": "new graphical calculus"}]
[{"st": 3, "ed": 6, "text": "simple graphical representation"}, {"st": 9, "ed": 11, "text": "intuitionistic logic"}, {"st": 16, "ed": 18, "text": "proof nets"}, {"st": 19, "ed": 21, "text": "interaction nets"}, {"st": 26, "ed": 28, "text": "linear logic"}, {"st": 31, "ed": 33, "text": "graphical calculus"}, {"st": 34, "ed": 38, "text": "proofs inherits good features"}, {"st": 52, "ed": 54, "text": "Howard isomorphism"}, {"st": 61, "ed": 63, "text": "lambda calculus"}, {"st": 66, "ed": 69, "text": "alternative diagrammatic representation"}, {"st": 70, "ed": 72, "text": "functional computations"}]
[{"st": 1, "ed": 3, "text": "Algebraic Approach"}]
[{"st": 6, "ed": 9, "text": "approximate computing focuses"}, {"st": 14, "ed": 16, "text": "satisfactory solution"}, {"st": 20, "ed": 22, "text": "unnecessary accuracy"}, {"st": 26, "ed": 28, "text": "Approximate bisimularity"}, {"st": 35, "ed": 37, "text": "accurate bisimilarity"}, {"st": 45, "ed": 47, "text": "basic processes"}, {"st": 51, "ed": 53, "text": "algebraic approach"}, {"st": 60, "ed": 64, "text": "whole process calculus CCS"}]
[{"st": 0, "ed": 4, "text": "Proof Relevant Corecursive Resolution"}]
[{"st": 7, "ed": 9, "text": "logic programming"}, {"st": 10, "ed": 14, "text": "type class context reduction"}, {"st": 15, "ed": 17, "text": "functional languages"}, {"st": 26, "ed": 28, "text": "inductive meaning"}, {"st": 40, "ed": 42, "text": "Cycle detection"}, {"st": 44, "ed": 46, "text": "popular method"}, {"st": 49, "ed": 51, "text": "small subset"}, {"st": 52, "ed": 54, "text": "such derivations"}, {"st": 59, "ed": 62, "text": "fact cycle detection"}, {"st": 64, "ed": 66, "text": "restricted form"}, {"st": 67, "ed": 69, "text": "coinductive proof"}, {"st": 73, "ed": 75, "text": "atomic formula"}, {"st": 82, "ed": 84, "text": "coinductive hypothesis"}, {"st": 89, "ed": 91, "text": "heuristic method"}, {"st": 94, "ed": 96, "text": "coinductive hypotheses"}, {"st": 100, "ed": 102, "text": "Horn formulas"}, {"st": 106, "ed": 108, "text": "cycle detection"}, {"st": 110, "ed": 112, "text": "coinductive meaning"}, {"st": 126, "ed": 129, "text": "Horn formula resolvents"}, {"st": 130, "ed": 133, "text": "corecursive evidence generation"}, {"st": 142, "ed": 146, "text": "type class resolution problems"}]
[{"st": 3, "ed": 5, "text": "Boolean Satisfiability"}]
[{"st": 0, "ed": 2, "text": "Boolean satisfiability"}, {"st": 10, "ed": 12, "text": "key role"}, {"st": 13, "ed": 15, "text": "diverse areas"}, {"st": 18, "ed": 20, "text": "formal verification"}, {"st": 33, "ed": 35, "text": "classical problem"}, {"st": 37, "ed": 39, "text": "boolean satisfiability"}, {"st": 53, "ed": 55, "text": "total number"}, {"st": 64, "ed": 66, "text": "practical interest"}, {"st": 70, "ed": 72, "text": "Prior work"}, {"st": 73, "ed": 75, "text": "heuristic approaches"}, {"st": 85, "ed": 87, "text": "theoretical approaches"}, {"st": 88, "ed": 90, "text": "proven guarantees"}, {"st": 92, "ed": 94, "text": "poor performance"}, {"st": 100, "ed": 102, "text": "novel approach"}, {"st": 106, "ed": 108, "text": "independence hashing"}, {"st": 119, "ed": 122, "text": "strong theoretical guarantees"}, {"st": 138, "ed": 140, "text": "practical algorithms"}, {"st": 146, "ed": 149, "text": "near uniform generator"}, {"st": 155, "ed": 160, "text": "first scalable approximate model counter"}, {"st": 163, "ed": 165, "text": "reference implementations"}, {"st": 167, "ed": 169, "text": "algorithms work"}, {"st": 171, "ed": 173, "text": "polynomial calls"}, {"st": 187, "ed": 189, "text": "large set"}, {"st": 193, "ed": 196, "text": "different application domains"}]
[{"st": 3, "ed": 5, "text": "Descriptive Approaches"}, {"st": 6, "ed": 9, "text": "Preferred Answer Sets"}]
[{"st": 1, "ed": 3, "text": "logic programming"}, {"st": 5, "ed": 8, "text": "answer set semantics"}, {"st": 19, "ed": 21, "text": "conflicting rules"}, {"st": 24, "ed": 27, "text": "Many interesting semantics"}, {"st": 39, "ed": 41, "text": "basic intuition"}, {"st": 55, "ed": 57, "text": "imperative feature"}, {"st": 59, "ed": 61, "text": "declarative language"}, {"st": 88, "ed": 90, "text": "declarative approaches"}, {"st": 91, "ed": 93, "text": "preference handling"}, {"st": 101, "ed": 103, "text": "general conflicts"}, {"st": 107, "ed": 109, "text": "indirect conflicts"}, {"st": 113, "ed": 115, "text": "first approach"}, {"st": 130, "ed": 133, "text": "preferred conflicting rule"}, {"st": 144, "ed": 146, "text": "conflicting rules"}, {"st": 163, "ed": 165, "text": "stratified programs"}, {"st": 178, "ed": 180, "text": "full control"}, {"st": 184, "ed": 186, "text": "second approach"}, {"st": 191, "ed": 193, "text": "conflicting rules"}, {"st": 201, "ed": 204, "text": "NP complexity class"}, {"st": 230, "ed": 232, "text": "preferred rule"}, {"st": 234, "ed": 236, "text": "second approach"}, {"st": 305, "ed": 307, "text": "paper produce"}]
[{"st": 1, "ed": 5, "text": "Punctual Metric Temporal Logic"}]
[{"st": 0, "ed": 3, "text": "Metric Temporal Logic"}, {"st": 10, "ed": 14, "text": "studied real time logics"}, {"st": 17, "ed": 19, "text": "considerable diversity"}, {"st": 22, "ed": 24, "text": "decidability properties"}, {"st": 27, "ed": 29, "text": "permitted set"}, {"st": 35, "ed": 38, "text": "time interval constraints"}, {"st": 39, "ed": 41, "text": "I$. Henzinger"}, {"st": 47, "ed": 49, "text": "seminal paper"}, {"st": 54, "ed": 56, "text": "punctual fragment"}, {"st": 72, "ed": 74, "text": "decidability result"}, {"st": 79, "ed": 81, "text": "punctual fragment"}, {"st": 93, "ed": 98, "text": "monotonic finite point wise time"}, {"st": 106, "ed": 109, "text": "punctual future modalities"}, {"st": 111, "ed": 114, "text": "punctual past modalities"}, {"st": 136, "ed": 138, "text": "first reduction"}, {"st": 139, "ed": 141, "text": "simple projections"}, {"st": 144, "ed": 146, "text": "second reduction"}, {"st": 148, "ed": 150, "text": "novel technique"}, {"st": 151, "ed": 153, "text": "temporal projections"}, {"st": 169, "ed": 171, "text": "second reduction"}, {"st": 175, "ed": 178, "text": "extra action points"}, {"st": 180, "ed": 182, "text": "underlying model"}, {"st": 186, "ed": 188, "text": "\\mathsf{MTL}[\\until_I]$ formula"}, {"st": 198, "ed": 200, "text": "first reduction"}, {"st": 206, "ed": 208, "text": "underlying model"}]
[{"st": 0, "ed": 3, "text": "Nagoya Termination Tool"}]
[{"st": 9, "ed": 12, "text": "Nagoya Termination Tool"}, {"st": 14, "ed": 16, "text": "termination prover"}, {"st": 17, "ed": 20, "text": "term rewrite systems"}, {"st": 22, "ed": 24, "text": "main features"}, {"st": 30, "ed": 32, "text": "first implementation"}, {"st": 34, "ed": 37, "text": "weighted path order"}, {"st": 43, "ed": 45, "text": "reduction pairs"}, {"st": 52, "ed": 54, "text": "strong cooperation"}, {"st": 55, "ed": 58, "text": "external SMT solvers"}, {"st": 62, "ed": 64, "text": "new ideas"}]
[{"st": 3, "ed": 5, "text": "Decidable PDA"}, {"st": 7, "ed": 9, "text": "Undecidable Ones"}]
[{"st": 4, "ed": 6, "text": "language equivalence"}, {"st": 9, "ed": 11, "text": "disjoint epsilon"}, {"st": 12, "ed": 14, "text": "deterministic PDA"}, {"st": 19, "ed": 21, "text": "strong bisimilarity"}, {"st": 28, "ed": 31, "text": "negative side Srba"}, {"st": 34, "ed": 36, "text": "weak bisimilarity"}, {"st": 39, "ed": 41, "text": "normed PDA"}, {"st": 42, "ed": 44, "text": "Later Jancar"}, {"st": 51, "ed": 53, "text": "weak bisimilarity"}, {"st": 54, "ed": 56, "text": "disjoint epsilon"}, {"st": 60, "ed": 62, "text": "disjoint epsilon"}, {"st": 63, "ed": 65, "text": "popping PDA"}, {"st": 69, "ed": 71, "text": "undecidability results"}, {"st": 75, "ed": 77, "text": "present paper"}, {"st": 91, "ed": 93, "text": "branching bisimilarity"}, {"st": 94, "ed": 96, "text": "several variants"}]
[]
[{"st": 6, "ed": 8, "text": "formative rules"}, {"st": 11, "ed": 14, "text": "order term rewriting"}, {"st": 23, "ed": 25, "text": "order setting"}, {"st": 32, "ed": 34, "text": "usable rules"}, {"st": 35, "ed": 37, "text": "formative rules"}, {"st": 42, "ed": 44, "text": "term constraints"}, {"st": 51, "ed": 53, "text": "termination proof"}, {"st": 59, "ed": 61, "text": "order definition"}, {"st": 65, "ed": 67, "text": "order setting"}, {"st": 69, "ed": 71, "text": "significant improvements"}]
[{"st": 0, "ed": 2, "text": "Weak MSO+U"}, {"st": 3, "ed": 5, "text": "Path Quantifiers"}, {"st": 6, "ed": 8, "text": "Infinite Trees"}]
[{"st": 5, "ed": 7, "text": "infinite trees"}, {"st": 16, "ed": 18, "text": "order logic"}, {"st": 21, "ed": 24, "text": "unbounding quantifier U"}, {"st": 27, "ed": 29, "text": "infinite paths"}, {"st": 39, "ed": 42, "text": "certain automaton model"}, {"st": 47, "ed": 49, "text": "automaton model"}, {"st": 52, "ed": 54, "text": "profinite trees"}]
[{"st": 0, "ed": 2, "text": "Possible values"}]
[{"st": 1, "ed": 3, "text": "important issue"}, {"st": 28, "ed": 30, "text": "former case"}, {"st": 48, "ed": 51, "text": "/ guarantee approaches"}, {"st": 63, "ed": 65, "text": "concurrent programs"}, {"st": 73, "ed": 76, "text": "\" possible values"}, {"st": 87, "ed": 89, "text": "multiple times"}, {"st": 101, "ed": 103, "text": "clear specifications"}, {"st": 107, "ed": 109, "text": "principled way"}, {"st": 122, "ed": 124, "text": "unwise use"}]
[{"st": 0, "ed": 2, "text": "Property Checking"}, {"st": 3, "ed": 5, "text": "Logic Relaxation"}]
[{"st": 3, "ed": 5, "text": "new framework"}, {"st": 6, "ed": 8, "text": "Property Checking"}, {"st": 12, "ed": 14, "text": "sequential circuits"}, {"st": 24, "ed": 26, "text": "gic Relaxation"}, {"st": 32, "ed": 34, "text": "safety property"}, {"st": 36, "ed": 38, "text": "LoR method"}, {"st": 40, "ed": 42, "text": "transition system"}, {"st": 52, "ed": 54, "text": "reachable states"}, {"st": 58, "ed": 61, "text": "th time frame"}, {"st": 63, "ed": 65, "text": "LoR method"}, {"st": 67, "ed": 69, "text": "superset A_j"}, {"st": 73, "ed": 75, "text": "bad states"}, {"st": 77, "ed": 79, "text": "j transitions"}, {"st": 82, "ed": 84, "text": "relaxed system"}, {"st": 85, "ed": 87, "text": "Set A_j"}, {"st": 103, "ed": 105, "text": "bad state"}, {"st": 111, "ed": 113, "text": "j transitions"}, {"st": 115, "ed": 117, "text": "relaxed system"}, {"st": 124, "ed": 126, "text": "original system"}, {"st": 147, "ed": 149, "text": "inductive invariant"}, {"st": 168, "ed": 170, "text": "relaxed system"}, {"st": 184, "ed": 188, "text": "\" faulty \" relaxation"}, {"st": 193, "ed": 195, "text": "original system"}]
[]
[{"st": 1, "ed": 5, "text": "Constrained Term Rewriting Systems"}, {"st": 10, "ed": 12, "text": "general framework"}, {"st": 21, "ed": 25, "text": "simple dependency pair approach"}, {"st": 43, "ed": 45, "text": "natural way"}]
[{"st": 3, "ed": 5, "text": "finite meadows"}]
[{"st": 4, "ed": 6, "text": "commutative ring"}, {"st": 8, "ed": 11, "text": "total inverse operator"}, {"st": 20, "ed": 22, "text": "finite meadows"}, {"st": 29, "ed": 31, "text": "Galois fields"}, {"st": 32, "ed": 34, "text": "finite products"}, {"st": 42, "ed": 44, "text": "unique representation"}, {"st": 45, "ed": 48, "text": "minimal finite meadows"}, {"st": 51, "ed": 54, "text": "finite prime fields"}]
[{"st": 4, "ed": 6, "text": "lambda calculus"}]
[{"st": 11, "ed": 13, "text": "PhD thesis"}, {"st": 15, "ed": 17, "text": "denotational semantics"}, {"st": 18, "ed": 22, "text": "equational / order theories"}, {"st": 31, "ed": 34, "text": "main research achievements"}, {"st": 40, "ed": 42, "text": "general construction"}, {"st": 47, "ed": 49, "text": "reflexive objects"}, {"st": 66, "ed": 69, "text": "style representation theorem"}, {"st": 70, "ed": 72, "text": "combinatory algebras"}, {"st": 80, "ed": 82, "text": "effective lambda"}, {"st": 97, "ed": 99, "text": "equational theory"}, {"st": 106, "ed": 108, "text": "partial answer"}, {"st": 110, "ed": 112, "text": "open problem"}, {"st": 116, "ed": 119, "text": "Ronchi Della Rocca"}]
[{"st": 1, "ed": 3, "text": "decidable weakening"}, {"st": 4, "ed": 6, "text": "Compass Logic"}, {"st": 11, "ed": 13, "text": "cardinal directions"}]
[{"st": 3, "ed": 5, "text": "modal logic"}, {"st": 7, "ed": 9, "text": "Cone Logic"}, {"st": 20, "ed": 22, "text": "spatial relationships"}, {"st": 29, "ed": 31, "text": "proposition letters"}, {"st": 32, "ed": 34, "text": "spatial relations"}, {"st": 42, "ed": 44, "text": "cardinal directions"}, {"st": 45, "ed": 47, "text": "Cone Logic"}, {"st": 56, "ed": 58, "text": "Compass Logic"}, {"st": 64, "ed": 66, "text": "Compass Logic"}, {"st": 67, "ed": 69, "text": "other projection"}, {"st": 71, "ed": 73, "text": "spatial logics"}, {"st": 75, "ed": 77, "text": "satisfiability problem"}, {"st": 97, "ed": 101, "text": "meaningful interval temporal logics"}, {"st": 106, "ed": 109, "text": "interval temporal logic"}, {"st": 114, "ed": 116, "text": "Begins \""}, {"st": 123, "ed": 125, "text": "Later \""}]
[{"st": 1, "ed": 3, "text": "Program Logic"}, {"st": 4, "ed": 8, "text": "Verifying Secure Routing Protocols"}]
[{"st": 25, "ed": 28, "text": "formal security guarantees"}, {"st": 29, "ed": 32, "text": "proposed secure inter"}, {"st": 33, "ed": 36, "text": "domain routing protocols"}, {"st": 39, "ed": 41, "text": "Secure BGP"}, {"st": 54, "ed": 57, "text": "sound program logic"}, {"st": 61, "ed": 64, "text": "declarative specification language"}, {"st": 65, "ed": 68, "text": "secure routing protocols"}, {"st": 77, "ed": 79, "text": "invariant properties"}, {"st": 80, "ed": 82, "text": "SANDLog programs"}, {"st": 86, "ed": 88, "text": "adversarial environment"}, {"st": 99, "ed": 102, "text": "verification condition generator"}, {"st": 108, "ed": 110, "text": "proof obligations"}, {"st": 122, "ed": 125, "text": "executable protocol implementations"}, {"st": 132, "ed": 134, "text": "empirical evaluation"}, {"st": 135, "ed": 138, "text": "secure routing protocols"}, {"st": 144, "ed": 146, "text": "unified framework"}, {"st": 165, "ed": 168, "text": "path authenticity properties"}, {"st": 172, "ed": 175, "text": "generated verification conditions"}, {"st": 180, "ed": 182, "text": "executable code"}, {"st": 184, "ed": 186, "text": "SANDLog specification"}]
[{"st": 0, "ed": 2, "text": "Algebraic Logic"}, {"st": 7, "ed": 9, "text": "Completeness Theorems"}]
[{"st": 0, "ed": 3, "text": "Algebraic logic studies"}, {"st": 11, "ed": 13, "text": "order logic"}, {"st": 15, "ed": 18, "text": "new algebraic approach"}, {"st": 21, "ed": 23, "text": "order logic"}, {"st": 54, "ed": 56, "text": "Boolean algebras"}, {"st": 61, "ed": 63, "text": "determined system"}, {"st": 67, "ed": 69, "text": "striking feature"}, {"st": 76, "ed": 78, "text": "Completeness Theorem"}, {"st": 81, "ed": 83, "text": "Completeness Theorem"}, {"st": 104, "ed": 106, "text": "polyadic algebras"}, {"st": 111, "ed": 114, "text": "simple transparent treatment"}]
[{"st": 3, "ed": 5, "text": "Hybrid Automata"}, {"st": 6, "ed": 8, "text": "Bounded Time"}]
[{"st": 6, "ed": 8, "text": "bounded version"}, {"st": 10, "ed": 12, "text": "reachability problem"}, {"st": 13, "ed": 15, "text": "hybrid automata"}, {"st": 22, "ed": 24, "text": "hybrid automaton"}, {"st": 28, "ed": 30, "text": "target location"}, {"st": 31, "ed": 34, "text": "T time units"}, {"st": 39, "ed": 42, "text": "constant rational value"}, {"st": 55, "ed": 57, "text": "reachability problem"}, {"st": 66, "ed": 69, "text": "rectangular hybrid automata"}, {"st": 73, "ed": 75, "text": "negative rates"}, {"st": 84, "ed": 86, "text": "practical interest"}, {"st": 95, "ed": 97, "text": "stopwatch automata"}, {"st": 108, "ed": 110, "text": "diagonal constraints"}, {"st": 114, "ed": 116, "text": "positive rates"}]
[{"st": 5, "ed": 8, "text": "Symbolic Model Checking"}]
[{"st": 3, "ed": 6, "text": "LTL model checking"}, {"st": 24, "ed": 26, "text": "specific conditions"}, {"st": 28, "ed": 31, "text": "input LTL formula"}, {"st": 43, "ed": 45, "text": "model checking"}, {"st": 64, "ed": 66, "text": "same counterexample"}, {"st": 84, "ed": 86, "text": "such reduction"}, {"st": 91, "ed": 93, "text": "lightweight effort"}, {"st": 109, "ed": 113, "text": "such technique \" Counterexample"}, {"st": 115, "ed": 117, "text": "Reduction \""}]
[{"st": 0, "ed": 2, "text": "Lazy abstractions"}]
[{"st": 3, "ed": 5, "text": "reachability problem"}, {"st": 6, "ed": 8, "text": "timed automata"}, {"st": 10, "ed": 12, "text": "standard solution"}, {"st": 18, "ed": 20, "text": "search tree"}, {"st": 28, "ed": 30, "text": "efficiency reasons"}, {"st": 39, "ed": 41, "text": "upper bounds"}, {"st": 68, "ed": 70, "text": "search tree"}, {"st": 96, "ed": 98, "text": "unabstracted system"}, {"st": 109, "ed": 112, "text": "lazy CEGAR algorithm"}, {"st": 113, "ed": 115, "text": "timed automata"}, {"st": 120, "ed": 123, "text": "several standard benchmarks"}, {"st": 131, "ed": 133, "text": "small LU"}, {"st": 141, "ed": 143, "text": "search space"}]
[{"st": 1, "ed": 3, "text": "Decidable Theory"}, {"st": 6, "ed": 8, "text": "Unbounded Size"}, {"st": 9, "ed": 11, "text": "Arbitrary Height"}]
[{"st": 8, "ed": 10, "text": "arbitrary height"}, {"st": 16, "ed": 18, "text": "satisfiability problem"}, {"st": 21, "ed": 23, "text": "free formulas"}, {"st": 28, "ed": 32, "text": "imperative software data structure"}, {"st": 33, "ed": 35, "text": "implements sets"}, {"st": 37, "ed": 39, "text": "several levels"}, {"st": 73, "ed": 75, "text": "binary trees"}, {"st": 110, "ed": 112, "text": "dynamic size"}, {"st": 122, "ed": 124, "text": "different layers"}, {"st": 129, "ed": 131, "text": "dynamic height"}, {"st": 137, "ed": 140, "text": "arbitrary many levels"}, {"st": 142, "ed": 144, "text": "first contribution"}, {"st": 149, "ed": 151, "text": "theory TSL"}, {"st": 156, "ed": 159, "text": "heap memory layout"}, {"st": 163, "ed": 165, "text": "arbitrary height"}, {"st": 167, "ed": 169, "text": "second contribution"}, {"st": 171, "ed": 173, "text": "decision procedure"}, {"st": 175, "ed": 178, "text": "satisfiability prob- lem"}, {"st": 181, "ed": 184, "text": "free TSL formulas"}, {"st": 186, "ed": 188, "text": "last contribution"}, {"st": 192, "ed": 194, "text": "formal verification"}, {"st": 196, "ed": 199, "text": "practical skiplist implementation"}, {"st": 201, "ed": 203, "text": "decision procedure"}]
[]
[{"st": 3, "ed": 5, "text": "process behaviour"}, {"st": 6, "ed": 8, "text": "spatial aspects"}, {"st": 17, "ed": 19, "text": "Computer Science"}, {"st": 25, "ed": 28, "text": "collective adaptive systems"}, {"st": 41, "ed": 43, "text": "physical space"}, {"st": 44, "ed": 47, "text": "Traditional verification techniques"}, {"st": 53, "ed": 55, "text": "temporal evolution"}, {"st": 78, "ed": 80, "text": "physical space"}, {"st": 84, "ed": 86, "text": "appropriate logic"}, {"st": 92, "ed": 94, "text": "topological interpretations"}, {"st": 95, "ed": 97, "text": "modal logics"}, {"st": 115, "ed": 117, "text": "topological definitions"}, {"st": 120, "ed": 122, "text": "general setting"}, {"st": 146, "ed": 148, "text": "efficient model"}, {"st": 158, "ed": 160, "text": "concept tool"}]
[{"st": 0, "ed": 2, "text": "Decidability Results"}, {"st": 4, "ed": 6, "text": "Boundedness Problem"}]
[{"st": 5, "ed": 7, "text": "boundedness problem"}, {"st": 12, "ed": 14, "text": "point recursion"}, {"st": 32, "ed": 34, "text": "formula phi(X"}, {"st": 50, "ed": 52, "text": "point recursion"}, {"st": 70, "ed": 73, "text": "uniform finite bound"}, {"st": 84, "ed": 86, "text": "fixed point"}, {"st": 96, "ed": 98, "text": "exact complexity"}, {"st": 107, "ed": 109, "text": "theoretic techniques"}, {"st": 111, "ed": 114, "text": "key result extends"}, {"st": 120, "ed": 122, "text": "theoretic interpretations"}, {"st": 128, "ed": 130, "text": "boundedness problem"}, {"st": 136, "ed": 138, "text": "order logic"}, {"st": 147, "ed": 150, "text": "fixed finite tree"}, {"st": 153, "ed": 155, "text": "Further model"}, {"st": 156, "ed": 159, "text": "theoretic transfer arguments"}, {"st": 165, "ed": 167, "text": "decidability results"}, {"st": 174, "ed": 176, "text": "order logic"}, {"st": 179, "ed": 181, "text": "new ones"}]
[{"st": 3, "ed": 5, "text": "Concurrent Imperative"}, {"st": 7, "ed": 9, "text": "Session Types"}]
[{"st": 0, "ed": 2, "text": "Concurrent C0"}, {"st": 4, "ed": 7, "text": "imperative programming language"}, {"st": 9, "ed": 11, "text": "C family"}, {"st": 14, "ed": 16, "text": "typed message"}, {"st": 17, "ed": 19, "text": "passing concurrency"}, {"st": 23, "ed": 25, "text": "semantics implements"}, {"st": 40, "ed": 42, "text": "blocking input"}, {"st": 44, "ed": 46, "text": "key idea"}, {"st": 49, "ed": 51, "text": "message reception"}, {"st": 57, "ed": 59, "text": "receive commands"}, {"st": 76, "ed": 78, "text": "intermediate language"}, {"st": 82, "ed": 84, "text": "blocking language"}, {"st": 92, "ed": 95, "text": "several benchmark programs"}, {"st": 103, "ed": 105, "text": "abstract measure"}, {"st": 123, "ed": 125, "text": "practical benefit"}]
[{"st": 7, "ed": 9, "text": "General Case"}, {"st": 10, "ed": 12, "text": "Long Version"}]
[{"st": 5, "ed": 7, "text": "observable properties"}, {"st": 9, "ed": 11, "text": "quantitative flavour"}, {"st": 17, "ed": 19, "text": "computational objects"}, {"st": 28, "ed": 30, "text": "partial orders"}, {"st": 41, "ed": 43, "text": "order programs"}, {"st": 45, "ed": 47, "text": "natural notion"}, {"st": 53, "ed": 55, "text": "context distance"}, {"st": 57, "ed": 59, "text": "metric analogue"}, {"st": 62, "ed": 64, "text": "context equivalence"}, {"st": 72, "ed": 74, "text": "main properties"}, {"st": 76, "ed": 78, "text": "context distance"}, {"st": 113, "ed": 116, "text": "context distance trivializes"}, {"st": 119, "ed": 121, "text": "sufficient condition"}, {"st": 127, "ed": 129, "text": "context distance"}, {"st": 153, "ed": 155, "text": "derive pseudometrics"}]
[{"st": 0, "ed": 3, "text": "Finitary Deduction Systems"}]
[{"st": 0, "ed": 2, "text": "Cryptographic protocols"}, {"st": 8, "ed": 10, "text": "distributed systems"}, {"st": 12, "ed": 14, "text": "formal analysis"}, {"st": 22, "ed": 24, "text": "focus points"}, {"st": 26, "ed": 28, "text": "security community"}, {"st": 39, "ed": 41, "text": "first group"}, {"st": 48, "ed": 50, "text": "security properties"}, {"st": 58, "ed": 60, "text": "decision procedures"}, {"st": 69, "ed": 71, "text": "line attackers"}, {"st": 74, "ed": 76, "text": "second group"}, {"st": 80, "ed": 82, "text": "equivalence properties"}, {"st": 91, "ed": 93, "text": "decision procedures"}, {"st": 100, "ed": 102, "text": "offline attacker"}, {"st": 112, "ed": 114, "text": "deduction system"}, {"st": 117, "ed": 119, "text": "possible actions"}, {"st": 130, "ed": 133, "text": "finitary deduction systems"}, {"st": 144, "ed": 147, "text": "such deduction systems"}, {"st": 149, "ed": 151, "text": "equivalence properties"}, {"st": 154, "ed": 156, "text": "line attackers"}, {"st": 161, "ed": 163, "text": "reachability properties"}, {"st": 165, "ed": 167, "text": "same setting"}]
[{"st": 0, "ed": 3, "text": "Dynamic Backward Slicing"}, {"st": 4, "ed": 7, "text": "Rewriting Logic Computations"}]
[{"st": 0, "ed": 2, "text": "Trace slicing"}, {"st": 8, "ed": 11, "text": "execution trace analysis"}, {"st": 16, "ed": 18, "text": "program debugging"}, {"st": 30, "ed": 32, "text": "backward trace"}, {"st": 43, "ed": 45, "text": "Logic theories"}, {"st": 47, "ed": 50, "text": "trace slicing technique"}, {"st": 56, "ed": 58, "text": "rewrite sequences"}, {"st": 59, "ed": 61, "text": "equational axioms"}, {"st": 82, "ed": 84, "text": "data dependencies"}, {"st": 87, "ed": 89, "text": "useless data"}, {"st": 94, "ed": 96, "text": "final result"}, {"st": 108, "ed": 111, "text": "large system computations"}, {"st": 118, "ed": 120, "text": "example traces"}, {"st": 121, "ed": 123, "text": "Maude model"}]
[{"st": 3, "ed": 5, "text": "Quantum Processes"}, {"st": 6, "ed": 8, "text": "Unifying Quantum"}, {"st": 9, "ed": 11, "text": "Classical Computing"}]
[{"st": 5, "ed": 7, "text": "quantum processes"}, {"st": 11, "ed": 13, "text": "quantum generalization"}, {"st": 14, "ed": 17, "text": "process algebra ACP"}, {"st": 20, "ed": 22, "text": "Communicating Processes"}, {"st": 30, "ed": 33, "text": "quantum process configuration"}, {"st": 45, "ed": 48, "text": "relative independent part"}, {"st": 50, "ed": 52, "text": "structural part"}, {"st": 56, "ed": 58, "text": "quantum part"}, {"st": 68, "ed": 70, "text": "complete theory"}, {"st": 74, "ed": 76, "text": "structural properties"}, {"st": 78, "ed": 80, "text": "structural part"}, {"st": 85, "ed": 87, "text": "quantum part"}, {"st": 105, "ed": 107, "text": "basic theory"}, {"st": 108, "ed": 110, "text": "quantum mechanics"}, {"st": 116, "ed": 118, "text": "strong bisimularity"}, {"st": 119, "ed": 121, "text": "quantum processes"}, {"st": 125, "ed": 127, "text": "weak bisimularity"}, {"st": 130, "ed": 132, "text": "silent step"}, {"st": 133, "ed": 136, "text": "abstract internal computations"}, {"st": 137, "ed": 139, "text": "quantum processes"}, {"st": 143, "ed": 145, "text": "quantum bisimularity"}, {"st": 146, "ed": 148, "text": "classical bisimularity"}, {"st": 163, "ed": 165, "text": "quantum processes"}, {"st": 174, "ed": 176, "text": "quantum information"}, {"st": 179, "ed": 181, "text": "classical information"}, {"st": 186, "ed": 188, "text": "classical computing"}, {"st": 200, "ed": 203, "text": "quantum communication protocols"}]
[{"st": 1, "ed": 4, "text": "Modal Transition Systems"}]
[{"st": 0, "ed": 2, "text": "Specification theories"}, {"st": 8, "ed": 11, "text": "driven development processes"}, {"st": 15, "ed": 17, "text": "software systems"}, {"st": 21, "ed": 23, "text": "considerable attention"}, {"st": 24, "ed": 27, "text": "Current specification theories"}, {"st": 41, "ed": 43, "text": "inevitable approximation"}, {"st": 51, "ed": 53, "text": "fundamental unpredictability"}, {"st": 54, "ed": 56, "text": "hardware platforms"}, {"st": 73, "ed": 75, "text": "actual system"}, {"st": 83, "ed": 86, "text": "modern software systems"}, {"st": 91, "ed": 94, "text": "first specification theory"}, {"st": 98, "ed": 100, "text": "quantitative aspects"}, {"st": 104, "ed": 106, "text": "implementation process"}, {"st": 113, "ed": 115, "text": "qualitative setting"}, {"st": 118, "ed": 121, "text": "quantitative specification framework"}, {"st": 123, "ed": 126, "text": "modal transition systems"}, {"st": 128, "ed": 130, "text": "formal model"}, {"st": 135, "ed": 138, "text": "labeled transition systems"}, {"st": 140, "ed": 142, "text": "additional feature"}, {"st": 146, "ed": 148, "text": "optional behavior"}, {"st": 172, "ed": 174, "text": "quantitative setting"}, {"st": 183, "ed": 186, "text": "modal transition systems"}, {"st": 190, "ed": 192, "text": "quantitative versions"}, {"st": 193, "ed": 195, "text": "parallel composition"}, {"st": 211, "ed": 213, "text": "Boolean setting"}]
[{"st": 2, "ed": 4, "text": "Descriptive Complexity"}, {"st": 7, "ed": 10, "text": "Order HORN Logics"}]
[{"st": 26, "ed": 28, "text": "order HORN"}, {"st": 46, "ed": 49, "text": "order universal quantifiers"}, {"st": 53, "ed": 55, "text": "order atoms"}, {"st": 59, "ed": 61, "text": "HORN clauses"}, {"st": 62, "ed": 64, "text": "DATALOG rules"}, {"st": 79, "ed": 82, "text": "fixed point logic"}]
[{"st": 2, "ed": 4, "text": "Timed Automata"}, {"st": 6, "ed": 10, "text": "Unbounded Discrete Data Structures"}]
[{"st": 4, "ed": 6, "text": "verification problems"}, {"st": 11, "ed": 15, "text": "unbounded discrete data structures"}, {"st": 25, "ed": 27, "text": "pushdown stack"}, {"st": 35, "ed": 37, "text": "strong model"}, {"st": 47, "ed": 49, "text": "time programs"}, {"st": 59, "ed": 61, "text": "reachability problem"}, {"st": 77, "ed": 80, "text": "timed pushdown automata"}, {"st": 83, "ed": 86, "text": "language inclusion problem"}]
[{"st": 1, "ed": 4, "text": "Abstract Game Semantics"}]
[{"st": 6, "ed": 10, "text": "recent concurrent game semantics"}, {"st": 11, "ed": 14, "text": "process algebra CCS"}, {"st": 21, "ed": 23, "text": "basic characteristics"}, {"st": 25, "ed": 28, "text": "actor computational model"}, {"st": 31, "ed": 33, "text": "reductive semantics"}, {"st": 40, "ed": 44, "text": "abstract concurrent game semantics"}, {"st": 49, "ed": 51, "text": "algebraic structure"}, {"st": 62, "ed": 65, "text": "innocent presheaf semantics"}, {"st": 68, "ed": 71, "text": "concurrent game semantics"}]
[{"st": 5, "ed": 8, "text": "SAT Witness Generator"}]
[{"st": 2, "ed": 4, "text": "random simulation"}, {"st": 6, "ed": 8, "text": "predominant approach"}, {"st": 13, "ed": 15, "text": "functional verification"}, {"st": 16, "ed": 19, "text": "complex digital designs"}, {"st": 28, "ed": 30, "text": "key factors"}, {"st": 38, "ed": 40, "text": "test vectors"}, {"st": 62, "ed": 64, "text": "second problem"}, {"st": 82, "ed": 84, "text": "almost-)uniform generation"}, {"st": 87, "ed": 90, "text": "large Boolean constraints"}, {"st": 94, "ed": 97, "text": "strong theoretical guarantees"}, {"st": 101, "ed": 103, "text": "generated solutions"}]
[{"st": 3, "ed": 5, "text": "Infinitary Formulas"}, {"st": 7, "ed": 10, "text": "Stable Model Semantics"}]
[{"st": 0, "ed": 2, "text": "Propositional formulas"}, {"st": 6, "ed": 8, "text": "intuitionistic logic"}, {"st": 26, "ed": 29, "text": "same stable models"}, {"st": 35, "ed": 37, "text": "propositional formulas"}, {"st": 39, "ed": 41, "text": "long conjunctions"}, {"st": 67, "ed": 69, "text": "Logic Programming"}]
[{"st": 2, "ed": 6, "text": "Linguistic First Order Logic"}, {"st": 8, "ed": 12, "text": "Linear Symmetrical Hedge Algebra"}]
[{"st": 6, "ed": 10, "text": "linguistic first order logic"}, {"st": 11, "ed": 13, "text": "truth value"}, {"st": 15, "ed": 19, "text": "linear symmetrical hedge algebra"}, {"st": 23, "ed": 25, "text": "basic components"}, {"st": 26, "ed": 30, "text": "linguistic first order logic"}, {"st": 39, "ed": 41, "text": "resolution principle"}, {"st": 50, "ed": 54, "text": "contradictory linguistic truth values"}, {"st": 56, "ed": 58, "text": "linguistic information"}, {"st": 64, "ed": 66, "text": "linguistic logic"}, {"st": 82, "ed": 84, "text": "natural approximation"}, {"st": 86, "ed": 89, "text": "resolution inference rule"}]
[{"st": 2, "ed": 4, "text": "Event Structures"}, {"st": 5, "ed": 8, "text": "History Preserving Bisimulation"}]
[{"st": 0, "ed": 2, "text": "Event structures"}, {"st": 3, "ed": 5, "text": "concurrent processes"}, {"st": 14, "ed": 16, "text": "behavioural relations"}, {"st": 25, "ed": 28, "text": "prime event structures"}, {"st": 29, "ed": 31, "text": "many variants"}, {"st": 32, "ed": 34, "text": "event structures"}, {"st": 38, "ed": 41, "text": "different behavioural relations"}, {"st": 49, "ed": 51, "text": "expressive power"}, {"st": 55, "ed": 57, "text": "possible benefits"}, {"st": 61, "ed": 64, "text": "expressive event structure"}, {"st": 70, "ed": 72, "text": "compact representation"}, {"st": 74, "ed": 76, "text": "same behaviour"}, {"st": 85, "ed": 88, "text": "prime event structure"}, {"st": 102, "ed": 104, "text": "event structure"}, {"st": 133, "ed": 136, "text": "prime event structures"}, {"st": 143, "ed": 146, "text": "asymmetric event structure"}, {"st": 150, "ed": 152, "text": "asymmetric form"}, {"st": 154, "ed": 156, "text": "conflict relation"}, {"st": 163, "ed": 166, "text": "flow event structure"}, {"st": 171, "ed": 173, "text": "disjunctive causality"}, {"st": 189, "ed": 191, "text": "event structure"}, {"st": 196, "ed": 198, "text": "single event"}, {"st": 201, "ed": 203, "text": "original behaviour"}, {"st": 205, "ed": 207, "text": "successive application"}, {"st": 209, "ed": 211, "text": "folding operation"}, {"st": 214, "ed": 218, "text": "minimal size event structure"}, {"st": 226, "ed": 228, "text": "folding operation"}, {"st": 233, "ed": 238, "text": "different minimal size event structures"}, {"st": 243, "ed": 245, "text": "negative implication"}, {"st": 247, "ed": 249, "text": "potential use"}, {"st": 251, "ed": 255, "text": "minimal size event structure"}, {"st": 257, "ed": 259, "text": "canonical representation"}]
[{"st": 0, "ed": 2, "text": "Groupoid Semantics"}, {"st": 3, "ed": 5, "text": "Thermal Computing"}]
[{"st": 1, "ed": 3, "text": "groupoid semantics"}, {"st": 11, "ed": 13, "text": "thermal degrees"}, {"st": 21, "ed": 23, "text": "syntactic model"}, {"st": 29, "ed": 31, "text": "algebraic characterization"}, {"st": 37, "ed": 39, "text": "encryption function"}, {"st": 51, "ed": 54, "text": "linear representation theory"}, {"st": 57, "ed": 60, "text": "underlying quantum semantics"}, {"st": 64, "ed": 66, "text": "first time"}, {"st": 67, "ed": 70, "text": "functorial classical model"}, {"st": 71, "ed": 73, "text": "quantum teleportation"}, {"st": 74, "ed": 77, "text": "other quantum phenomena"}]
[{"st": 2, "ed": 4, "text": "Reveals Relation"}, {"st": 5, "ed": 7, "text": "Occurrence Nets"}]
[{"st": 0, "ed": 3, "text": "Petri net unfoldings"}, {"st": 5, "ed": 7, "text": "useful tool"}, {"st": 11, "ed": 13, "text": "space explosion"}, {"st": 16, "ed": 18, "text": "related tasks"}, {"st": 30, "ed": 32, "text": "causal precedence"}, {"st": 45, "ed": 47, "text": "data structure"}, {"st": 52, "ed": 54, "text": "following relation"}, {"st": 61, "ed": 64, "text": "event b iff"}, {"st": 85, "ed": 87, "text": "a. Knowledge"}, {"st": 88, "ed": 90, "text": "reveals facilitates"}, {"st": 96, "ed": 98, "text": "observable systems"}, {"st": 117, "ed": 119, "text": "concise representations"}, {"st": 125, "ed": 127, "text": "reveals relation"}, {"st": 134, "ed": 136, "text": "fault diagnosis"}, {"st": 143, "ed": 145, "text": "reveals relation"}, {"st": 157, "ed": 159, "text": "unfolding U"}, {"st": 161, "ed": 165, "text": "safe Petri net N"}, {"st": 167, "ed": 170, "text": "finite prefix P"}, {"st": 180, "ed": 182, "text": "reveals b."}, {"st": 202, "ed": 204, "text": "efficient algorithm"}]
[{"st": 0, "ed": 2, "text": "Ticket Entailment"}]
[{"st": 5, "ed": 7, "text": "Ticket Entailment"}, {"st": 17, "ed": 19, "text": "relevance logic"}, {"st": 31, "ed": 33, "text": "type inhabitation"}, {"st": 37, "ed": 39, "text": "combinatory logic"}, {"st": 41, "ed": 44, "text": "partial basis BB'IW"}, {"st": 48, "ed": 50, "text": "equivalent problem"}, {"st": 51, "ed": 53, "text": "type inhabitation"}, {"st": 67, "ed": 69, "text": "maximal terms"}]
[{"st": 0, "ed": 4, "text": "Bisimulations Meet PCTL Equivalences"}, {"st": 5, "ed": 7, "text": "Probabilistic Automata"}]
[{"st": 0, "ed": 2, "text": "Probabilistic automata"}, {"st": 10, "ed": 12, "text": "formal verification"}, {"st": 15, "ed": 17, "text": "stochastic systems"}, {"st": 18, "ed": 20, "text": "Efficient model"}, {"st": 30, "ed": 32, "text": "used logics"}, {"st": 38, "ed": 42, "text": "probabilistic computation tree logic"}, {"st": 47, "ed": 52, "text": "extension PCTL^*. Various behavioral equivalences"}, {"st": 57, "ed": 59, "text": "powerful tool"}, {"st": 62, "ed": 64, "text": "compositional minimization"}, {"st": 86, "ed": 88, "text": "logical equivalences"}, {"st": 100, "ed": 103, "text": "complete behavioral equivalence"}, {"st": 124, "ed": 126, "text": "novel notions"}, {"st": 127, "ed": 130, "text": "strong bisimulation relations"}, {"st": 135, "ed": 137, "text": "PCTL *"}, {"st": 141, "ed": 143, "text": "weak bisimulations"}, {"st": 147, "ed": 149, "text": "PCTL *"}, {"st": 150, "ed": 152, "text": "next operator"}, {"st": 163, "ed": 165, "text": "simulation preorders"}, {"st": 176, "ed": 178, "text": "behavioral equivalences"}]
[{"st": 5, "ed": 9, "text": "cirquent calculus system CL6"}, {"st": 10, "ed": 12, "text": "computability logic"}]
[{"st": 0, "ed": 2, "text": "Computability logic"}, {"st": 4, "ed": 6, "text": "formal theory"}, {"st": 11, "ed": 14, "text": "article \" Introduction"}, {"st": 18, "ed": 21, "text": "abstract resource semantics"}, {"st": 30, "ed": 33, "text": "basic fragment CL5"}, {"st": 34, "ed": 36, "text": "computability logic"}, {"st": 38, "ed": 40, "text": "present article"}, {"st": 46, "ed": 51, "text": "expressive cirquent calculus system CL6"}, {"st": 55, "ed": 57, "text": "conservative extension"}, {"st": 61, "ed": 64, "text": "classical propositional logic"}]
[{"st": 2, "ed": 5, "text": "Free ExpTime Tableaux"}, {"st": 6, "ed": 8, "text": "Checking Satisfiability"}, {"st": 10, "ed": 12, "text": "Knowledge Base"}, {"st": 14, "ed": 17, "text": "Description Logic SHI"}]
[{"st": 3, "ed": 5, "text": "first cut"}, {"st": 6, "ed": 8, "text": "free ExpTime"}, {"st": 11, "ed": 14, "text": "tableau decision procedure"}, {"st": 19, "ed": 21, "text": "knowledge base"}, {"st": 23, "ed": 26, "text": "description logic SHI"}, {"st": 34, "ed": 36, "text": "transitive roles"}, {"st": 37, "ed": 39, "text": "inverse roles"}, {"st": 40, "ed": 42, "text": "role hierarchies"}]
[{"st": 1, "ed": 4, "text": "Embedded C Software"}, {"st": 5, "ed": 7, "text": "Timing Constraints"}, {"st": 9, "ed": 12, "text": "Untimed Model Checker"}]
[{"st": 6, "ed": 8, "text": "home appliances"}, {"st": 9, "ed": 11, "text": "critical systems"}, {"st": 13, "ed": 15, "text": "medical devices"}, {"st": 20, "ed": 22, "text": "timing constraints"}, {"st": 38, "ed": 40, "text": "model checker"}, {"st": 45, "ed": 48, "text": "embedded C programs"}, {"st": 55, "ed": 57, "text": "discrete time"}, {"st": 60, "ed": 62, "text": "code annotations"}, {"st": 64, "ed": 66, "text": "annotated code"}, {"st": 73, "ed": 77, "text": "manipulates auxiliary timer variables"}, {"st": 86, "ed": 90, "text": "untimed software model checker"}, {"st": 103, "ed": 105, "text": "same way"}, {"st": 108, "ed": 110, "text": "same time"}, {"st": 111, "ed": 114, "text": "untimed system requirements"}, {"st": 130, "ed": 132, "text": "case study"}, {"st": 139, "ed": 141, "text": "pulse oximeter"}, {"st": 143, "ed": 146, "text": "noninvasive medical device"}, {"st": 149, "ed": 151, "text": "oxygen saturation"}, {"st": 152, "ed": 154, "text": "arterial blood"}]
[{"st": 2, "ed": 4, "text": "passing CCS"}, {"st": 10, "ed": 12, "text": "Concurrent Systems"}]
[{"st": 7, "ed": 9, "text": "theory CCS"}, {"st": 17, "ed": 19, "text": "passing CCTS"}, {"st": 33, "ed": 35, "text": "data values"}, {"st": 38, "ed": 40, "text": "nonsequential semantics"}, {"st": 44, "ed": 46, "text": "operational approach"}, {"st": 49, "ed": 51, "text": "concurrent model"}, {"st": 53, "ed": 56, "text": "weak barbed congruence"}, {"st": 58, "ed": 62, "text": "localized early weak bisimilarity"}, {"st": 67, "ed": 69, "text": "latter relation"}, {"st": 83, "ed": 85, "text": "potential applications"}, {"st": 101, "ed": 103, "text": "programming language"}, {"st": 107, "ed": 111, "text": "C / C++ concurrency"}, {"st": 118, "ed": 120, "text": "operational semantics"}, {"st": 126, "ed": 129, "text": "relaxed memory models"}, {"st": 134, "ed": 136, "text": "guarantee property"}]
[{"st": 2, "ed": 5, "text": "Order Propositional Satisfiability"}]
[{"st": 3, "ed": 7, "text": "static program analyser searches"}, {"st": 16, "ed": 18, "text": "candidate solutions"}, {"st": 20, "ed": 23, "text": "candidate validation technique"}, {"st": 27, "ed": 29, "text": "heuristic reduces"}, {"st": 32, "ed": 34, "text": "order problem"}, {"st": 53, "ed": 57, "text": "SAT / SMT solver"}, {"st": 62, "ed": 64, "text": "monolithic design"}, {"st": 65, "ed": 67, "text": "such analyses"}, {"st": 85, "ed": 88, "text": "latter causes changes"}, {"st": 90, "ed": 92, "text": "whole analysis"}, {"st": 104, "ed": 106, "text": "solver technology"}, {"st": 108, "ed": 112, "text": "SAT / SMT solvers"}, {"st": 114, "ed": 116, "text": "tremendous progress"}, {"st": 123, "ed": 125, "text": "order solvers"}, {"st": 138, "ed": 140, "text": "decidable fragment"}, {"st": 143, "ed": 145, "text": "order logic"}, {"st": 152, "ed": 156, "text": "numerous program analysis problems"}, {"st": 158, "ed": 160, "text": "safety proving"}, {"st": 161, "ed": 163, "text": "bug finding"}, {"st": 168, "ed": 170, "text": "termination proving"}, {"st": 178, "ed": 180, "text": "satisfiability problem"}, {"st": 186, "ed": 188, "text": "Order SAT"}, {"st": 201, "ed": 203, "text": "decision procedure"}, {"st": 206, "ed": 208, "text": "Order SAT"}, {"st": 210, "ed": 212, "text": "program synthesis"}, {"st": 213, "ed": 216, "text": "present experimental evidence"}, {"st": 222, "ed": 225, "text": "program analysis problems"}]
[{"st": 4, "ed": 6, "text": "computational effects"}]
[{"st": 2, "ed": 7, "text": "functional programming languages imperative features"}, {"st": 10, "ed": 12, "text": "computational effects"}, {"st": 19, "ed": 22, "text": "functional lan- guages"}, {"st": 29, "ed": 31, "text": "decorated logic"}, {"st": 33, "ed": 36, "text": "rigorous for- malism"}, {"st": 41, "ed": 43, "text": "operation signatures"}, {"st": 46, "ed": 48, "text": "program properties"}, {"st": 51, "ed": 53, "text": "computational effects"}, {"st": 63, "ed": 65, "text": "Coq libraries"}, {"st": 69, "ed": 71, "text": "program properties"}, {"st": 72, "ed": 74, "text": "decorated settings"}, {"st": 77, "ed": 79, "text": "several effects"}, {"st": 82, "ed": 84, "text": "local state"}, {"st": 103, "ed": 105, "text": "several effects"}]
[{"st": 0, "ed": 2, "text": "Program certification"}, {"st": 3, "ed": 5, "text": "computational effects"}]
[{"st": 0, "ed": 2, "text": "Dynamic evaluation"}, {"st": 6, "ed": 8, "text": "computer algebra"}, {"st": 14, "ed": 16, "text": "algebraic numbers"}, {"st": 18, "ed": 20, "text": "linear algebra"}, {"st": 24, "ed": 26, "text": "dynamic evaluation"}, {"st": 42, "ed": 44, "text": "prime number"}, {"st": 50, "ed": 52, "text": "composite number"}, {"st": 57, "ed": 59, "text": "dynamic evaluation"}, {"st": 60, "ed": 63, "text": "modern computing languages"}, {"st": 67, "ed": 69, "text": "exceptions mechanism"}, {"st": 81, "ed": 83, "text": "proof system"}, {"st": 104, "ed": 106, "text": "core part"}, {"st": 108, "ed": 110, "text": "proof system"}, {"st": 114, "ed": 116, "text": "proof system"}, {"st": 118, "ed": 120, "text": "state effect"}, {"st": 121, "ed": 123, "text": "imperative languages"}, {"st": 128, "ed": 130, "text": "categorical notion"}, {"st": 134, "ed": 136, "text": "proof systems"}, {"st": 140, "ed": 143, "text": "Coq proof assistant"}, {"st": 157, "ed": 159, "text": "same time"}]
[{"st": 8, "ed": 10, "text": "model checking"}, {"st": 11, "ed": 13, "text": "satisfiability problem"}]
[{"st": 4, "ed": 6, "text": "model checking"}, {"st": 8, "ed": 10, "text": "satisfiability problem"}, {"st": 12, "ed": 14, "text": "Dynamic Logic"}, {"st": 15, "ed": 18, "text": "Propositional Assignments DL"}, {"st": 21, "ed": 23, "text": "Coalition Logic"}, {"st": 24, "ed": 26, "text": "Propositional Control"}, {"st": 27, "ed": 29, "text": "Delegation DCL"}, {"st": 89, "ed": 92, "text": "van der Hoek"}]
[{"st": 0, "ed": 2, "text": "Data refinement"}, {"st": 3, "ed": 5, "text": "true concurrency"}]
[{"st": 3, "ed": 9, "text": "modern systems exhibit sophisticated concurrent behaviour"}, {"st": 11, "ed": 14, "text": "several system components"}, {"st": 18, "ed": 20, "text": "system state"}, {"st": 23, "ed": 25, "text": "grained atomicity"}, {"st": 26, "ed": 28, "text": "Many systems"}, {"st": 33, "ed": 35, "text": "core processors"}, {"st": 38, "ed": 40, "text": "time controllers"}, {"st": 44, "ed": 46, "text": "concurrent behaviour"}, {"st": 48, "ed": 50, "text": "multiple events"}, {"st": 57, "ed": 59, "text": "data refinement"}, {"st": 73, "ed": 75, "text": "level operators"}, {"st": 79, "ed": 82, "text": "deterministic expression evaluation"}, {"st": 98, "ed": 100, "text": "data refinement"}, {"st": 104, "ed": 106, "text": "continuous systems"}, {"st": 115, "ed": 117, "text": "forward simulation"}, {"st": 122, "ed": 125, "text": "forward simulation rule"}, {"st": 131, "ed": 134, "text": "data refinement definition"}, {"st": 141, "ed": 144, "text": "forward simulation proofs"}, {"st": 148, "ed": 150, "text": "parallel composition"}]
[]
[{"st": 3, "ed": 6, "text": "modern software systems"}, {"st": 10, "ed": 12, "text": "reconfiguration mechanisms"}, {"st": 15, "ed": 17, "text": "dynamic evolution"}, {"st": 19, "ed": 21, "text": "execution configurations"}, {"st": 25, "ed": 27, "text": "external stimulus"}, {"st": 28, "ed": 31, "text": "internal performance measures"}, {"st": 34, "ed": 36, "text": "such systems"}, {"st": 40, "ed": 42, "text": "transition systems"}, {"st": 47, "ed": 49, "text": "different configurations"}, {"st": 58, "ed": 60, "text": "en- dowed"}, {"st": 72, "ed": 74, "text": "order structure"}, {"st": 86, "ed": 88, "text": "corresponding configuration"}, {"st": 89, "ed": 91, "text": "Hybrid logics"}, {"st": 96, "ed": 98, "text": "modal description"}, {"st": 106, "ed": 108, "text": "specific states"}, {"st": 111, "ed": 113, "text": "generic framework"}, {"st": 130, "ed": 132, "text": "suitable notions"}, {"st": 139, "ed": 142, "text": "hybrid logic specifications"}, {"st": 146, "ed": 148, "text": "design discipline"}, {"st": 160, "ed": 162, "text": "distinctive point"}, {"st": 170, "ed": 173, "text": "specific hybrid logic"}, {"st": 183, "ed": 185, "text": "hybridised logics"}, {"st": 187, "ed": 190, "text": "standard specification logics"}, {"st": 191, "ed": 193, "text": "e.g. propositional"}, {"st": 204, "ed": 206, "text": "hybrid features"}, {"st": 210, "ed": 212, "text": "systematic way"}]
[{"st": 0, "ed": 2, "text": "Full abstraction"}]
[{"st": 1, "ed": 3, "text": "previous work"}, {"st": 19, "ed": 22, "text": "innocent presheaf semantics"}, {"st": 25, "ed": 28, "text": "concurrent game semantics"}, {"st": 35, "ed": 37, "text": "behavioural equivalence"}, {"st": 42, "ed": 44, "text": "CCS processes"}, {"st": 57, "ed": 60, "text": "new algebraic notion"}, {"st": 82, "ed": 85, "text": "labelled transition systems"}, {"st": 95, "ed": 97, "text": "functional bisimulation"}]
[{"st": 3, "ed": 5, "text": "HOL Light"}]
[{"st": 0, "ed": 3, "text": "Hierarchical proof trees"}, {"st": 11, "ed": 14, "text": "ordinary proof trees"}, {"st": 26, "ed": 28, "text": "additional structure"}, {"st": 40, "ed": 42, "text": "particular portions"}, {"st": 53, "ed": 55, "text": "complementary methods"}, {"st": 59, "ed": 61, "text": "HOL Light"}, {"st": 74, "ed": 76, "text": "first method"}, {"st": 77, "ed": 79, "text": "tactic recording"}, {"st": 90, "ed": 92, "text": "hierarchical tree"}, {"st": 96, "ed": 99, "text": "tactic proof script"}, {"st": 104, "ed": 106, "text": "second method"}, {"st": 107, "ed": 109, "text": "proof recording"}, {"st": 113, "ed": 116, "text": "HOL Light kernel"}, {"st": 118, "ed": 121, "text": "hierachical proof trees"}, {"st": 139, "ed": 141, "text": "recorded objects"}]
[{"st": 2, "ed": 4, "text": "Well Extension"}, {"st": 5, "ed": 8, "text": "Partial Well Orderings"}]
[{"st": 7, "ed": 9, "text": "well extension"}, {"st": 29, "ed": 31, "text": "R >"}, {"st": 46, "ed": 48, "text": "linear extension"}, {"st": 49, "ed": 51, "text": "< A"}, {"st": 52, "ed": 54, "text": "R >"}, {"st": 67, "ed": 69, "text": "unordered subset"}]
[{"st": 3, "ed": 6, "text": "Polynomial Invariant Generation"}]
[{"st": 1, "ed": 3, "text": "abstract interpretation"}, {"st": 8, "ed": 10, "text": "specific kinds"}, {"st": 28, "ed": 30, "text": "reachable sets"}, {"st": 53, "ed": 57, "text": "usual forward fixpoint computation"}, {"st": 58, "ed": 61, "text": "numerical abstract domains"}, {"st": 80, "ed": 82, "text": "polynomial invariant"}, {"st": 84, "ed": 86, "text": "invariant generation"}, {"st": 102, "ed": 104, "text": "state space"}, {"st": 109, "ed": 111, "text": "target property"}, {"st": 119, "ed": 121, "text": "program semantics"}, {"st": 127, "ed": 130, "text": "inductive polynomial invariant"}, {"st": 131, "ed": 133, "text": "numerical optimization"}, {"st": 135, "ed": 137, "text": "method applies"}, {"st": 139, "ed": 141, "text": "wide set"}, {"st": 160, "ed": 162, "text": "polynomial updates"}, {"st": 163, "ed": 166, "text": "piecewise polynomial controllers"}, {"st": 172, "ed": 174, "text": "various programs"}]
[{"st": 2, "ed": 4, "text": "Topological Semantics"}]
[{"st": 6, "ed": 8, "text": "deductive explosion"}, {"st": 19, "ed": 21, "text": "inconsistent set"}, {"st": 24, "ed": 26, "text": "Paraconsistent logic"}, {"st": 29, "ed": 31, "text": "other hand"}, {"st": 34, "ed": 36, "text": "umbrella term"}, {"st": 37, "ed": 39, "text": "logical systems"}, {"st": 41, "ed": 44, "text": "logical consequence relation"}, {"st": 58, "ed": 61, "text": "different topological spaces"}]
[{"st": 0, "ed": 2, "text": "Finite countermodels"}, {"st": 3, "ed": 5, "text": "safety verification"}, {"st": 6, "ed": 9, "text": "parameterized tree systems"}]
[{"st": 8, "ed": 10, "text": "safety properties"}, {"st": 11, "ed": 13, "text": "parameterized systems"}, {"st": 15, "ed": 17, "text": "tree topology"}, {"st": 19, "ed": 21, "text": "verification problem"}, {"st": 26, "ed": 28, "text": "logical problem"}, {"st": 31, "ed": 33, "text": "finite countermodel"}, {"st": 37, "ed": 39, "text": "order formula"}, {"st": 45, "ed": 48, "text": "generic finite model"}, {"st": 52, "ed": 55, "text": "finite countermodel method"}, {"st": 63, "ed": 66, "text": "regular tree model"}, {"st": 73, "ed": 75, "text": "monotonic abstraction"}, {"st": 76, "ed": 79, "text": "backwards symbolic reachability"}, {"st": 81, "ed": 83, "text": "practical efficiency"}]
[{"st": 0, "ed": 3, "text": "Stochastic Timed Automata"}]
[{"st": 1, "ed": 4, "text": "stochastic timed automaton"}, {"st": 7, "ed": 9, "text": "stochastic process"}, {"st": 12, "ed": 14, "text": "timed automaton"}, {"st": 20, "ed": 22, "text": "discrete choices"}, {"st": 31, "ed": 33, "text": "sure model"}, {"st": 34, "ed": 36, "text": "checking problem"}, {"st": 45, "ed": 49, "text": "stochastic timed automaton A"}, {"st": 74, "ed": 76, "text": "several classes"}, {"st": 89, "ed": 91, "text": "proof relies"}, {"st": 96, "ed": 98, "text": "finite abstraction"}, {"st": 101, "ed": 103, "text": "thick graph"}, {"st": 109, "ed": 112, "text": "finite Markov chain"}, {"st": 122, "ed": 124, "text": "sure model"}, {"st": 125, "ed": 127, "text": "checking problem"}, {"st": 150, "ed": 152, "text": "large classes"}, {"st": 155, "ed": 158, "text": "single- clock automata"}, {"st": 164, "ed": 166, "text": "reactive automata"}, {"st": 171, "ed": 174, "text": "article gather tools"}, {"st": 177, "ed": 179, "text": "time verification"}, {"st": 180, "ed": 182, "text": "probabilistic verification"}, {"st": 186, "ed": 188, "text": "topological games"}, {"st": 190, "ed": 192, "text": "timed automata"}]
[{"st": 3, "ed": 5, "text": "Coq library"}, {"st": 9, "ed": 11, "text": "rewrite relations"}, {"st": 16, "ed": 18, "text": "automated verification"}, {"st": 19, "ed": 21, "text": "termination certificates"}]
[{"st": 3, "ed": 5, "text": "important property"}, {"st": 14, "ed": 16, "text": "proof assistants"}, {"st": 21, "ed": 23, "text": "active subject"}, {"st": 29, "ed": 31, "text": "complete formalism"}, {"st": 37, "ed": 39, "text": "many methods"}, {"st": 60, "ed": 62, "text": "important issue"}, {"st": 69, "ed": 73, "text": "library formalizing important results"}, {"st": 86, "ed": 89, "text": "proof assistant Coq"}, {"st": 97, "ed": 99, "text": "automated verification"}, {"st": 100, "ed": 102, "text": "termination certificates"}, {"st": 106, "ed": 108, "text": "termination tools"}]
[{"st": 3, "ed": 7, "text": "Preference Set Constraint Atoms"}]
[{"st": 6, "ed": 9, "text": "Answer Set Programming"}, {"st": 10, "ed": 14, "text": "Preference Set Constraint Programming"}, {"st": 19, "ed": 21, "text": "general formalism"}, {"st": 28, "ed": 32, "text": "extends Set Constraint Programming"}, {"st": 50, "ed": 52, "text": "constraint atoms"}, {"st": 53, "ed": 55, "text": "measure preference"}, {"st": 56, "ed": 58, "text": "constraint atoms"}, {"st": 61, "ed": 63, "text": "ordered preference"}, {"st": 64, "ed": 66, "text": "constraint atoms"}, {"st": 71, "ed": 74, "text": "set constraint atoms"}, {"st": 83, "ed": 85, "text": "PSC program"}, {"st": 87, "ed": 90, "text": "preferred stable model"}, {"st": 105, "ed": 107, "text": "constraint atoms"}, {"st": 110, "ed": 113, "text": "Answer Set Optimization"}, {"st": 123, "ed": 125, "text": "General Preference"}, {"st": 137, "ed": 139, "text": "constraint atoms"}]
[]
[{"st": 8, "ed": 10, "text": "mathematical theory"}, {"st": 13, "ed": 15, "text": "denotational semantics"}, {"st": 22, "ed": 24, "text": "Scott topology"}, {"st": 25, "ed": 28, "text": "represent data types"}, {"st": 29, "ed": 32, "text": "Scott continuous functions"}, {"st": 33, "ed": 35, "text": "computable functions"}, {"st": 39, "ed": 42, "text": "popular continuous model"}, {"st": 45, "ed": 47, "text": "Covariant Logic"}, {"st": 59, "ed": 62, "text": "Scott continuous functions"}, {"st": 67, "ed": 70, "text": "output inference engines"}, {"st": 94, "ed": 97, "text": "B. Which retractions"}, {"st": 108, "ed": 110, "text": "information systems"}, {"st": 114, "ed": 116, "text": "reflexive logics"}, {"st": 122, "ed": 124, "text": "continuous domains"}, {"st": 129, "ed": 131, "text": "D. How"}, {"st": 133, "ed": 135, "text": "Scott topologies"}, {"st": 136, "ed": 139, "text": "generalized distance functions"}, {"st": 143, "ed": 145, "text": "Scott continuity"}, {"st": 146, "ed": 150, "text": "\" abstract computability \""}, {"st": 171, "ed": 173, "text": "Scott continuity"}, {"st": 174, "ed": 176, "text": "distance functions"}, {"st": 179, "ed": 182, "text": "\\bf relaxed metrics"}, {"st": 198, "ed": 200, "text": "domain subsets"}, {"st": 203, "ed": 205, "text": "negative information"}, {"st": 206, "ed": 208, "text": "domain elements"}, {"st": 210, "ed": 212, "text": "positive answer"}, {"st": 219, "ed": 221, "text": "novel class"}, {"st": 224, "ed": 226, "text": "continuous valuations"}, {"st": 230, "ed": 233, "text": "Scott open sets"}, {"st": 237, "ed": 239, "text": "natural questions"}, {"st": 249, "ed": 251, "text": "novel approach"}, {"st": 264, "ed": 266, "text": "clear justifications"}]
[{"st": 0, "ed": 2, "text": "Clone Theory"}, {"st": 3, "ed": 5, "text": "Algebraic Logic"}]
[{"st": 8, "ed": 10, "text": "many branches"}, {"st": 15, "ed": 17, "text": "universal algebra"}, {"st": 18, "ed": 20, "text": "algebraic logic"}, {"st": 22, "ed": 24, "text": "lambda calculus"}, {"st": 40, "ed": 42, "text": "infinite power"}, {"st": 48, "ed": 50, "text": "right algebras"}, {"st": 56, "ed": 58, "text": "contravariant functors"}, {"st": 75, "ed": 77, "text": "order logic"}, {"st": 99, "ed": 101, "text": "classical treatment"}, {"st": 110, "ed": 112, "text": "fundamental theorems"}, {"st": 115, "ed": 117, "text": "order theory"}]
[{"st": 9, "ed": 11, "text": "order formulas"}]
[{"st": 4, "ed": 6, "text": "order logic"}, {"st": 7, "ed": 9, "text": "monoidal quantifiers"}, {"st": 19, "ed": 21, "text": "neutral letter"}, {"st": 25, "ed": 28, "text": "addition numerical predicate"}, {"st": 33, "ed": 35, "text": "order predicate"}, {"st": 37, "ed": 40, "text": "only numerical predicate"}, {"st": 68, "ed": 71, "text": "neutral letter languages"}, {"st": 77, "ed": 86, "text": "LS[<,+ ] cap N = LS [ < ]"}, {"st": 93, "ed": 96, "text": "Crane Beach conjecture"}, {"st": 100, "ed": 103, "text": "logic LS[<,+ ]"}, {"st": 119, "ed": 121, "text": "FO+MOD[<,+ ]"}, {"st": 123, "ed": 127, "text": "FO+MOD [ < ]"}, {"st": 129, "ed": 131, "text": "cyclic groups"}, {"st": 135, "ed": 137, "text": "open question"}, {"st": 144, "ed": 146, "text": "MOD[<,+ ]"}, {"st": 148, "ed": 152, "text": "MOD [ < ]"}, {"st": 175, "ed": 177, "text": "separation results"}, {"st": 179, "ed": 182, "text": "uniform circuit classes"}, {"st": 187, "ed": 189, "text": "FO[<,+]-uniform CC0"}, {"st": 190, "ed": 192, "text": "FO[<,+]-uniform ACC0"}]
[{"st": 1, "ed": 3, "text": "Deduction Modulo"}, {"st": 8, "ed": 10, "text": "Point Definitions"}]
[{"st": 2, "ed": 4, "text": "coinductive specifications"}, {"st": 9, "ed": 11, "text": "computational systems"}, {"st": 12, "ed": 14, "text": "Such specifications"}, {"st": 16, "ed": 18, "text": "natural rendition"}, {"st": 24, "ed": 26, "text": "point definitions"}, {"st": 28, "ed": 31, "text": "useful formalization device"}, {"st": 34, "ed": 36, "text": "recursive specifications"}, {"st": 58, "ed": 61, "text": "strong monotonicity restrictions"}, {"st": 68, "ed": 70, "text": "rewriting capability"}, {"st": 75, "ed": 78, "text": "point definitions towards"}, {"st": 80, "ed": 82, "text": "recursive specifications"}, {"st": 89, "ed": 92, "text": "natural deduction calculus"}, {"st": 100, "ed": 103, "text": "world \" equality"}, {"st": 105, "ed": 107, "text": "key ingredient"}, {"st": 111, "ed": 113, "text": "point definitions"}, {"st": 138, "ed": 140, "text": "strong normalizability"}, {"st": 142, "ed": 144, "text": "rewrite system"}, {"st": 145, "ed": 147, "text": "general properties"}, {"st": 167, "ed": 169, "text": "world equality"}, {"st": 170, "ed": 172, "text": "deduction modulo"}, {"st": 177, "ed": 179, "text": "elimination principle"}, {"st": 191, "ed": 193, "text": "first time"}, {"st": 200, "ed": 202, "text": "finite proofs"}]
[]
[{"st": 2, "ed": 4, "text": "collection F"}, {"st": 5, "ed": 7, "text": "computable functions"}, {"st": 24, "ed": 26, "text": "sentence \\varphi"}, {"st": 33, "ed": 37, "text": "positive rational number \\delta"}, {"st": 40, "ed": 42, "text": "\" \\varphi"}, {"st": 43, "ed": 45, "text": "true \""}, {"st": 55, "ed": 57, "text": "false \""}, {"st": 59, "ed": 61, "text": "mild assumptions"}, {"st": 66, "ed": 69, "text": "computable signature F"}, {"st": 73, "ed": 75, "text": "decision problem"}, {"st": 81, "ed": 83, "text": "L_F resides"}, {"st": 90, "ed": 92, "text": "sharp contrast"}, {"st": 97, "ed": 99, "text": "undecidability results"}, {"st": 104, "ed": 106, "text": "theoretical basis"}, {"st": 110, "ed": 112, "text": "numerical methods"}, {"st": 113, "ed": 115, "text": "decision procedures"}, {"st": 119, "ed": 121, "text": "order theories"}]
[{"st": 2, "ed": 4, "text": "Expressive Power"}, {"st": 7, "ed": 9, "text": "Propositional Fragments"}, {"st": 10, "ed": 12, "text": "Modal Logic"}]
[{"st": 0, "ed": 2, "text": "Modal logic"}, {"st": 9, "ed": 12, "text": "applicable formal systems"}, {"st": 13, "ed": 15, "text": "computer science"}, {"st": 20, "ed": 22, "text": "low complexity"}, {"st": 23, "ed": 26, "text": "classical propositional logic"}, {"st": 28, "ed": 30, "text": "notable exceptions"}, {"st": 40, "ed": 42, "text": "spatial logic"}, {"st": 46, "ed": 48, "text": "expressive formalisms"}, {"st": 51, "ed": 53, "text": "high complexity"}, {"st": 67, "ed": 69, "text": "clausal forms"}, {"st": 70, "ed": 72, "text": "other sub"}, {"st": 73, "ed": 75, "text": "propositional restrictions"}, {"st": 78, "ed": 80, "text": "description logics"}, {"st": 91, "ed": 93, "text": "propositional logics"}, {"st": 102, "ed": 104, "text": "various fragments"}, {"st": 106, "ed": 108, "text": "natural questions"}, {"st": 111, "ed": 114, "text": "relative expressive power"}, {"st": 123, "ed": 125, "text": "basic multi"}, {"st": 126, "ed": 129, "text": "modal logic Kn"}, {"st": 136, "ed": 138, "text": "Krom restrictions"}, {"st": 143, "ed": 145, "text": "combined restriction"}, {"st": 149, "ed": 151, "text": "core fragment"}, {"st": 153, "ed": 155, "text": "modal logic"}, {"st": 170, "ed": 172, "text": "positive literals"}, {"st": 180, "ed": 182, "text": "general setting"}, {"st": 189, "ed": 192, "text": "other meaningful cases"}]
[{"st": 1, "ed": 3, "text": "New Rule"}, {"st": 4, "ed": 6, "text": "LTL Tableaux"}]
[{"st": 0, "ed": 5, "text": "Propositional linear time temporal logic"}, {"st": 10, "ed": 13, "text": "standard temporal logic"}, {"st": 52, "ed": 55, "text": "shaped tableau systems"}, {"st": 70, "ed": 72, "text": "novel style"}, {"st": 73, "ed": 75, "text": "tableau rule"}, {"st": 128, "ed": 130, "text": "art systems"}, {"st": 136, "ed": 138, "text": "parallel implementations"}]
[{"st": 7, "ed": 9, "text": "Hybrid Logics"}]
[{"st": 3, "ed": 5, "text": "modal logics"}, {"st": 9, "ed": 12, "text": "basic modal logic"}, {"st": 17, "ed": 19, "text": "accessibility relation"}, {"st": 36, "ed": 38, "text": "dynamic modalities"}, {"st": 47, "ed": 49, "text": "swap edges"}, {"st": 87, "ed": 89, "text": "decidable fragments"}, {"st": 94, "ed": 96, "text": "expressive power"}, {"st": 100, "ed": 102, "text": "modal logics"}, {"st": 103, "ed": 105, "text": "hybrid logics"}]
[{"st": 2, "ed": 5, "text": "Parameterized Timed Networks"}]
[{"st": 7, "ed": 10, "text": "infinite state systems"}, {"st": 15, "ed": 17, "text": "parameterized discrete"}, {"st": 20, "ed": 22, "text": "multiple clocks"}, {"st": 42, "ed": 44, "text": "Such specifications"}, {"st": 53, "ed": 55, "text": "regular specifications"}, {"st": 60, "ed": 62, "text": "complex liveness"}, {"st": 63, "ed": 65, "text": "safety properties"}, {"st": 77, "ed": 79, "text": "symmetric broadcast"}, {"st": 88, "ed": 90, "text": "parameterized systems"}, {"st": 93, "ed": 95, "text": "timed processes"}, {"st": 102, "ed": 104, "text": "symmetric broadcast"}, {"st": 106, "ed": 108, "text": "decidability proof"}, {"st": 111, "ed": 113, "text": "automata theory"}, {"st": 114, "ed": 117, "text": "rational linear programming"}, {"st": 119, "ed": 121, "text": "geometric reasoning"}, {"st": 123, "ed": 126, "text": "certain reachability questions"}, {"st": 127, "ed": 130, "text": "vector addition systems"}, {"st": 134, "ed": 136, "text": "proof techniques"}, {"st": 141, "ed": 143, "text": "related problems"}]
[{"st": 1, "ed": 4, "text": "Linear Dynamic Logic"}]
[{"st": 3, "ed": 7, "text": "weighted linear dynamic logic"}, {"st": 8, "ed": 10, "text": "weighted LDL"}, {"st": 16, "ed": 18, "text": "expressive equivalence"}, {"st": 22, "ed": 25, "text": "weighted rational expressions"}, {"st": 29, "ed": 31, "text": "new characterization"}, {"st": 32, "ed": 34, "text": "recognizable series"}, {"st": 36, "ed": 39, "text": "fundamental Sch\\\"utzenberger theorem"}, {"st": 51, "ed": 53, "text": "weighted LDL"}, {"st": 80, "ed": 82, "text": "equivalence problem"}, {"st": 83, "ed": 86, "text": "weighted LDL formulas"}, {"st": 92, "ed": 94, "text": "exponential time"}, {"st": 98, "ed": 100, "text": "classical logics"}, {"st": 105, "ed": 107, "text": "weighted LDL"}, {"st": 111, "ed": 113, "text": "weighted LTL"}, {"st": 114, "ed": 116, "text": "finite words"}, {"st": 123, "ed": 125, "text": "weighted LTL"}, {"st": 131, "ed": 133, "text": "infinite words"}, {"st": 135, "ed": 137, "text": "LTL formulas"}, {"st": 144, "ed": 147, "text": "weighted LDL formulas"}]
[{"st": 1, "ed": 4, "text": "Canonical Model Construction"}, {"st": 7, "ed": 9, "text": "Free PDL"}]
[{"st": 8, "ed": 10, "text": "free fragment"}, {"st": 11, "ed": 14, "text": "Propositional Dynamic Logic"}, {"st": 22, "ed": 24, "text": "program composition"}, {"st": 39, "ed": 41, "text": "normal form"}, {"st": 55, "ed": 59, "text": "refined canonical model construction"}, {"st": 65, "ed": 67, "text": "axiom system"}, {"st": 72, "ed": 74, "text": "strong completeness"}]
[{"st": 0, "ed": 2, "text": "Partial Solvers"}, {"st": 3, "ed": 5, "text": "Parity Games"}, {"st": 6, "ed": 8, "text": "Effective Polynomial"}, {"st": 9, "ed": 11, "text": "Time Composition"}]
[{"st": 0, "ed": 2, "text": "Partial methods"}, {"st": 4, "ed": 6, "text": "important role"}, {"st": 7, "ed": 9, "text": "formal methods"}, {"st": 13, "ed": 15, "text": "such methods"}, {"st": 18, "ed": 20, "text": "parity games"}, {"st": 24, "ed": 27, "text": "time partial solvers"}, {"st": 43, "ed": 46, "text": "time partial solvers"}, {"st": 52, "ed": 54, "text": "partial solvers"}, {"st": 56, "ed": 59, "text": "generic composition patterns"}, {"st": 63, "ed": 65, "text": "time computability"}, {"st": 71, "ed": 74, "text": "such composition patterns"}, {"st": 75, "ed": 78, "text": "new partial solvers"}, {"st": 83, "ed": 85, "text": "node sets"}, {"st": 90, "ed": 92, "text": "unknown winner"}, {"st": 98, "ed": 100, "text": "partial solvers"}, {"st": 113, "ed": 115, "text": "driven approach"}, {"st": 121, "ed": 124, "text": "time partial solvers"}, {"st": 128, "ed": 130, "text": "standard benchmarks"}, {"st": 131, "ed": 133, "text": "structured games"}, {"st": 140, "ed": 143, "text": "time partial solvers"}, {"st": 146, "ed": 149, "text": "sole random game"}, {"st": 153, "ed": 155, "text": "random games"}]
[]
[{"st": 5, "ed": 7, "text": "different formulations"}, {"st": 14, "ed": 16, "text": "first formulation"}, {"st": 22, "ed": 24, "text": "rewrite rules"}, {"st": 32, "ed": 34, "text": "second formulation"}, {"st": 36, "ed": 38, "text": "inference system"}, {"st": 47, "ed": 49, "text": "third formulation"}, {"st": 54, "ed": 56, "text": "standard proof"}, {"st": 57, "ed": 59, "text": "search mechanism"}, {"st": 61, "ed": 64, "text": "sequent calculus LKp(T"}, {"st": 101, "ed": 103, "text": "Lemma learning"}, {"st": 123, "ed": 125, "text": "Ivan Gazeau"}, {"st": 126, "ed": 128, "text": "previous work"}, {"st": 138, "ed": 140, "text": "\" -modulo"}, {"st": 141, "ed": 144, "text": "Theory \" aspect"}, {"st": 154, "ed": 156, "text": "sequent calculus"}, {"st": 161, "ed": 163, "text": "theory solver"}, {"st": 179, "ed": 181, "text": "advanced features"}, {"st": 187, "ed": 189, "text": "Lemma learning"}, {"st": 203, "ed": 205, "text": "quantitative aspects"}, {"st": 219, "ed": 221, "text": "complete proofs"}, {"st": 223, "ed": 225, "text": "Other aspects"}, {"st": 235, "ed": 238, "text": "search / width"}, {"st": 239, "ed": 241, "text": "search space"}]
[{"st": 3, "ed": 5, "text": "Induction Methods"}, {"st": 6, "ed": 8, "text": "Timed Systems"}]
[{"st": 1, "ed": 4, "text": "time related aspects"}, {"st": 7, "ed": 9, "text": "many applications"}, {"st": 10, "ed": 12, "text": "verification methods"}, {"st": 14, "ed": 16, "text": "precise results"}, {"st": 25, "ed": 27, "text": "dense domain"}, {"st": 42, "ed": 45, "text": "infinite state space"}, {"st": 48, "ed": 50, "text": "verification methods"}, {"st": 54, "ed": 56, "text": "symbolic treatment"}, {"st": 63, "ed": 66, "text": "timing related elements"}, {"st": 68, "ed": 70, "text": "state space"}, {"st": 74, "ed": 76, "text": "attractive approach"}, {"st": 79, "ed": 81, "text": "timed systems"}, {"st": 83, "ed": 85, "text": "large amount"}, {"st": 97, "ed": 100, "text": "timed system extension"}, {"st": 102, "ed": 104, "text": "IC3 algorithm"}, {"st": 114, "ed": 117, "text": "complete verification method"}, {"st": 118, "ed": 120, "text": "untimed systems"}, {"st": 124, "ed": 127, "text": "infinite state spaces"}, {"st": 128, "ed": 130, "text": "timed system"}, {"st": 132, "ed": 135, "text": "extended IC3 algorithm"}, {"st": 144, "ed": 146, "text": "region abstraction"}, {"st": 147, "ed": 149, "text": "timed systems"}, {"st": 156, "ed": 159, "text": "symbolic verification method"}, {"st": 160, "ed": 163, "text": "discrete time systems"}, {"st": 168, "ed": 170, "text": "similar fashion"}, {"st": 172, "ed": 174, "text": "timed systems"}, {"st": 176, "ed": 178, "text": "new methods"}, {"st": 188, "ed": 190, "text": "verification approach"}, {"st": 193, "ed": 198, "text": "original discrete time IC3 algorithm"}]
[{"st": 6, "ed": 8, "text": "Time Logics"}]
[{"st": 6, "ed": 8, "text": "satisfiability problem"}, {"st": 20, "ed": 22, "text": "Boolean combinations"}, {"st": 23, "ed": 25, "text": "path formulas"}, {"st": 26, "ed": 28, "text": "fairness properties"}, {"st": 29, "ed": 31, "text": "past modalities"}, {"st": 33, "ed": 35, "text": "forgettable past"}, {"st": 37, "ed": 40, "text": "main result shows"}, {"st": 58, "ed": 60, "text": "nonelementary complexity"}, {"st": 61, "ed": 63, "text": "CTL *"}, {"st": 64, "ed": 66, "text": "forgettable past"}, {"st": 70, "ed": 72, "text": "complete classification"}, {"st": 92, "ed": 94, "text": "complete complexity"}, {"st": 108, "ed": 110, "text": "forgettable past"}, {"st": 127, "ed": 129, "text": "upper bounds"}, {"st": 136, "ed": 138, "text": "new kind"}, {"st": 139, "ed": 141, "text": "pebble automata"}]
[{"st": 2, "ed": 4, "text": "Hybrid Extension"}]
[{"st": 1, "ed": 3, "text": "paper studies"}, {"st": 6, "ed": 8, "text": "relative succinctness"}, {"st": 13, "ed": 15, "text": "hybrid extensions"}, {"st": 19, "ed": 22, "text": "time logics CTL"}, {"st": 27, "ed": 30, "text": "Previous complexity results"}, {"st": 39, "ed": 41, "text": "elementary complexity"}, {"st": 51, "ed": 53, "text": "hybrid extensions"}, {"st": 77, "ed": 79, "text": "other hand"}, {"st": 83, "ed": 85, "text": "hybrid extension"}, {"st": 89, "ed": 91, "text": "many variables"}, {"st": 94, "ed": 96, "text": "CTL *"}, {"st": 104, "ed": 109, "text": "simple CTL * property EGFp"}, {"st": 111, "ed": 113, "text": "satisfiability problem"}, {"st": 118, "ed": 121, "text": "triply exponential time"}, {"st": 127, "ed": 129, "text": "weak fragments"}, {"st": 131, "ed": 133, "text": "strong extensions"}]
[{"st": 0, "ed": 2, "text": "Predicate Transformers"}]
[{"st": 1, "ed": 3, "text": "short note"}, {"st": 4, "ed": 6, "text": "random thoughts"}, {"st": 8, "ed": 10, "text": "factorization theorem"}, {"st": 11, "ed": 15, "text": "closure / interior operators"}, {"st": 28, "ed": 31, "text": "monad / comonad"}, {"st": 36, "ed": 38, "text": "formal topology"}, {"st": 54, "ed": 56, "text": "several variations"}, {"st": 83, "ed": 85, "text": "predicativity issues"}]
[{"st": 7, "ed": 9, "text": "Ramsey Fragment"}, {"st": 10, "ed": 12, "text": "Separation Logic"}]
[{"st": 0, "ed": 2, "text": "Separation Logic"}, {"st": 10, "ed": 12, "text": "assertion language"}, {"st": 16, "ed": 20, "text": "style modular proof systems"}, {"st": 25, "ed": 27, "text": "data structures"}, {"st": 38, "ed": 40, "text": "order SL"}, {"st": 55, "ed": 57, "text": "quantified variables"}, {"st": 62, "ed": 64, "text": "memory locations"}, {"st": 91, "ed": 93, "text": "free fragment"}, {"st": 102, "ed": 104, "text": "prefix belongs"}, {"st": 112, "ed": 114, "text": "memory locations"}, {"st": 119, "ed": 122, "text": "linear arithmetic constraints"}, {"st": 126, "ed": 128, "text": "sharp boundary"}, {"st": 137, "ed": 139, "text": "decision procedure"}, {"st": 141, "ed": 143, "text": "decidable fragment"}, {"st": 148, "ed": 150, "text": "specialized solver"}, {"st": 158, "ed": 161, "text": "CVC4 SMT solver"}, {"st": 174, "ed": 176, "text": "verification conditions"}, {"st": 183, "ed": 185, "text": "inductive predicates"}, {"st": 195, "ed": 198, "text": "verification condition generator"}, {"st": 199, "ed": 202, "text": "Experimental data shows"}]
[{"st": 2, "ed": 4, "text": "Frobenius pseudomonoids"}, {"st": 8, "ed": 10, "text": "linear proofs"}]
[{"st": 2, "ed": 4, "text": "coherence theorems"}, {"st": 5, "ed": 7, "text": "Frobenius pseudomonoids"}, {"st": 10, "ed": 12, "text": "monoidal bicategories"}, {"st": 24, "ed": 28, "text": "nonsymmetric multiplicative linear logic"}, {"st": 31, "ed": 33, "text": "geometrical notion"}, {"st": 42, "ed": 45, "text": "global correctness criterion"}, {"st": 52, "ed": 55, "text": "traditional proof nets"}]
[{"st": 3, "ed": 5, "text": "Parameterized Reachability"}, {"st": 6, "ed": 10, "text": "Mobile Ad Hoc Networks"}]
[{"st": 5, "ed": 7, "text": "spontaneous movement"}, {"st": 11, "ed": 13, "text": "verification problems"}, {"st": 18, "ed": 20, "text": "protocol model"}, {"st": 23, "ed": 26, "text": "selective broadcast communication"}, {"st": 33, "ed": 35, "text": "error state"}, {"st": 38, "ed": 40, "text": "parameterized verification"}, {"st": 43, "ed": 45, "text": "polynomial complexity"}, {"st": 56, "ed": 58, "text": "complexity changes"}, {"st": 64, "ed": 66, "text": "cardinality constraints"}]
[{"st": 2, "ed": 7, "text": "Methods --- A Brief Overview"}]
[{"st": 6, "ed": 8, "text": "specific class"}, {"st": 11, "ed": 14, "text": "automated proof search"}, {"st": 17, "ed": 19, "text": "order logic"}, {"st": 27, "ed": 29, "text": "major methods"}, {"st": 41, "ed": 44, "text": "established resolution methods"}, {"st": 49, "ed": 51, "text": "recent trends"}, {"st": 68, "ed": 71, "text": "comprehensive literature list"}]
[{"st": 5, "ed": 7, "text": "Reduction Graphs"}]
[{"st": 1, "ed": 3, "text": "biological process"}, {"st": 4, "ed": 6, "text": "gene assembly"}, {"st": 19, "ed": 22, "text": "string pointer rules"}, {"st": 27, "ed": 30, "text": "called legal strings"}, {"st": 36, "ed": 38, "text": "reduction graphs"}, {"st": 47, "ed": 49, "text": "breakpoint graph"}, {"st": 58, "ed": 60, "text": "legal strings"}, {"st": 61, "ed": 63, "text": "valuable insights"}, {"st": 72, "ed": 74, "text": "legal strings"}, {"st": 76, "ed": 79, "text": "same reduction graph"}, {"st": 96, "ed": 98, "text": "reduction graphs"}]
[{"st": 0, "ed": 2, "text": "Feasible reactivity"}, {"st": 4, "ed": 6, "text": "synchronous pi"}]
[{"st": 3, "ed": 5, "text": "essential property"}, {"st": 7, "ed": 9, "text": "synchronous program"}, {"st": 34, "ed": 36, "text": "present work"}, {"st": 40, "ed": 42, "text": "refined property"}, {"st": 46, "ed": 48, "text": "feasible reactivity"}, {"st": 50, "ed": 52, "text": "Beyond reactivity"}, {"st": 68, "ed": 70, "text": "reaction time"}, {"st": 105, "ed": 109, "text": "related static analysis techniques"}, {"st": 111, "ed": 113, "text": "feasible reactivity"}, {"st": 128, "ed": 130, "text": "synchronous version"}]
[{"st": 1, "ed": 3, "text": "Bedwyr system"}, {"st": 4, "ed": 6, "text": "model checking"}, {"st": 7, "ed": 9, "text": "syntactic expressions"}]
[{"st": 5, "ed": 7, "text": "logic programming"}, {"st": 13, "ed": 15, "text": "syntactic expressions"}, {"st": 28, "ed": 30, "text": "direct implementation"}, {"st": 32, "ed": 34, "text": "recent advances"}, {"st": 38, "ed": 40, "text": "proof search"}, {"st": 50, "ed": 52, "text": "finite success"}, {"st": 53, "ed": 55, "text": "finite failure"}, {"st": 60, "ed": 62, "text": "sequent calculus"}, {"st": 64, "ed": 66, "text": "inference rules"}, {"st": 80, "ed": 82, "text": "proof search"}, {"st": 85, "ed": 87, "text": "sequent calculus"}, {"st": 89, "ed": 91, "text": "simple model"}, {"st": 101, "ed": 103, "text": "operational semantics"}, {"st": 110, "ed": 113, "text": "order abstract syntax"}, {"st": 136, "ed": 138, "text": "bound variables"}]
[{"st": 1, "ed": 4, "text": "Simplified Suspension Calculus"}, {"st": 8, "ed": 12, "text": "Other Explicit Substitution Calculi"}]
[{"st": 4, "ed": 6, "text": "explicit treatment"}, {"st": 10, "ed": 12, "text": "lambda calculus"}, {"st": 24, "ed": 26, "text": "suspension calculus"}, {"st": 40, "ed": 42, "text": "cumbersome encoding"}, {"st": 43, "ed": 45, "text": "substitution composition"}, {"st": 53, "ed": 55, "text": "efficient realization"}, {"st": 86, "ed": 88, "text": "inconsequential flexibility"}, {"st": 96, "ed": 99, "text": "inadvertent side effect"}, {"st": 101, "ed": 103, "text": "contextual information"}, {"st": 107, "ed": 109, "text": "modified calculus"}, {"st": 116, "ed": 118, "text": "logical analyses"}, {"st": 130, "ed": 132, "text": "lambda terms"}, {"st": 134, "ed": 136, "text": "overall calculus"}, {"st": 141, "ed": 143, "text": "theoretical properties"}, {"st": 160, "ed": 163, "text": "term meta variables"}, {"st": 180, "ed": 182, "text": "broad set"}, {"st": 188, "ed": 191, "text": "explicit substitution calculi"}, {"st": 207, "ed": 209, "text": "suspension calculus"}, {"st": 228, "ed": 231, "text": "other calculi towards"}]
[{"st": 4, "ed": 6, "text": "Macronuclear Genes"}]
[{"st": 0, "ed": 2, "text": "Formal models"}, {"st": 3, "ed": 5, "text": "gene assembly"}, {"st": 14, "ed": 18, "text": "string pointer reduction system"}, {"st": 23, "ed": 27, "text": "graph pointer reduction system"}, {"st": 32, "ed": 34, "text": "reduction graph"}, {"st": 36, "ed": 38, "text": "valuable tool"}, {"st": 43, "ed": 45, "text": "much information"}, {"st": 47, "ed": 49, "text": "gene assembly"}, {"st": 67, "ed": 69, "text": "information present"}, {"st": 82, "ed": 84, "text": "reduction graph"}, {"st": 105, "ed": 107, "text": "equivalent manner"}, {"st": 121, "ed": 124, "text": "realistic overlap graphs"}, {"st": 129, "ed": 131, "text": "graphs correspond"}, {"st": 139, "ed": 141, "text": "reduction graph"}, {"st": 149, "ed": 151, "text": "several results"}, {"st": 158, "ed": 160, "text": "reduction graph"}]
[{"st": 0, "ed": 4, "text": "Static Dependency Pair Method"}, {"st": 6, "ed": 8, "text": "Strong Computability"}, {"st": 11, "ed": 14, "text": "Order Rewrite Systems"}]
[{"st": 2, "ed": 5, "text": "order rewrite systems"}, {"st": 11, "ed": 13, "text": "typed term"}, {"st": 19, "ed": 21, "text": "computational models"}, {"st": 22, "ed": 24, "text": "functional programs"}, {"st": 30, "ed": 32, "text": "powerful method"}, {"st": 34, "ed": 38, "text": "static dependency pair method"}, {"st": 46, "ed": 48, "text": "strong computability"}, {"st": 82, "ed": 86, "text": "static dependency pair method"}, {"st": 96, "ed": 100, "text": "static dependency pair method"}, {"st": 106, "ed": 108, "text": "new restrictions"}]
[{"st": 1, "ed": 3, "text": "Spurious Counterexamples"}, {"st": 5, "ed": 8, "text": "Abstract Model Checking"}]
[{"st": 6, "ed": 8, "text": "important strategies"}, {"st": 12, "ed": 16, "text": "state space explosion problem"}, {"st": 17, "ed": 19, "text": "model checking"}, {"st": 22, "ed": 24, "text": "abstract model"}, {"st": 26, "ed": 28, "text": "state space"}, {"st": 45, "ed": 47, "text": "real counterexample"}, {"st": 49, "ed": 51, "text": "concrete model"}, {"st": 55, "ed": 58, "text": "abstract model needs"}, {"st": 76, "ed": 78, "text": "key problem"}, {"st": 82, "ed": 84, "text": "refinement loop"}, {"st": 90, "ed": 92, "text": "formal definition"}, {"st": 93, "ed": 95, "text": "spurious path"}, {"st": 102, "ed": 104, "text": "efficient algorithms"}, {"st": 106, "ed": 108, "text": "spurious counterexamples"}]
[{"st": 3, "ed": 5, "text": "Testing Equivalences"}, {"st": 8, "ed": 10, "text": "Probabilistic Processes"}]
[{"st": 4, "ed": 6, "text": "studied extensions"}, {"st": 14, "ed": 16, "text": "probabilistic processes"}, {"st": 23, "ed": 25, "text": "lack properties"}, {"st": 29, "ed": 31, "text": "Probabilistic trace"}, {"st": 32, "ed": 34, "text": "distribution equivalence"}, {"st": 40, "ed": 42, "text": "same set"}, {"st": 46, "ed": 48, "text": "same probabilities"}, {"st": 55, "ed": 57, "text": "parallel composition"}, {"st": 66, "ed": 69, "text": "extremal success probabilities"}, {"st": 77, "ed": 79, "text": "restricted classes"}, {"st": 85, "ed": 87, "text": "nondeterministic processes"}, {"st": 88, "ed": 93, "text": "generative / reactive probabilistic processes"}, {"st": 96, "ed": 98, "text": "specific sets"}, {"st": 107, "ed": 109, "text": "new versions"}, {"st": 110, "ed": 112, "text": "probabilistic trace"}, {"st": 113, "ed": 115, "text": "testing equivalences"}, {"st": 119, "ed": 121, "text": "general class"}, {"st": 124, "ed": 126, "text": "probabilistic processes"}, {"st": 128, "ed": 131, "text": "new trace equivalence"}, {"st": 136, "ed": 138, "text": "execution probabilities"}, {"st": 139, "ed": 141, "text": "single traces"}, {"st": 143, "ed": 146, "text": "entire trace distributions"}, {"st": 169, "ed": 171, "text": "success probabilities"}, {"st": 176, "ed": 179, "text": "extremal success probabilities"}, {"st": 181, "ed": 184, "text": "considers success probabilities"}, {"st": 190, "ed": 192, "text": "trace fashion"}, {"st": 197, "ed": 199, "text": "entire resolutions"}, {"st": 209, "ed": 211, "text": "restricted classes"}, {"st": 223, "ed": 225, "text": "trace approach"}, {"st": 228, "ed": 232, "text": "standard probabilistic testing equivalences"}, {"st": 235, "ed": 238, "text": "reactive probabilistic processes"}, {"st": 243, "ed": 245, "text": "full details"}, {"st": 246, "ed": 248, "text": "new equivalences"}, {"st": 251, "ed": 253, "text": "simple spectrum"}, {"st": 265, "ed": 267, "text": "probabilistic processes"}]
[{"st": 0, "ed": 3, "text": "Lazy Model Expansion"}]
[{"st": 20, "ed": 23, "text": "model generation problem"}, {"st": 44, "ed": 46, "text": "art approach"}, {"st": 47, "ed": 50, "text": "bounded model generation"}, {"st": 51, "ed": 55, "text": "rich knowledge representation languages"}, {"st": 85, "ed": 87, "text": "search algorithm"}, {"st": 93, "ed": 95, "text": "important bottleneck"}, {"st": 107, "ed": 109, "text": "reduction phase"}, {"st": 127, "ed": 129, "text": "theoretical framework"}, {"st": 141, "ed": 144, "text": "knowledge representation language"}, {"st": 165, "ed": 167, "text": "partial assignment"}, {"st": 169, "ed": 171, "text": "grounded part"}, {"st": 175, "ed": 177, "text": "valid justifications"}, {"st": 184, "ed": 186, "text": "grounded part"}, {"st": 195, "ed": 197, "text": "complete assignment"}, {"st": 202, "ed": 204, "text": "grounded part"}, {"st": 210, "ed": 212, "text": "particular formula"}, {"st": 246, "ed": 249, "text": "theoretical framework captures"}, {"st": 258, "ed": 261, "text": "lazy clause generation"}, {"st": 276, "ed": 279, "text": "2-watched literal scheme"}, {"st": 285, "ed": 288, "text": "lazy model expansion"}, {"st": 293, "ed": 295, "text": "model generator"}, {"st": 304, "ed": 306, "text": "order logic"}, {"st": 307, "ed": 309, "text": "inductive definitions"}, {"st": 324, "ed": 326, "text": "art FO(ID"}, {"st": 329, "ed": 332, "text": "Base System IDP"}, {"st": 333, "ed": 335, "text": "Experimental results"}]
[{"st": 3, "ed": 5, "text": "theoretic view"}]
[{"st": 5, "ed": 7, "text": "new approach"}, {"st": 14, "ed": 16, "text": "theoretic study"}, {"st": 17, "ed": 19, "text": "concurrent interaction"}, {"st": 23, "ed": 25, "text": "schedules \""}, {"st": 28, "ed": 30, "text": "proof theory"}, {"st": 37, "ed": 39, "text": "confluent systems"}, {"st": 47, "ed": 49, "text": "fundamental feature"}, {"st": 62, "ed": 65, "text": "concurrent systems confluent"}, {"st": 71, "ed": 73, "text": "logical system"}, {"st": 82, "ed": 84, "text": "different fragments"}, {"st": 86, "ed": 88, "text": "proof language"}, {"st": 99, "ed": 101, "text": "concurrent system"}, {"st": 107, "ed": 109, "text": "new insights"}, {"st": 111, "ed": 113, "text": "denotational semantics"}, {"st": 116, "ed": 118, "text": "new methods"}, {"st": 136, "ed": 138, "text": "operational counterpart"}, {"st": 141, "ed": 143, "text": "proof systems"}]
[]
[{"st": 3, "ed": 6, "text": "description logic ALCQIO_{b"}, {"st": 11, "ed": 13, "text": "reachability assertions"}, {"st": 24, "ed": 26, "text": "variable fragment"}, {"st": 27, "ed": 30, "text": "first order logic"}, {"st": 45, "ed": 47, "text": "software verification"}, {"st": 48, "ed": 50, "text": "shape analysis"}, {"st": 51, "ed": 53, "text": "Shape analysis"}, {"st": 54, "ed": 56, "text": "expressive logics"}, {"st": 62, "ed": 65, "text": "good computational properties"}, {"st": 75, "ed": 78, "text": "complex data structures"}, {"st": 80, "ed": 82, "text": "high degree"}, {"st": 97, "ed": 99, "text": "finite satisfiability"}, {"st": 100, "ed": 102, "text": "implication problems"}, {"st": 126, "ed": 128, "text": "finite satisfiability"}, {"st": 129, "ed": 131, "text": "finite implication"}, {"st": 141, "ed": 143, "text": "Description logics"}, {"st": 144, "ed": 147, "text": "transitive closure constructors"}, {"st": 159, "ed": 162, "text": "first description logic"}, {"st": 166, "ed": 168, "text": "finite structures"}, {"st": 172, "ed": 175, "text": "same time nominals"}, {"st": 176, "ed": 178, "text": "inverse roles"}, {"st": 182, "ed": 184, "text": "reachability assertions"}]
[{"st": 3, "ed": 5, "text": "internal moves"}]
[{"st": 2, "ed": 4, "text": "first part"}, {"st": 10, "ed": 12, "text": "coalgebraic approach"}, {"st": 18, "ed": 20, "text": "invisible transitions"}, {"st": 23, "ed": 25, "text": "different state"}, {"st": 27, "ed": 29, "text": "systems semantics"}, {"st": 43, "ed": 45, "text": "certain monad"}, {"st": 50, "ed": 52, "text": "internal moves"}, {"st": 57, "ed": 59, "text": "monadic type"}, {"st": 74, "ed": 77, "text": "important behavioural equivalences"}, {"st": 83, "ed": 85, "text": "internal moves"}, {"st": 88, "ed": 90, "text": "weak bisimulation"}, {"st": 91, "ed": 93, "text": "trace semantics"}, {"st": 99, "ed": 101, "text": "weak bisimulations"}, {"st": 109, "ed": 111, "text": "key notions"}, {"st": 121, "ed": 123, "text": "previous work"}, {"st": 128, "ed": 131, "text": "order saturation monad"}, {"st": 136, "ed": 138, "text": "saturator operator"}, {"st": 146, "ed": 149, "text": "transitive closure operator"}, {"st": 160, "ed": 162, "text": "internal moves"}, {"st": 167, "ed": 169, "text": "necessary conditions"}, {"st": 174, "ed": 176, "text": "same notion"}, {"st": 177, "ed": 179, "text": "weak bisimulation"}, {"st": 187, "ed": 189, "text": "trace semantics"}, {"st": 192, "ed": 194, "text": "silent moves"}, {"st": 198, "ed": 200, "text": "point operator"}, {"st": 205, "ed": 207, "text": "weak bisimilation"}, {"st": 209, "ed": 211, "text": "trace semantics"}, {"st": 214, "ed": 216, "text": "internal steps"}]
[{"st": 3, "ed": 5, "text": "logical glue"}]
[{"st": 1, "ed": 4, "text": "typical mathematical language"}, {"st": 8, "ed": 10, "text": "logical abuses"}, {"st": 18, "ed": 21, "text": "domain specific notation"}, {"st": 26, "ed": 28, "text": "trivial skills"}, {"st": 31, "ed": 33, "text": "mathematical discipline"}, {"st": 35, "ed": 37, "text": "large part"}, {"st": 39, "ed": 41, "text": "background knowledge"}, {"st": 56, "ed": 58, "text": "different incarnations"}, {"st": 60, "ed": 62, "text": "same entity"}, {"st": 73, "ed": 75, "text": "similar capabilities"}, {"st": 79, "ed": 81, "text": "major way"}, {"st": 99, "ed": 101, "text": "present paper"}, {"st": 108, "ed": 110, "text": "superposition calculus"}, {"st": 112, "ed": 115, "text": "Matita interactive prover"}, {"st": 123, "ed": 128, "text": "\" smart \" application tactic"}, {"st": 133, "ed": 135, "text": "innovative approach"}]
[{"st": 0, "ed": 2, "text": "Stateless HOL"}]
[{"st": 6, "ed": 9, "text": "HOL Light system"}, {"st": 73, "ed": 76, "text": "HOL Light developments"}, {"st": 81, "ed": 83, "text": "stateless system"}, {"st": 85, "ed": 87, "text": "minor changes"}, {"st": 89, "ed": 91, "text": "basic principle"}, {"st": 117, "ed": 119, "text": "data structures"}, {"st": 127, "ed": 129, "text": "big graph"}, {"st": 133, "ed": 135, "text": "implementation language"}, {"st": 141, "ed": 143, "text": "pointer equality"}, {"st": 147, "ed": 149, "text": "data structures"}, {"st": 158, "ed": 160, "text": "acceptable speeds"}, {"st": 172, "ed": 174, "text": "stateful version"}, {"st": 175, "ed": 177, "text": "HOL Light"}]
[{"st": 0, "ed": 2, "text": "Nonuniform Coercions"}, {"st": 3, "ed": 5, "text": "Unification Hints"}]
[{"st": 5, "ed": 7, "text": "nonuniform coercion"}, {"st": 20, "ed": 22, "text": "enriched value"}, {"st": 24, "ed": 26, "text": "different type"}, {"st": 28, "ed": 30, "text": "nonuniform procedure"}, {"st": 31, "ed": 33, "text": "Nonuniform coercions"}, {"st": 56, "ed": 60, "text": "order interactive theorem prover"}, {"st": 61, "ed": 63, "text": "convenient devices"}, {"st": 64, "ed": 66, "text": "canonical structures"}, {"st": 67, "ed": 69, "text": "type classes"}, {"st": 70, "ed": 72, "text": "unification hints"}, {"st": 77, "ed": 79, "text": "nonuniform coercions"}, {"st": 85, "ed": 87, "text": "user level"}, {"st": 89, "ed": 92, "text": "interactive theorem prover"}, {"st": 94, "ed": 96, "text": "unification hints"}]
[{"st": 0, "ed": 3, "text": "Generic Trace Logics"}]
[{"st": 2, "ed": 4, "text": "previous work"}]
[{"st": 0, "ed": 3, "text": "Typed Operational Semantics"}, {"st": 4, "ed": 7, "text": "Dependent Record Types"}]
[{"st": 0, "ed": 3, "text": "Typed operational semantics"}, {"st": 8, "ed": 10, "text": "H. Goguen"}, {"st": 14, "ed": 16, "text": "theoretic properties"}, {"st": 17, "ed": 19, "text": "type systems"}, {"st": 21, "ed": 23, "text": "paper studies"}, {"st": 27, "ed": 29, "text": "type system"}, {"st": 30, "ed": 33, "text": "dependent record types"}, {"st": 38, "ed": 41, "text": "typed operational semantics"}, {"st": 46, "ed": 48, "text": "metatheoretical properties"}, {"st": 52, "ed": 54, "text": "strong normalisation"}, {"st": 59, "ed": 61, "text": "subject reduction"}]
[{"st": 5, "ed": 7, "text": "Vector Formulas"}]
[{"st": 2, "ed": 4, "text": "vector formulas"}, {"st": 6, "ed": 9, "text": "hardware verification problems"}, {"st": 13, "ed": 16, "text": "level arithmetic operations"}, {"st": 17, "ed": 20, "text": "Empirical evidence shows"}, {"st": 27, "ed": 30, "text": "art SMT solvers"}, {"st": 39, "ed": 41, "text": "vector formulas"}, {"st": 49, "ed": 51, "text": "multiplication operators"}, {"st": 56, "ed": 58, "text": "alternative ways"}, {"st": 71, "ed": 73, "text": "certain types"}, {"st": 74, "ed": 76, "text": "decomposed multipliers"}, {"st": 79, "ed": 81, "text": "special assertions"}, {"st": 83, "ed": 85, "text": "input formula"}, {"st": 95, "ed": 97, "text": "level multiplication"}, {"st": 108, "ed": 110, "text": "SMT solver"}, {"st": 115, "ed": 117, "text": "SMT solvers"}, {"st": 120, "ed": 124, "text": "heuristic allows several formulas"}, {"st": 131, "ed": 134, "text": "same formulas time"}, {"st": 139, "ed": 141, "text": "processing step"}]
[{"st": 0, "ed": 2, "text": "Information Flow"}, {"st": 3, "ed": 5, "text": "Logical Environments"}]
[{"st": 3, "ed": 5, "text": "information flow"}, {"st": 6, "ed": 8, "text": "logical environments"}, {"st": 12, "ed": 14, "text": "information flow"}, {"st": 18, "ed": 20, "text": "distributed systems"}, {"st": 29, "ed": 31, "text": "Information Flow"}, {"st": 35, "ed": 37, "text": "Distributed Systems"}, {"st": 41, "ed": 43, "text": "Logical environments"}, {"st": 67, "ed": 70, "text": "Abstract Model Theory"}, {"st": 79, "ed": 82, "text": "abstract model theory"}, {"st": 83, "ed": 85, "text": "Information flow"}, {"st": 93, "ed": 95, "text": "distributed systems"}, {"st": 97, "ed": 99, "text": "semantic integration"}, {"st": 100, "ed": 102, "text": "distributed systems"}, {"st": 109, "ed": 112, "text": "other information resources"}, {"st": 120, "ed": 122, "text": "channel theory"}, {"st": 123, "ed": 125, "text": "information flow"}, {"st": 133, "ed": 135, "text": "information flow"}, {"st": 138, "ed": 141, "text": "specific logical environment"}, {"st": 145, "ed": 147, "text": "information flow"}, {"st": 152, "ed": 154, "text": "information flow"}, {"st": 159, "ed": 162, "text": "arbitrary logical environment"}]
[{"st": 2, "ed": 4, "text": "Invariant Types"}, {"st": 5, "ed": 7, "text": "Their Applications"}]
[{"st": 7, "ed": 9, "text": "standard model"}, {"st": 10, "ed": 12, "text": "theoretic concept"}, {"st": 23, "ed": 25, "text": "invariant properties"}, {"st": 38, "ed": 41, "text": "auxiliary order relation"}, {"st": 48, "ed": 50, "text": "order relation"}, {"st": 58, "ed": 60, "text": "invariant properties"}, {"st": 68, "ed": 70, "text": "logical object"}, {"st": 86, "ed": 88, "text": "basic principles"}, {"st": 101, "ed": 104, "text": "invariant MSO properties"}, {"st": 121, "ed": 123, "text": "Vaught theorem"}, {"st": 126, "ed": 128, "text": "invariant properties"}]
[{"st": 2, "ed": 6, "text": "choice Message Sequence Graphs"}]
[{"st": 4, "ed": 6, "text": "realizability problem"}, {"st": 7, "ed": 10, "text": "Message Sequence Graphs"}, {"st": 20, "ed": 22, "text": "MSG specification"}, {"st": 26, "ed": 28, "text": "parallel components"}, {"st": 33, "ed": 35, "text": "fundamental problem"}, {"st": 48, "ed": 50, "text": "restricted class"}, {"st": 57, "ed": 59, "text": "choice MSG"}, {"st": 76, "ed": 78, "text": "MSG model"}, {"st": 92, "ed": 94, "text": "MSG specifications"}, {"st": 98, "ed": 100, "text": "free realization"}, {"st": 107, "ed": 109, "text": "control data"}, {"st": 115, "ed": 117, "text": "presented class"}, {"st": 120, "ed": 122, "text": "known subclass"}, {"st": 129, "ed": 131, "text": "free realization"}]
[{"st": 0, "ed": 2, "text": "Random strings"}, {"st": 7, "ed": 11, "text": "Turing complete C.E. sets"}]
[{"st": 5, "ed": 7, "text": "table degrees"}, {"st": 9, "ed": 11, "text": "co-)c.e.\\ sets"}, {"st": 17, "ed": 19, "text": "random strings"}, {"st": 27, "ed": 29, "text": "random strings"}, {"st": 33, "ed": 35, "text": "universal prefix"}, {"st": 36, "ed": 38, "text": "free machine"}, {"st": 46, "ed": 48, "text": "table completeness"}, {"st": 53, "ed": 55, "text": "universal machine"}, {"st": 60, "ed": 62, "text": "such sets"}, {"st": 63, "ed": 65, "text": "random strings"}, {"st": 67, "ed": 69, "text": "finite set"}, {"st": 73, "ed": 75, "text": "table degrees"}, {"st": 89, "ed": 91, "text": "table degrees"}, {"st": 99, "ed": 101, "text": "such truth"}, {"st": 102, "ed": 104, "text": "table degrees"}, {"st": 106, "ed": 108, "text": "infinite meet"}, {"st": 112, "ed": 114, "text": "latter result"}, {"st": 131, "ed": 134, "text": "Turing complete c.e"}, {"st": 139, "ed": 141, "text": "table degrees"}, {"st": 143, "ed": 145, "text": "minimal pair"}]
[{"st": 5, "ed": 9, "text": "Calculus Targeting SPL Verification"}]
[{"st": 13, "ed": 15, "text": "fixpoint logic"}, {"st": 19, "ed": 21, "text": "check properties"}, {"st": 23, "ed": 26, "text": "labeled transition systems"}, {"st": 51, "ed": 54, "text": "feature transition systems"}, {"st": 61, "ed": 63, "text": "feature expressions"}, {"st": 76, "ed": 78, "text": "specific products"}, {"st": 97, "ed": 99, "text": "new mu"}, {"st": 117, "ed": 119, "text": "SPL behavior"}, {"st": 155, "ed": 157, "text": "toy example"}]
[{"st": 0, "ed": 2, "text": "Structural Multi"}, {"st": 3, "ed": 6, "text": "type Sequent Calculus"}, {"st": 7, "ed": 9, "text": "Inquisitive Logic"}]
[{"st": 9, "ed": 11, "text": "type calculus"}, {"st": 12, "ed": 14, "text": "inquisitive logic"}, {"st": 24, "ed": 26, "text": "style cut"}, {"st": 29, "ed": 31, "text": "subformula property"}, {"st": 32, "ed": 34, "text": "Inquisitive logic"}, {"st": 38, "ed": 40, "text": "inquisitive semantics"}, {"st": 42, "ed": 44, "text": "semantic framework"}, {"st": 58, "ed": 60, "text": "natural language"}, {"st": 61, "ed": 63, "text": "Inquisitive logic"}, {"st": 66, "ed": 68, "text": "complete w.r.t"}, {"st": 73, "ed": 75, "text": "state semantics"}, {"st": 79, "ed": 81, "text": "team semantics"}, {"st": 86, "ed": 88, "text": "style presentation"}, {"st": 89, "ed": 91, "text": "inquisitive logic"}, {"st": 95, "ed": 97, "text": "uniform substitution"}, {"st": 108, "ed": 110, "text": "certain subclass"}, {"st": 114, "ed": 116, "text": "flat formulas"}, {"st": 119, "ed": 121, "text": "other features"}, {"st": 125, "ed": 127, "text": "analytic calculi"}, {"st": 136, "ed": 138, "text": "certain algebraic"}, {"st": 141, "ed": 143, "text": "theoretic analysis"}, {"st": 145, "ed": 147, "text": "team semantics"}, {"st": 159, "ed": 161, "text": "type environment"}, {"st": 173, "ed": 175, "text": "general formulas"}, {"st": 186, "ed": 188, "text": "type environment"}, {"st": 193, "ed": 195, "text": "semantic environment"}, {"st": 199, "ed": 201, "text": "type calculus"}, {"st": 202, "ed": 204, "text": "inquisitive logic"}]
[{"st": 0, "ed": 2, "text": "Parameter Synthesis"}, {"st": 3, "ed": 5, "text": "Markov Models"}]
[{"st": 3, "ed": 5, "text": "simple technique"}, {"st": 7, "ed": 9, "text": "probabilistic models"}, {"st": 10, "ed": 12, "text": "transition probabilities"}, {"st": 20, "ed": 22, "text": "parametric transitions"}, {"st": 23, "ed": 25, "text": "nondeterministic choices"}, {"st": 26, "ed": 28, "text": "extremal values"}, {"st": 34, "ed": 36, "text": "free model"}, {"st": 49, "ed": 51, "text": "upper bounds"}, {"st": 57, "ed": 59, "text": "parameter space"}, {"st": 67, "ed": 70, "text": "parametric Markov chains"}, {"st": 71, "ed": 73, "text": "several orders"}, {"st": 89, "ed": 92, "text": "various probabilistic models"}, {"st": 98, "ed": 100, "text": "first sound"}, {"st": 101, "ed": 103, "text": "feasible method"}, {"st": 105, "ed": 107, "text": "parameter synthesis"}, {"st": 108, "ed": 111, "text": "Markov decision processes"}]
[{"st": 0, "ed": 3, "text": "Quantitative classical realizability"}]
[{"st": 2, "ed": 4, "text": "Dal Lago"}, {"st": 7, "ed": 9, "text": "quantitative realizability"}, {"st": 20, "ed": 23, "text": "Multiplicative Linear Logic"}, {"st": 32, "ed": 36, "text": "bounded time computable functions"}, {"st": 45, "ed": 47, "text": "uniform proofs"}, {"st": 50, "ed": 53, "text": "several type systems"}, {"st": 56, "ed": 60, "text": "certain time complexity classes"}, {"st": 74, "ed": 76, "text": "classical realizability"}, {"st": 80, "ed": 83, "text": "generalizes Dal Lago"}, {"st": 89, "ed": 92, "text": "reveals deep connections"}, {"st": 93, "ed": 95, "text": "quantitative realizability"}, {"st": 97, "ed": 99, "text": "linear variant"}]
[{"st": 0, "ed": 3, "text": "Coalgebraic Trace Semantics"}, {"st": 4, "ed": 8, "text": "Continuous Probabilistic Transition Systems"}]
[{"st": 3, "ed": 6, "text": "Kleisli category yield"}, {"st": 7, "ed": 9, "text": "generic definition"}, {"st": 10, "ed": 12, "text": "trace semantics"}, {"st": 13, "ed": 15, "text": "various types"}, {"st": 16, "ed": 19, "text": "labelled transition systems"}, {"st": 26, "ed": 28, "text": "generic theory"}, {"st": 30, "ed": 33, "text": "probabilistic transition systems"}, {"st": 34, "ed": 36, "text": "short PTS"}, {"st": 43, "ed": 45, "text": "state spaces"}, {"st": 51, "ed": 53, "text": "probability monad"}, {"st": 55, "ed": 57, "text": "probability monad"}, {"st": 58, "ed": 60, "text": "Giry monad"}, {"st": 65, "ed": 67, "text": "measurable spaces"}, {"st": 68, "ed": 70, "text": "measurable functions"}, {"st": 72, "ed": 74, "text": "main contribution"}, {"st": 80, "ed": 82, "text": "final coalgebra"}, {"st": 84, "ed": 86, "text": "Kleisli category"}, {"st": 96, "ed": 99, "text": "theoretic extension theorem"}, {"st": 113, "ed": 115, "text": "practical definition"}, {"st": 117, "ed": 119, "text": "trace measure"}, {"st": 123, "ed": 125, "text": "infinite traces"}, {"st": 135, "ed": 139, "text": "discrete probabilistic transition systems"}, {"st": 144, "ed": 146, "text": "example systems"}, {"st": 147, "ed": 150, "text": "uncountable state spaces"}, {"st": 157, "ed": 159, "text": "trace measures"}]
[]
[{"st": 5, "ed": 7, "text": "aka WSTSs"}, {"st": 9, "ed": 11, "text": "computational models"}, {"st": 15, "ed": 17, "text": "possible configurations"}, {"st": 31, "ed": 33, "text": "transition relation"}, {"st": 39, "ed": 42, "text": "generic decidability results"}, {"st": 48, "ed": 51, "text": "several other fields"}, {"st": 56, "ed": 58, "text": "basic theory"}, {"st": 67, "ed": 70, "text": "classic decision algorithms"}, {"st": 75, "ed": 77, "text": "exhaustive search"}, {"st": 79, "ed": 83, "text": "\" bad \" sequences"}, {"st": 88, "ed": 91, "text": "new powerful techniques"}, {"st": 93, "ed": 95, "text": "complexity analysis"}, {"st": 96, "ed": 98, "text": "WSTS algorithms"}, {"st": 116, "ed": 118, "text": "theoretical sense"}, {"st": 120, "ed": 124, "text": "several important WSTS models"}, {"st": 125, "ed": 128, "text": "unreliable channel systems"}, {"st": 129, "ed": 132, "text": "monotonic counter machines"}, {"st": 136, "ed": 138, "text": "timed systems"}]
[{"st": 2, "ed": 5, "text": "Markov Decision Processes"}, {"st": 6, "ed": 8, "text": "Learning Algorithms"}]
[{"st": 3, "ed": 5, "text": "general framework"}, {"st": 9, "ed": 11, "text": "learning algorithms"}, {"st": 15, "ed": 18, "text": "Markov decision processes"}, {"st": 23, "ed": 25, "text": "primary goal"}, {"st": 35, "ed": 37, "text": "exhaustive exploration"}, {"st": 39, "ed": 41, "text": "state space"}, {"st": 46, "ed": 48, "text": "probabilistic reachability"}, {"st": 52, "ed": 54, "text": "core property"}, {"st": 62, "ed": 64, "text": "distinct instantiations"}, {"st": 69, "ed": 71, "text": "full knowledge"}, {"st": 83, "ed": 85, "text": "partial exploration"}, {"st": 93, "ed": 95, "text": "upper bounds"}, {"st": 97, "ed": 99, "text": "required probability"}, {"st": 114, "ed": 117, "text": "yields probabilistic guarantees"}, {"st": 126, "ed": 128, "text": "upper bounds"}, {"st": 142, "ed": 144, "text": "first extension"}, {"st": 145, "ed": 147, "text": "statistical model"}, {"st": 150, "ed": 152, "text": "unbounded properties"}, {"st": 158, "ed": 161, "text": "other related approaches"}, {"st": 184, "ed": 186, "text": "particular properties"}, {"st": 198, "ed": 200, "text": "LTL objectives"}, {"st": 202, "ed": 205, "text": "present experimental results"}, {"st": 212, "ed": 214, "text": "several examples"}]
[{"st": 0, "ed": 2, "text": "Robust Synchronization"}, {"st": 3, "ed": 6, "text": "Markov Decision Processes"}]
[{"st": 5, "ed": 8, "text": "Markov decision processes"}, {"st": 18, "ed": 20, "text": "probability distributions"}, {"st": 24, "ed": 26, "text": "probability distribution"}, {"st": 32, "ed": 34, "text": "probability mass"}, {"st": 46, "ed": 48, "text": "probability distributions"}, {"st": 49, "ed": 51, "text": "weakly p"}, {"st": 68, "ed": 70, "text": "many distributions"}, {"st": 80, "ed": 82, "text": "synchronizing mode"}, {"st": 100, "ed": 102, "text": "1-synchronizing sequence"}, {"st": 132, "ed": 134, "text": "1-{\\epsilon})-synchronizing sequence"}, {"st": 159, "ed": 161, "text": "1-{\\epsilon})-synchronizing sequence"}, {"st": 188, "ed": 190, "text": "complexity bounds"}, {"st": 198, "ed": 201, "text": "optimal memory requirement"}, {"st": 223, "ed": 225, "text": "weakly synchronizing"}, {"st": 241, "ed": 243, "text": "weakly synchronizing"}, {"st": 244, "ed": 246, "text": "exponential memory"}, {"st": 253, "ed": 255, "text": "sure winning"}, {"st": 257, "ed": 259, "text": "infinite memory"}, {"st": 264, "ed": 266, "text": "sure winning"}, {"st": 273, "ed": 275, "text": "size memory"}, {"st": 291, "ed": 293, "text": "robustness result"}, {"st": 303, "ed": 305, "text": "modes coincide"}]
[{"st": 0, "ed": 3, "text": "Strong Turing Degrees"}, {"st": 4, "ed": 7, "text": "Additive BSS RAM"}]
[{"st": 2, "ed": 6, "text": "additive real BSS machines"}, {"st": 13, "ed": 15, "text": "order tests"}, {"st": 18, "ed": 21, "text": "corresponding Turing reducibility"}, {"st": 26, "ed": 29, "text": "decidable decision problems"}, {"st": 45, "ed": 47, "text": "linear hierarchy"}, {"st": 58, "ed": 61, "text": "several halting problems"}, {"st": 64, "ed": 66, "text": "additive machines"}, {"st": 67, "ed": 69, "text": "different abilities"}, {"st": 72, "ed": 75, "text": "suitable decision problems"}, {"st": 84, "ed": 87, "text": "classical recursion theory"}, {"st": 96, "ed": 98, "text": "algebraic properties"}, {"st": 105, "ed": 107, "text": "known hierarchy"}, {"st": 111, "ed": 113, "text": "halting problem"}, {"st": 115, "ed": 117, "text": "additive machines"}, {"st": 119, "ed": 121, "text": "equality tests"}, {"st": 125, "ed": 127, "text": "further subhierarchy"}, {"st": 130, "ed": 132, "text": "decidable problems"}, {"st": 134, "ed": 136, "text": "halting problems"}, {"st": 138, "ed": 140, "text": "additive machines"}, {"st": 142, "ed": 144, "text": "equality tests"}, {"st": 146, "ed": 148, "text": "order tests"}]
[{"st": 3, "ed": 6, "text": "Infinite State Processes"}]
[{"st": 3, "ed": 6, "text": "uniform verification problem"}, {"st": 7, "ed": 10, "text": "infinite state processes"}, {"st": 17, "ed": 19, "text": "parallel composition"}, {"st": 21, "ed": 23, "text": "arbitrary number"}, {"st": 24, "ed": 26, "text": "processes satisfies"}, {"st": 27, "ed": 29, "text": "temporal property"}, {"st": 31, "ed": 33, "text": "practical motivation"}, {"st": 37, "ed": 39, "text": "general framework"}, {"st": 41, "ed": 43, "text": "temporal verification"}, {"st": 44, "ed": 46, "text": "concurrent datatypes"}, {"st": 54, "ed": 56, "text": "general method"}, {"st": 60, "ed": 62, "text": "safety properties"}, {"st": 63, "ed": 65, "text": "parametrized programs"}, {"st": 70, "ed": 72, "text": "global data"}, {"st": 74, "ed": 76, "text": "mutable state"}, {"st": 102, "ed": 105, "text": "novel parametrized invariance"}, {"st": 113, "ed": 116, "text": "specialized decision procedures"}, {"st": 118, "ed": 120, "text": "proof rules"}, {"st": 123, "ed": 125, "text": "finite collection"}, {"st": 126, "ed": 128, "text": "verification conditions"}, {"st": 141, "ed": 143, "text": "program description"}, {"st": 179, "ed": 181, "text": "decision procedures"}, {"st": 182, "ed": 184, "text": "complex data"}, {"st": 193, "ed": 196, "text": "shelf SMT solvers"}, {"st": 200, "ed": 202, "text": "practical verification"}, {"st": 207, "ed": 210, "text": "functional correctness properties"}, {"st": 213, "ed": 216, "text": "concurrent list implementation"}, {"st": 232, "ed": 234, "text": "decision procedure"}, {"st": 238, "ed": 240, "text": "list layouts"}, {"st": 253, "ed": 256, "text": "art SMT solvers"}]
[{"st": 4, "ed": 7, "text": "fly Fast Mean"}, {"st": 8, "ed": 10, "text": "Field Model"}]
[{"st": 9, "ed": 11, "text": "fly model"}, {"st": 12, "ed": 14, "text": "checking procedure"}, {"st": 18, "ed": 21, "text": "bounded PCTL properties"}, {"st": 29, "ed": 31, "text": "large systems"}, {"st": 32, "ed": 35, "text": "independent interacting objects"}, {"st": 37, "ed": 40, "text": "proposed procedure combines"}, {"st": 44, "ed": 46, "text": "fly model"}, {"st": 52, "ed": 54, "text": "field approximation"}, {"st": 55, "ed": 57, "text": "discrete time"}, {"st": 59, "ed": 61, "text": "asymptotic correctness"}, {"st": 74, "ed": 76, "text": "prototype implementation"}, {"st": 78, "ed": 80, "text": "FlyFast model"}]
[{"st": 10, "ed": 14, "text": "linear logic type discipline"}]
[{"st": 19, "ed": 21, "text": "deterministic choice"}, {"st": 25, "ed": 28, "text": "convergent parallel composition"}, {"st": 31, "ed": 33, "text": "recent works"}, {"st": 35, "ed": 37, "text": "relational semantics"}, {"st": 38, "ed": 40, "text": "linear logic"}, {"st": 43, "ed": 46, "text": "idempotent intersection types"}, {"st": 53, "ed": 55, "text": "type system"}, {"st": 63, "ed": 65, "text": "second translation"}, {"st": 66, "ed": 68, "text": "intuitionistic logic"}, {"st": 90, "ed": 92, "text": "typing tree"}, {"st": 93, "ed": 95, "text": "enough information"}, {"st": 104, "ed": 106, "text": "lazy call"}, {"st": 109, "ed": 111, "text": "value reduction"}, {"st": 116, "ed": 118, "text": "typing tree"}, {"st": 126, "ed": 128, "text": "exact length"}]
[{"st": 13, "ed": 17, "text": "monadic second order logic"}]
[{"st": 29, "ed": 31, "text": "base structure"}, {"st": 32, "ed": 34, "text": "several logics"}, {"st": 46, "ed": 50, "text": "monadic second order logic"}, {"st": 51, "ed": 53, "text": "certain subsets"}, {"st": 57, "ed": 59, "text": "finite sets"}, {"st": 63, "ed": 65, "text": "finite unions"}, {"st": 77, "ed": 79, "text": "Stupp iteration"}, {"st": 87, "ed": 89, "text": "base structure"}]
[{"st": 7, "ed": 9, "text": "automatic structures"}]
[{"st": 16, "ed": 18, "text": "automatic structures"}, {"st": 25, "ed": 27, "text": "such structures"}, {"st": 30, "ed": 32, "text": "order logic"}, {"st": 37, "ed": 39, "text": "order quantifiers"}, {"st": 73, "ed": 78, "text": "proof identifies certain algebraic properties"}, {"st": 89, "ed": 92, "text": "regular equivalence relation"}, {"st": 93, "ed": 95, "text": "countable index"}, {"st": 99, "ed": 101, "text": "regular set"}, {"st": 111, "ed": 113, "text": "countable structure"}, {"st": 116, "ed": 118, "text": "\\omega$-automatic presentation"}, {"st": 124, "ed": 126, "text": "finite words"}, {"st": 132, "ed": 134, "text": "recent result"}, {"st": 149, "ed": 151, "text": "automatic structure"}, {"st": 154, "ed": 156, "text": "injective presentation"}]
[]
[{"st": 13, "ed": 15, "text": "formal theory"}, {"st": 21, "ed": 24, "text": "simple algebraic theory"}, {"st": 25, "ed": 27, "text": "rational budgets"}, {"st": 42, "ed": 44, "text": "rational numbers"}, {"st": 51, "ed": 53, "text": "tuplix calculus"}, {"st": 61, "ed": 63, "text": "totalized models"}, {"st": 65, "ed": 67, "text": "rational numbers"}, {"st": 71, "ed": 73, "text": "case study"}, {"st": 75, "ed": 77, "text": "educational budget"}, {"st": 79, "ed": 84, "text": "university department offering master programs"}]
[{"st": 1, "ed": 3, "text": "ExpTime Procedure"}, {"st": 4, "ed": 6, "text": "Description Logic"}]
[{"st": 3, "ed": 6, "text": "case ExpTime tableau"}, {"st": 8, "ed": 10, "text": "decision procedure"}, {"st": 14, "ed": 16, "text": "satisfiability problem"}, {"st": 18, "ed": 20, "text": "\\mathcal{ALCQI}$ w.r.t"}, {"st": 21, "ed": 23, "text": "general axioms"}]
[{"st": 4, "ed": 6, "text": "Selective Unification"}, {"st": 7, "ed": 9, "text": "Concolic Testing"}, {"st": 10, "ed": 12, "text": "Logic Programs"}]
[{"st": 0, "ed": 2, "text": "Concolic testing"}, {"st": 4, "ed": 8, "text": "popular dynamic validation technique"}, {"st": 14, "ed": 16, "text": "model checking"}, {"st": 17, "ed": 21, "text": "automatic test case generation"}, {"st": 26, "ed": 28, "text": "concolic testing"}, {"st": 32, "ed": 34, "text": "logic programming"}, {"st": 38, "ed": 40, "text": "previous approaches"}, {"st": 42, "ed": 44, "text": "key ingredient"}, {"st": 55, "ed": 57, "text": "time goals"}, {"st": 60, "ed": 62, "text": "possible ways"}, {"st": 71, "ed": 73, "text": "program clauses"}, {"st": 78, "ed": 81, "text": "selective \" unification"}, {"st": 97, "ed": 99, "text": "different alternatives"}, {"st": 106, "ed": 108, "text": "complete algorithm"}, {"st": 109, "ed": 111, "text": "selective unification"}]
[{"st": 5, "ed": 9, "text": "order Abstract Syntax Specifications"}]
[{"st": 0, "ed": 3, "text": "Nominal abstract syntax"}, {"st": 6, "ed": 9, "text": "order abstract syntax"}, {"st": 14, "ed": 16, "text": "binding structure"}, {"st": 22, "ed": 24, "text": "traditional techniques"}, {"st": 30, "ed": 32, "text": "different communities"}, {"st": 36, "ed": 38, "text": "similar lines"}, {"st": 40, "ed": 42, "text": "subtle differences"}, {"st": 50, "ed": 54, "text": "nominal abstract syntax community"}, {"st": 65, "ed": 67, "text": "variable capture"}, {"st": 78, "ed": 82, "text": "order abstract syntax community"}, {"st": 111, "ed": 113, "text": "concrete correspondence"}, {"st": 115, "ed": 117, "text": "different devices"}, {"st": 134, "ed": 137, "text": "nominal abstract syntax"}, {"st": 138, "ed": 141, "text": "logic programming language"}, {"st": 148, "ed": 151, "text": "order abstract syntax"}, {"st": 152, "ed": 155, "text": "logic programming language"}, {"st": 161, "ed": 163, "text": "order judgments"}, {"st": 167, "ed": 169, "text": "powerful tool"}, {"st": 174, "ed": 177, "text": "order abstract syntax"}, {"st": 201, "ed": 204, "text": "order abstract syntax"}, {"st": 209, "ed": 211, "text": "variable control"}, {"st": 212, "ed": 214, "text": "nominal specifications"}, {"st": 217, "ed": 219, "text": "desirable properties"}, {"st": 222, "ed": 224, "text": "order judgments"}]
[{"st": 0, "ed": 2, "text": "Categorical Models"}, {"st": 4, "ed": 7, "text": "Semantically Linear Lambda"}]
[{"st": 5, "ed": 7, "text": "categorical approach"}, {"st": 11, "ed": 16, "text": "simple Semantically Linear lambda calculus"}, {"st": 25, "ed": 27, "text": "core calculus"}, {"st": 29, "ed": 32, "text": "programming language SlPCF"}, {"st": 56, "ed": 58, "text": "large class"}, {"st": 59, "ed": 61, "text": "sound models"}, {"st": 72, "ed": 75, "text": "natural way Benton"}, {"st": 80, "ed": 82, "text": "de Paiva"}, {"st": 83, "ed": 85, "text": "Linear Category"}, {"st": 106, "ed": 108, "text": "interesting models"}, {"st": 109, "ed": 111, "text": "Scott Domains"}, {"st": 112, "ed": 114, "text": "Coherence Spaces"}]
[{"st": 2, "ed": 4, "text": "Bound Quantification"}, {"st": 5, "ed": 7, "text": "Graph Transformation"}]
[{"st": 0, "ed": 2, "text": "Graph transformation"}, {"st": 7, "ed": 9, "text": "concurrent systems"}, {"st": 10, "ed": 12, "text": "software engineering"}, {"st": 19, "ed": 21, "text": "life sciences"}, {"st": 26, "ed": 28, "text": "transformation rule"}, {"st": 52, "ed": 55, "text": "intuitionistic linear logic"}, {"st": 61, "ed": 63, "text": "bound quantification"}, {"st": 67, "ed": 69, "text": "implicit handling"}, {"st": 71, "ed": 73, "text": "DPO conditions"}, {"st": 76, "ed": 78, "text": "resource logic"}, {"st": 84, "ed": 87, "text": "graph transformation systems"}]
[{"st": 5, "ed": 7, "text": "Explicit Copy"}]
[{"st": 8, "ed": 10, "text": "explicit substitution"}, {"st": 20, "ed": 22, "text": "close correspondence"}, {"st": 25, "ed": 27, "text": "labelled lambda"}, {"st": 39, "ed": 41, "text": "important role"}, {"st": 58, "ed": 60, "text": "labelled lambda"}, {"st": 65, "ed": 67, "text": "multiplicative information"}, {"st": 79, "ed": 83, "text": "labelled explicit substitution calculi"}, {"st": 88, "ed": 91, "text": "exponential information present"}, {"st": 102, "ed": 104, "text": "name translations"}, {"st": 110, "ed": 113, "text": "linear logic proof"}]
[{"st": 2, "ed": 6, "text": "Generic Process Shape Types"}]
[{"st": 0, "ed": 2, "text": "Shape types"}, {"st": 4, "ed": 6, "text": "general concept"}, {"st": 7, "ed": 9, "text": "process types"}, {"st": 12, "ed": 15, "text": "many process calculi"}, {"st": 21, "ed": 24, "text": "Poly * system"}, {"st": 25, "ed": 27, "text": "shape types"}, {"st": 38, "ed": 40, "text": "extended system"}, {"st": 43, "ed": 45, "text": "shape types"}, {"st": 59, "ed": 61, "text": "Mobile Ambients"}, {"st": 66, "ed": 68, "text": "extended system"}, {"st": 75, "ed": 77, "text": "shape types"}, {"st": 81, "ed": 83, "text": "principal typings"}, {"st": 86, "ed": 89, "text": "type inference implementation"}]
[{"st": 3, "ed": 5, "text": "Layer Communications"}, {"st": 6, "ed": 8, "text": "Wireless Systems"}]
[{"st": 3, "ed": 6, "text": "timed process calculus"}, {"st": 8, "ed": 10, "text": "wireless networks"}, {"st": 12, "ed": 15, "text": "individual stations broadcast"}, {"st": 16, "ed": 18, "text": "receive messages"}, {"st": 30, "ed": 32, "text": "reduction semantics"}, {"st": 38, "ed": 40, "text": "contextual equivalence"}, {"st": 43, "ed": 45, "text": "external behaviour"}, {"st": 46, "ed": 49, "text": "such wireless networks"}, {"st": 55, "ed": 57, "text": "extensional LTS"}, {"st": 59, "ed": 61, "text": "transition system"}, {"st": 75, "ed": 77, "text": "external environment"}, {"st": 78, "ed": 80, "text": "Standard bisimulations"}, {"st": 85, "ed": 88, "text": "sound proof method"}, {"st": 100, "ed": 102, "text": "proof methodology"}, {"st": 113, "ed": 115, "text": "proof method"}, {"st": 121, "ed": 123, "text": "large class"}]
[{"st": 3, "ed": 5, "text": "Separation Logic"}, {"st": 6, "ed": 9, "text": "Multithreaded Java Programs"}]
[{"st": 4, "ed": 6, "text": "program logic"}, {"st": 15, "ed": 18, "text": "dynamic thread creation"}, {"st": 19, "ed": 21, "text": "thread joining"}, {"st": 22, "ed": 25, "text": "reentrant object monitors"}, {"st": 31, "ed": 34, "text": "concurrent separation logic"}, {"st": 38, "ed": 41, "text": "first detailed adaptation"}, {"st": 42, "ed": 45, "text": "concurrent separation logic"}, {"st": 50, "ed": 52, "text": "like language"}, {"st": 54, "ed": 56, "text": "program logic"}, {"st": 58, "ed": 62, "text": "unique static access permission"}, {"st": 64, "ed": 66, "text": "heap location"}, {"st": 68, "ed": 71, "text": "exclusive write accesses"}, {"st": 74, "ed": 76, "text": "data races"}, {"st": 77, "ed": 79, "text": "Concurrent reads"}, {"st": 82, "ed": 84, "text": "fractional permissions"}, {"st": 92, "ed": 94, "text": "thread starting"}, {"st": 95, "ed": 97, "text": "thread joining"}, {"st": 98, "ed": 101, "text": "initial monitor entrancies"}, {"st": 102, "ed": 105, "text": "final monitor exits"}, {"st": 111, "ed": 114, "text": "initial monitor entrancies"}, {"st": 115, "ed": 117, "text": "monitor reentrancies"}, {"st": 118, "ed": 120, "text": "auxiliary variables"}, {"st": 129, "ed": 131, "text": "Data abstraction"}, {"st": 132, "ed": 134, "text": "behavioral subtyping"}, {"st": 137, "ed": 139, "text": "abstract predicates"}, {"st": 146, "ed": 148, "text": "monitor invariants"}, {"st": 151, "ed": 153, "text": "thread starting"}, {"st": 156, "ed": 158, "text": "thread joining"}, {"st": 161, "ed": 163, "text": "parametrized types"}, {"st": 166, "ed": 171, "text": "capture common strong global invariants"}, {"st": 173, "ed": 177, "text": "static object ownership relations"}, {"st": 179, "ed": 181, "text": "program logic"}, {"st": 185, "ed": 187, "text": "model language"}, {"st": 199, "ed": 201, "text": "program logic"}, {"st": 208, "ed": 210, "text": "illustrative examples"}]
[]
[{"st": 35, "ed": 39, "text": "X|X = t_X \\rangle$"}, {"st": 45, "ed": 47, "text": "\\sqsubseteq_{RS}$. Second"}]
[{"st": 5, "ed": 8, "text": "Clocked Boehm Trees"}]
[{"st": 31, "ed": 34, "text": "usual Boehm Trees"}, {"st": 43, "ed": 46, "text": "same Boehm Tree"}, {"st": 57, "ed": 60, "text": "fixed point combinators"}, {"st": 66, "ed": 68, "text": "same BT"}, {"st": 70, "ed": 72, "text": "interesting equation"}, {"st": 81, "ed": 84, "text": "BY = BYS"}, {"st": 86, "ed": 88, "text": "equation valid"}, {"st": 90, "ed": 93, "text": "classical model P"}, {"st": 120, "ed": 122, "text": "such beta"}, {"st": 151, "ed": 153, "text": "Boehm Trees"}, {"st": 158, "ed": 161, "text": "intrinsic clock behaviour"}, {"st": 166, "ed": 168, "text": "discrimination method"}, {"st": 174, "ed": 176, "text": "corresponding equality"}, {"st": 184, "ed": 187, "text": "Boehm Tree equality"}, {"st": 192, "ed": 194, "text": "model P"}, {"st": 198, "ed": 201, "text": "analogous approach pertains"}, {"st": 206, "ed": 208, "text": "Berarducci Trees"}, {"st": 210, "ed": 213, "text": "refined Boehm Trees"}, {"st": 221, "ed": 225, "text": "discriminating fixed point combinators"}, {"st": 236, "ed": 240, "text": "equation BY = BYS"}, {"st": 256, "ed": 258, "text": "production schemes"}, {"st": 269, "ed": 271, "text": "new fpc"}, {"st": 277, "ed": 279, "text": "term SI"}, {"st": 303, "ed": 305, "text": "clocked BT"}, {"st": 314, "ed": 316, "text": "new fpc"}, {"st": 329, "ed": 331, "text": "discrimination power"}, {"st": 336, "ed": 338, "text": "clock notion"}, {"st": 342, "ed": 344, "text": "atomic clock"}]
[{"st": 0, "ed": 3, "text": "DBGen User Manual"}]
[{"st": 5, "ed": 7, "text": "Coq developers"}, {"st": 16, "ed": 18, "text": "term structure"}, {"st": 19, "ed": 21, "text": "bindings annotations"}, {"st": 22, "ed": 24, "text": "generates definitions"}, {"st": 32, "ed": 35, "text": "De Bruijn setting"}, {"st": 39, "ed": 41, "text": "substitution lemma"}, {"st": 50, "ed": 52, "text": "translation function"}, {"st": 54, "ed": 57, "text": "De Bruijn syntax"}]
[{"st": 9, "ed": 11, "text": "Compositionality Requirements"}, {"st": 12, "ed": 14, "text": "Process Semantics"}]
[{"st": 3, "ed": 6, "text": "basic sanity properties"}, {"st": 8, "ed": 10, "text": "behavioural semantics"}, {"st": 20, "ed": 22, "text": "process operators"}, {"st": 33, "ed": 35, "text": "rule formats"}, {"st": 36, "ed": 39, "text": "transition system specifications"}, {"st": 41, "ed": 43, "text": "process algebras"}, {"st": 52, "ed": 54, "text": "orthogonal approach"}, {"st": 63, "ed": 65, "text": "process operators"}, {"st": 76, "ed": 78, "text": "possible class"}, {"st": 93, "ed": 95, "text": "Milner logic"}, {"st": 101, "ed": 103, "text": "modal characterization"}, {"st": 123, "ed": 125, "text": "action prefix"}, {"st": 126, "ed": 128, "text": "alternative composition"}, {"st": 130, "ed": 132, "text": "restriction operators"}, {"st": 134, "ed": 136, "text": "parallel composition"}]
[{"st": 0, "ed": 2, "text": "Structural Decomposition"}]
[{"st": 2, "ed": 4, "text": "decomposition problems"}, {"st": 10, "ed": 13, "text": "Computational Systems Biology"}, {"st": 14, "ed": 16, "text": "recent work"}, {"st": 19, "ed": 21, "text": "graph transformation"}, {"st": 27, "ed": 29, "text": "arbitrary colimits"}, {"st": 31, "ed": 34, "text": "deconstruct \" models"}, {"st": 44, "ed": 46, "text": "adhesive categories"}, {"st": 48, "ed": 50, "text": "fundamental problem"}, {"st": 54, "ed": 56, "text": "complex reactions"}, {"st": 57, "ed": 59, "text": "large states"}, {"st": 60, "ed": 62, "text": "simpler reactions"}, {"st": 70, "ed": 73, "text": "local decomposition problem"}, {"st": 94, "ed": 96, "text": "\" ones"}, {"st": 107, "ed": 109, "text": "source object"}, {"st": 118, "ed": 120, "text": "first result"}, {"st": 124, "ed": 126, "text": "colimit decomposition"}, {"st": 127, "ed": 131, "text": "arbitrary double pushout transformations"}, {"st": 139, "ed": 144, "text": "several \" local \" transformations"}, {"st": 149, "ed": 153, "text": "single \" global \""}, {"st": 161, "ed": 163, "text": "certain class"}, {"st": 164, "ed": 167, "text": "local decomposition problems"}, {"st": 173, "ed": 176, "text": "clarifies recent work"}, {"st": 179, "ed": 181, "text": "graph transformation"}]
[{"st": 0, "ed": 2, "text": "Type Classes"}, {"st": 5, "ed": 7, "text": "Type Theory"}]
[{"st": 5, "ed": 8, "text": "class type classes"}, {"st": 10, "ed": 12, "text": "Coq system"}, {"st": 19, "ed": 21, "text": "basic interfaces"}, {"st": 23, "ed": 25, "text": "mathematical formalization"}, {"st": 26, "ed": 28, "text": "type theory"}, {"st": 32, "ed": 34, "text": "new set"}, {"st": 35, "ed": 37, "text": "type classes"}, {"st": 41, "ed": 43, "text": "full advantage"}, {"st": 45, "ed": 47, "text": "unique features"}, {"st": 52, "ed": 54, "text": "flexible approach"}, {"st": 63, "ed": 67, "text": "traditional proof engineering challenges"}, {"st": 70, "ed": 72, "text": "new ones"}, {"st": 84, "ed": 86, "text": "constructive analysis"}, {"st": 88, "ed": 90, "text": "abstraction penalties"}, {"st": 91, "ed": 93, "text": "efficient computation"}, {"st": 106, "ed": 108, "text": "type classes"}, {"st": 110, "ed": 113, "text": "standard algebraic hierarchy"}, {"st": 119, "ed": 121, "text": "category theory"}, {"st": 122, "ed": 124, "text": "universal algebra"}, {"st": 134, "ed": 137, "text": "sound abstract interfaces"}, {"st": 138, "ed": 140, "text": "different kinds"}, {"st": 146, "ed": 148, "text": "categorical language"}, {"st": 149, "ed": 152, "text": "universal algebra constructions"}, {"st": 153, "ed": 155, "text": "Strategic use"}, {"st": 156, "ed": 158, "text": "type classes"}, {"st": 164, "ed": 166, "text": "level theory"}, {"st": 167, "ed": 169, "text": "friendly definitions"}, {"st": 172, "ed": 174, "text": "efficient implementations"}, {"st": 176, "ed": 178, "text": "gratuitous indirection"}, {"st": 199, "ed": 203, "text": "type class instance resolution"}, {"st": 209, "ed": 211, "text": "quote function"}, {"st": 217, "ed": 219, "text": "reflective techniques"}]
[{"st": 1, "ed": 3, "text": "Paraconsistent Weakening"}, {"st": 4, "ed": 6, "text": "Intuitionistic Negation"}]
[{"st": 9, "ed": 12, "text": "intuitionistic negation logic"}, {"st": 22, "ed": 24, "text": "da Costa"}, {"st": 36, "ed": 38, "text": "da Costa"}, {"st": 40, "ed": 42, "text": "fundamental properties"}, {"st": 49, "ed": 51, "text": "distributive lattices"}, {"st": 71, "ed": 73, "text": "intuitionistic logic"}, {"st": 89, "ed": 91, "text": "modified systems"}]
[{"st": 3, "ed": 5, "text": "Parity Games"}]
[{"st": 3, "ed": 6, "text": "process theoretic notion"}, {"st": 13, "ed": 15, "text": "parity games"}, {"st": 20, "ed": 22, "text": "equivalent vertices"}, {"st": 24, "ed": 26, "text": "same winner"}, {"st": 28, "ed": 30, "text": "parity game"}, {"st": 36, "ed": 38, "text": "parity game"}, {"st": 44, "ed": 46, "text": "game graph"}, {"st": 73, "ed": 76, "text": "typical verification problems"}, {"st": 79, "ed": 81, "text": "equivalence speeds"}, {"st": 83, "ed": 85, "text": "parity games"}, {"st": 86, "ed": 88, "text": "many cases"}]
[{"st": 5, "ed": 7, "text": "Hybrid Automata"}]
[{"st": 9, "ed": 11, "text": "reachability problem"}, {"st": 12, "ed": 15, "text": "rectangular hybrid automata"}, {"st": 18, "ed": 20, "text": "negative rates"}, {"st": 31, "ed": 36, "text": "decidable [ Brihaye et al"}, {"st": 37, "ed": 39, "text": "ICALP11 ]"}, {"st": 43, "ed": 46, "text": "unbounded reachability problem"}, {"st": 49, "ed": 51, "text": "simple classes"}, {"st": 52, "ed": 54, "text": "hybrid automata"}, {"st": 65, "ed": 67, "text": "[ Brihaye"}, {"st": 70, "ed": 72, "text": "ICALP11 ]"}, {"st": 76, "ed": 78, "text": "precise characterisation"}, {"st": 86, "ed": 88, "text": "reachability problem"}, {"st": 93, "ed": 95, "text": "present paper"}, {"st": 103, "ed": 106, "text": "new NExpTime algorithm"}, {"st": 112, "ed": 114, "text": "reachability problem"}, {"st": 124, "ed": 126, "text": "[ Brihaye"}, {"st": 129, "ed": 131, "text": "ICALP11 ]"}, {"st": 143, "ed": 145, "text": "new algorithm"}, {"st": 175, "ed": 177, "text": "practical direction"}, {"st": 203, "ed": 206, "text": "T time units"}]
[{"st": 10, "ed": 12, "text": "Finite Automata"}]
[{"st": 1, "ed": 3, "text": "new technique"}, {"st": 11, "ed": 13, "text": "term rewriting"}, {"st": 15, "ed": 17, "text": "basic idea"}, {"st": 23, "ed": 26, "text": "empty regular language"}, {"st": 37, "ed": 39, "text": "normal forms"}, {"st": 49, "ed": 51, "text": "tree automaton"}, {"st": 53, "ed": 55, "text": "fixed number"}, {"st": 61, "ed": 63, "text": "mentioned requirements"}, {"st": 65, "ed": 67, "text": "SAT formula"}, {"st": 81, "ed": 83, "text": "many examples"}, {"st": 97, "ed": 99, "text": "combinatory logic"}]
[{"st": 1, "ed": 3, "text": "Alloy Formulas"}, {"st": 5, "ed": 7, "text": "SMT Solver"}, {"st": 9, "ed": 11, "text": "Case Study"}]
[{"st": 7, "ed": 11, "text": "modern SAT Modulo theories"}, {"st": 21, "ed": 23, "text": "book problem"}, {"st": 30, "ed": 33, "text": "order relational logic"}, {"st": 34, "ed": 36, "text": "transitive closure"}, {"st": 37, "ed": 39, "text": "Current analysis"}, {"st": 40, "ed": 42, "text": "Alloy models"}, {"st": 47, "ed": 49, "text": "Alloy Analyzer"}, {"st": 77, "ed": 79, "text": "background theories"}, {"st": 85, "ed": 87, "text": "type finitization"}, {"st": 111, "ed": 113, "text": "Alloy Analyzer"}, {"st": 120, "ed": 122, "text": "experimental results"}, {"st": 133, "ed": 135, "text": "Alloy Analyzer"}, {"st": 136, "ed": 138, "text": "various versions"}, {"st": 140, "ed": 143, "text": "address book problem"}]
[{"st": 1, "ed": 3, "text": "Minimal Corrections"}]
[{"st": 2, "ed": 4, "text": "programming paradigm"}, {"st": 14, "ed": 16, "text": "usual issue"}, {"st": 18, "ed": 20, "text": "human error"}, {"st": 50, "ed": 52, "text": "minimal correction"}, {"st": 54, "ed": 57, "text": "contradictory ASP program"}, {"st": 59, "ed": 62, "text": "contradictory ASP program"}, {"st": 71, "ed": 73, "text": "automated way"}, {"st": 80, "ed": 83, "text": "minimal correction set"}, {"st": 85, "ed": 87, "text": "contradictory program"}, {"st": 90, "ed": 92, "text": "irreducible set"}, {"st": 98, "ed": 100, "text": "program consistent"}, {"st": 104, "ed": 106, "text": "propositional logic"}, {"st": 109, "ed": 111, "text": "ASP programs"}, {"st": 130, "ed": 132, "text": "propositional logic"}, {"st": 139, "ed": 141, "text": "experimental evaluation"}, {"st": 149, "ed": 151, "text": "such algorithms"}]
[{"st": 2, "ed": 6, "text": "order definable string transformations"}]
[{"st": 6, "ed": 8, "text": "computational models"}, {"st": 20, "ed": 22, "text": "order logic"}, {"st": 23, "ed": 25, "text": "finite automata"}, {"st": 47, "ed": 49, "text": "Similar connections"}, {"st": 54, "ed": 56, "text": "order logic"}, {"st": 57, "ed": 59, "text": "finite automata"}, {"st": 60, "ed": 63, "text": "certain aperiodicity restriction"}, {"st": 80, "ed": 82, "text": "output structure"}, {"st": 85, "ed": 87, "text": "logical formulas"}, {"st": 90, "ed": 92, "text": "input structure"}, {"st": 98, "ed": 102, "text": "corresponding \" automata connection"}, {"st": 108, "ed": 112, "text": "way generalised sequential machines"}, {"st": 118, "ed": 122, "text": "second order definable transformations"}, {"st": 135, "ed": 139, "text": "way deterministic transducer model"}, {"st": 140, "ed": 142, "text": "string variables"}, {"st": 152, "ed": 154, "text": "same class"}, {"st": 165, "ed": 167, "text": "logic correspondence"}, {"st": 172, "ed": 176, "text": "order definable string transformations"}, {"st": 180, "ed": 182, "text": "new notion"}, {"st": 183, "ed": 185, "text": "transition monoid"}, {"st": 191, "ed": 193, "text": "structural properties"}, {"st": 196, "ed": 198, "text": "input automata"}, {"st": 199, "ed": 201, "text": "variable dependencies"}, {"st": 205, "ed": 207, "text": "aperiodicity restriction"}, {"st": 209, "ed": 211, "text": "transition monoids"}, {"st": 228, "ed": 231, "text": "order definable transformations"}]
[{"st": 0, "ed": 3, "text": "Concurrent Kleene Algebra"}, {"st": 4, "ed": 6, "text": "Partial Strings"}]
[{"st": 0, "ed": 3, "text": "Concurrent Kleene Algebra"}, {"st": 10, "ed": 12, "text": "algebraic structure"}, {"st": 21, "ed": 23, "text": "concurrent programming"}, {"st": 25, "ed": 27, "text": "unifying power"}, {"st": 36, "ed": 38, "text": "exchange law"}, {"st": 43, "ed": 46, "text": "sequential composition operators"}, {"st": 52, "ed": 55, "text": "extensive theoretical work"}, {"st": 56, "ed": 58, "text": "true concurrency"}, {"st": 67, "ed": 69, "text": "pomset model"}, {"st": 71, "ed": 74, "text": "fixed point operators"}, {"st": 77, "ed": 80, "text": "program refinement relation"}, {"st": 83, "ed": 86, "text": "monotonic bijective morphisms"}, {"st": 89, "ed": 92, "text": "partial order model"}, {"st": 112, "ed": 114, "text": "concurrent programs"}, {"st": 131, "ed": 134, "text": "access relaxed memory"}, {"st": 137, "ed": 139, "text": "subsequent work"}]
[{"st": 0, "ed": 2, "text": "Polynomial Interpretations"}, {"st": 8, "ed": 10, "text": "Real Numbers"}]
[{"st": 0, "ed": 2, "text": "Polynomial interpretations"}, {"st": 4, "ed": 6, "text": "useful technique"}, {"st": 10, "ed": 13, "text": "term rewrite systems"}, {"st": 17, "ed": 19, "text": "various flavors"}, {"st": 20, "ed": 22, "text": "polynomial interpretations"}, {"st": 27, "ed": 29, "text": "integer coefficients"}, {"st": 50, "ed": 52, "text": "rewrite systems"}, {"st": 59, "ed": 61, "text": "polynomial interpretations"}, {"st": 78, "ed": 80, "text": "rational coefficients"}, {"st": 86, "ed": 88, "text": "corresponding statement"}, {"st": 92, "ed": 94, "text": "rational coefficients"}, {"st": 95, "ed": 97, "text": "integer coefficients"}, {"st": 109, "ed": 111, "text": "full picture"}, {"st": 116, "ed": 118, "text": "aforementioned variants"}, {"st": 119, "ed": 121, "text": "polynomial interpretations"}, {"st": 128, "ed": 130, "text": "polynomial interpretations"}, {"st": 133, "ed": 135, "text": "rational coefficients"}, {"st": 138, "ed": 140, "text": "polynomial interpretations"}, {"st": 141, "ed": 143, "text": "integer coefficients"}, {"st": 149, "ed": 152, "text": "incremental termination proofs"}, {"st": 153, "ed": 155, "text": "polynomial interpretations"}]
[{"st": 2, "ed": 4, "text": "relational models"}]
[{"st": 10, "ed": 12, "text": "simple set"}, {"st": 46, "ed": 48, "text": "formal system"}, {"st": 51, "ed": 54, "text": "suitable semantic models"}, {"st": 71, "ed": 73, "text": "Heyting algebras"}, {"st": 74, "ed": 76, "text": "Boolean operators"}]
[{"st": 1, "ed": 3, "text": "DRAT format"}, {"st": 6, "ed": 8, "text": "trim checker"}]
[{"st": 4, "ed": 6, "text": "DRAT format"}, {"st": 7, "ed": 9, "text": "clausal proofs"}, {"st": 13, "ed": 16, "text": "trim proof checker"}]
[{"st": 3, "ed": 5, "text": "Infinite Data"}]
[{"st": 3, "ed": 5, "text": "subtle issues"}, {"st": 12, "ed": 15, "text": "infinite data structures"}, {"st": 31, "ed": 34, "text": "name functional core"}, {"st": 38, "ed": 40, "text": "communication primitives"}, {"st": 43, "ed": 45, "text": "session operations"}, {"st": 50, "ed": 52, "text": "demand \""}, {"st": 56, "ed": 58, "text": "typing discipline"}, {"st": 72, "ed": 74, "text": "unexpected interplay"}]
[{"st": 0, "ed": 2, "text": "Compositional bisimulation"}, {"st": 5, "ed": 8, "text": "Probabilistic Process Calculi"}]
[{"st": 6, "ed": 10, "text": "probabilistic process calculi allow"}, {"st": 11, "ed": 13, "text": "compositional reasoning"}, {"st": 16, "ed": 19, "text": "bisimulation metric semantics"}, {"st": 23, "ed": 25, "text": "uniform continuity"}, {"st": 29, "ed": 31, "text": "proposed property"}, {"st": 38, "ed": 40, "text": "essential nature"}, {"st": 41, "ed": 43, "text": "compositional reasoning"}, {"st": 51, "ed": 53, "text": "recursive processes"}, {"st": 59, "ed": 61, "text": "probabilistic processes"}, {"st": 63, "ed": 67, "text": "standard process algebra operators"}, {"st": 75, "ed": 77, "text": "compositional reasoning"}, {"st": 81, "ed": 85, "text": "continuous process algebra operators"}, {"st": 92, "ed": 94, "text": "performance validation"}]
[{"st": 1, "ed": 4, "text": "Hybrid Hoare Logic"}, {"st": 5, "ed": 8, "text": "Gene Network Models"}]
[{"st": 1, "ed": 3, "text": "main difficulty"}, {"st": 5, "ed": 7, "text": "gene networks"}, {"st": 32, "ed": 34, "text": "real values"}, {"st": 41, "ed": 43, "text": "widespread idea"}, {"st": 46, "ed": 48, "text": "new constraints"}, {"st": 53, "ed": 55, "text": "possible values"}, {"st": 60, "ed": 62, "text": "new work"}, {"st": 65, "ed": 67, "text": "particular class"}, {"st": 68, "ed": 70, "text": "Hybrid automata"}, {"st": 73, "ed": 76, "text": "Thomas discrete models"}, {"st": 78, "ed": 80, "text": "discrete parameters"}, {"st": 83, "ed": 85, "text": "signed celerities"}, {"st": 89, "ed": 91, "text": "new approach"}, {"st": 92, "ed": 94, "text": "Hoare logic"}, {"st": 96, "ed": 98, "text": "precondition calculus"}, {"st": 100, "ed": 102, "text": "la Dijkstra"}, {"st": 108, "ed": 110, "text": "parameter values"}, {"st": 114, "ed": 116, "text": "proper specifications"}, {"st": 119, "ed": 121, "text": "biological traces"}, {"st": 122, "ed": 124, "text": "duration information"}, {"st": 130, "ed": 132, "text": "biological experiments"}, {"st": 140, "ed": 142, "text": "imperative programs"}, {"st": 144, "ed": 147, "text": "classical Hoare logic"}, {"st": 151, "ed": 154, "text": "hybrid Hoare logic"}, {"st": 156, "ed": 158, "text": "small model"}, {"st": 160, "ed": 162, "text": "lacI repressor"}, {"st": 164, "ed": 166, "text": "lactose operon"}]
[{"st": 0, "ed": 3, "text": "Reactive Turing Machines"}, {"st": 4, "ed": 6, "text": "Infinite Alphabets"}]
[{"st": 3, "ed": 6, "text": "Reactive Turing machine"}, {"st": 13, "ed": 15, "text": "orthogonal extension"}, {"st": 29, "ed": 32, "text": "executable transition system"}, {"st": 34, "ed": 36, "text": "same way"}, {"st": 37, "ed": 39, "text": "Turing machines"}, {"st": 46, "ed": 48, "text": "computable function"}, {"st": 49, "ed": 51, "text": "natural numbers"}, {"st": 70, "ed": 72, "text": "single step"}, {"st": 81, "ed": 83, "text": "finite set"}, {"st": 87, "ed": 89, "text": "process calculi"}, {"st": 101, "ed": 103, "text": "infinite alphabet"}, {"st": 112, "ed": 114, "text": "transition systems"}, {"st": 138, "ed": 140, "text": "infinite data"}, {"st": 144, "ed": 146, "text": "computable manner"}, {"st": 153, "ed": 155, "text": "several ways"}, {"st": 158, "ed": 160, "text": "finiteness requirement"}, {"st": 185, "ed": 187, "text": "infinitary RTM"}, {"st": 188, "ed": 190, "text": "Infinitary RTMs"}, {"st": 202, "ed": 204, "text": "expressiveness criterion"}, {"st": 213, "ed": 215, "text": "extra restrictions"}, {"st": 233, "ed": 235, "text": "restricted variant"}, {"st": 244, "ed": 246, "text": "data symbols"}, {"st": 259, "ed": 261, "text": "nominal executability"}, {"st": 271, "ed": 274, "text": "effective transition system"}, {"st": 300, "ed": 304, "text": "process specification language mCRL2"}, {"st": 318, "ed": 320, "text": "nominal executability"}, {"st": 322, "ed": 325, "text": "new expressiveness criterion"}, {"st": 326, "ed": 328, "text": "process calculi"}]
[{"st": 3, "ed": 5, "text": "Robustness Properties"}, {"st": 8, "ed": 11, "text": "Heap Separation Logic"}]
[{"st": 2, "ed": 4, "text": "heap automata"}, {"st": 11, "ed": 13, "text": "robustness properties"}, {"st": 15, "ed": 18, "text": "symbolic heap fragment"}, {"st": 19, "ed": 21, "text": "separation logic"}, {"st": 25, "ed": 27, "text": "inductive predicates"}, {"st": 28, "ed": 30, "text": "Robustness properties"}, {"st": 44, "ed": 46, "text": "wide range"}, {"st": 50, "ed": 53, "text": "automated program analysis"}, {"st": 57, "ed": 59, "text": "separation logic"}, {"st": 62, "ed": 64, "text": "such properties"}, {"st": 67, "ed": 69, "text": "many places"}, {"st": 71, "ed": 74, "text": "separation logic literature"}, {"st": 82, "ed": 84, "text": "systematic manner"}, {"st": 92, "ed": 94, "text": "algorithmic framework"}, {"st": 96, "ed": 98, "text": "heap automata"}, {"st": 104, "ed": 107, "text": "optimal decision procedures"}, {"st": 109, "ed": 111, "text": "wide range"}, {"st": 112, "ed": 114, "text": "robustness properties"}, {"st": 116, "ed": 118, "text": "uniform way"}, {"st": 128, "ed": 130, "text": "promising results"}, {"st": 134, "ed": 137, "text": "aforementioned robustness properties"}, {"st": 145, "ed": 147, "text": "heap automata"}, {"st": 148, "ed": 150, "text": "robustness properties"}, {"st": 154, "ed": 156, "text": "algorithmic framework"}, {"st": 158, "ed": 160, "text": "model checking"}, {"st": 162, "ed": 164, "text": "entailment problem"}, {"st": 167, "ed": 170, "text": "heap separation logic"}]
[{"st": 0, "ed": 3, "text": "Sequential decision problems"}, {"st": 4, "ed": 6, "text": "dependent types"}, {"st": 7, "ed": 9, "text": "generic solutions"}]
[{"st": 5, "ed": 8, "text": "checked generic implementation"}, {"st": 12, "ed": 16, "text": "horizon sequential decision problems"}, {"st": 20, "ed": 22, "text": "wide class"}, {"st": 28, "ed": 30, "text": "temporal optimizations"}, {"st": 33, "ed": 35, "text": "optimal bracketing"}, {"st": 46, "ed": 49, "text": "step dependent control"}, {"st": 50, "ed": 52, "text": "state spaces"}, {"st": 54, "ed": 56, "text": "monadic representations"}, {"st": 82, "ed": 84, "text": "programming language"}, {"st": 85, "ed": 87, "text": "dependent types"}, {"st": 97, "ed": 99, "text": "Dependent types"}, {"st": 113, "ed": 115, "text": "checked proof"}, {"st": 117, "ed": 119, "text": "central component"}, {"st": 130, "ed": 134, "text": "associated backwards induction algorithm"}, {"st": 138, "ed": 140, "text": "certain aspects"}, {"st": 141, "ed": 143, "text": "backwards induction"}, {"st": 147, "ed": 149, "text": "explicit notions"}, {"st": 159, "ed": 161, "text": "starting point"}, {"st": 167, "ed": 170, "text": "monadic dynamical systems"}, {"st": 177, "ed": 180, "text": "climate impact research"}]
[{"st": 0, "ed": 5, "text": "Efficient Certified Resolution Proof Checking"}]
[{"st": 3, "ed": 6, "text": "novel propositional proof"}, {"st": 10, "ed": 12, "text": "complex processing"}, {"st": 32, "ed": 34, "text": "proof checker"}, {"st": 46, "ed": 48, "text": "art checker"}, {"st": 58, "ed": 63, "text": "theory underlying propositional proof checking"}, {"st": 73, "ed": 76, "text": "construction proof checker"}, {"st": 84, "ed": 86, "text": "empirical evaluation"}, {"st": 88, "ed": 90, "text": "unsatisfiable instances"}, {"st": 95, "ed": 97, "text": "SAT competitions"}, {"st": 100, "ed": 102, "text": "certified checker"}, {"st": 117, "ed": 119, "text": "proof checker"}, {"st": 130, "ed": 132, "text": "TB proof"}, {"st": 134, "ed": 138, "text": "Boolean Pythagorean Triples conjecture"}]
[{"st": 2, "ed": 4, "text": "separation logic"}]
[{"st": 3, "ed": 5, "text": "new system"}, {"st": 8, "ed": 10, "text": "separation logic"}, {"st": 12, "ed": 16, "text": "interactive theorem prover Isabelle"}, {"st": 25, "ed": 27, "text": "auto2 prover"}, {"st": 40, "ed": 42, "text": "imperative programs"}, {"st": 52, "ed": 55, "text": "binary search trees"}, {"st": 63, "ed": 65, "text": "black trees"}, {"st": 66, "ed": 69, "text": "indexed priority queues"}, {"st": 75, "ed": 77, "text": "high degree"}, {"st": 83, "ed": 86, "text": "complicated data structures"}]
[{"st": 0, "ed": 2, "text": "Full abstraction"}]
[{"st": 1, "ed": 3, "text": "previous work"}, {"st": 19, "ed": 21, "text": "innocent form"}, {"st": 22, "ed": 24, "text": "presheaf semantics"}, {"st": 27, "ed": 29, "text": "concurrent form"}, {"st": 30, "ed": 32, "text": "game semantics"}, {"st": 49, "ed": 51, "text": "abstract w.r.t"}, {"st": 62, "ed": 65, "text": "new algebraic notion"}, {"st": 88, "ed": 91, "text": "labelled transition systems"}, {"st": 98, "ed": 100, "text": "functional bisimulation"}]
[{"st": 0, "ed": 2, "text": "Formal Design"}, {"st": 3, "ed": 6, "text": "Asynchronous Fault Detection"}, {"st": 7, "ed": 9, "text": "Identification Components"}, {"st": 10, "ed": 13, "text": "Temporal Epistemic Logic"}]
[{"st": 0, "ed": 3, "text": "Autonomous critical systems"}, {"st": 8, "ed": 10, "text": "space rovers"}, {"st": 24, "ed": 26, "text": "correct operation"}, {"st": 33, "ed": 35, "text": "Fault Detection"}, {"st": 59, "ed": 61, "text": "timely manner"}, {"st": 68, "ed": 70, "text": "predefined alarms"}, {"st": 74, "ed": 77, "text": "effective FDI components"}, {"st": 80, "ed": 82, "text": "hard problem"}, {"st": 90, "ed": 93, "text": "complete theoretical foundation"}, {"st": 96, "ed": 98, "text": "precise specification"}, {"st": 99, "ed": 101, "text": "validation techniques"}, {"st": 109, "ed": 112, "text": "first formal approach"}, {"st": 116, "ed": 118, "text": "FDI components"}, {"st": 119, "ed": 122, "text": "discrete event systems"}, {"st": 128, "ed": 130, "text": "asynchronous setting"}, {"st": 134, "ed": 136, "text": "logical language"}, {"st": 140, "ed": 142, "text": "FDI requirements"}, {"st": 146, "ed": 148, "text": "wide class"}, {"st": 149, "ed": 151, "text": "practical cases"}, {"st": 154, "ed": 156, "text": "novel aspects"}, {"st": 170, "ed": 172, "text": "clear semantics"}, {"st": 174, "ed": 177, "text": "temporal epistemic logic"}, {"st": 183, "ed": 185, "text": "suitable properties"}, {"st": 200, "ed": 202, "text": "FDI component"}, {"st": 217, "ed": 220, "text": "construction FDI components"}, {"st": 228, "ed": 230, "text": "design approach"}, {"st": 232, "ed": 234, "text": "industrial case"}]
[{"st": 0, "ed": 2, "text": "Compositional Verification"}, {"st": 3, "ed": 5, "text": "Timed Systems"}, {"st": 7, "ed": 10, "text": "Automatic Invariant Generation"}]
[{"st": 5, "ed": 7, "text": "compositional verification"}, {"st": 10, "ed": 15, "text": "state space explosion problem inherent"}, {"st": 23, "ed": 25, "text": "large number"}, {"st": 29, "ed": 31, "text": "main challenge"}, {"st": 34, "ed": 38, "text": "pertinent global timing constraints"}, {"st": 54, "ed": 56, "text": "auxiliary clocks"}, {"st": 59, "ed": 61, "text": "new invariants"}, {"st": 81, "ed": 83, "text": "Finder tool"}, {"st": 87, "ed": 89, "text": "several benchmarks"}]
[{"st": 7, "ed": 9, "text": "logical geometry"}]
[{"st": 36, "ed": 38, "text": "relation symbols"}, {"st": 52, "ed": 54, "text": "H$. Let"}, {"st": 59, "ed": 61, "text": "infinite set"}, {"st": 71, "ed": 73, "text": "finite subsets"}, {"st": 98, "ed": 100, "text": "knowledge base"}, {"st": 112, "ed": 114, "text": "knowledge bases"}, {"st": 119, "ed": 121, "text": "sufficient conditions"}, {"st": 125, "ed": 127, "text": "knowledge bases"}, {"st": 136, "ed": 138, "text": "sufficient conditions"}, {"st": 142, "ed": 144, "text": "knowledge bases"}]
[{"st": 3, "ed": 5, "text": "Conjunction Operation"}, {"st": 6, "ed": 9, "text": "Probabilistic Soft Logic"}]
[{"st": 0, "ed": 3, "text": "Probabilistic Soft Logic"}, {"st": 9, "ed": 11, "text": "several applications"}, {"st": 13, "ed": 15, "text": "efficient way"}, {"st": 22, "ed": 24, "text": "relational representation"}, {"st": 26, "ed": 28, "text": "several applications"}, {"st": 35, "ed": 37, "text": "adequate description"}, {"st": 50, "ed": 52, "text": "theoretical explanation"}, {"st": 58, "ed": 60, "text": "heuristic choices"}, {"st": 73, "ed": 76, "text": "corresponding conjunction operations"}, {"st": 83, "ed": 85, "text": "general family"}, {"st": 92, "ed": 94, "text": "future applications"}, {"st": 95, "ed": 98, "text": "probabilistic soft logic"}]
[{"st": 0, "ed": 2, "text": "Temporal Logics"}, {"st": 5, "ed": 8, "text": "Multiple Data Values"}]
[{"st": 4, "ed": 7, "text": "studies temporal logics"}, {"st": 8, "ed": 10, "text": "attributed words"}, {"st": 14, "ed": 16, "text": "data words"}, {"st": 34, "ed": 36, "text": "basic logic"}, {"st": 39, "ed": 41, "text": "semantical fragment"}, {"st": 66, "ed": 68, "text": "emptiness problem"}, {"st": 69, "ed": 71, "text": "data automata"}, {"st": 76, "ed": 78, "text": "basic logic"}, {"st": 83, "ed": 85, "text": "basic logic"}, {"st": 93, "ed": 95, "text": "data value"}, {"st": 107, "ed": 110, "text": "different data values"}, {"st": 113, "ed": 115, "text": "undecidable results"}, {"st": 123, "ed": 125, "text": "certain UNTIL"}, {"st": 129, "ed": 132, "text": "inequality target condition"}]
[{"st": 1, "ed": 4, "text": "Total Assignment Enumeration"}, {"st": 5, "ed": 8, "text": "Modern SAT Solver"}]
[{"st": 1, "ed": 3, "text": "new framework"}, {"st": 11, "ed": 13, "text": "modern DLL"}, {"st": 15, "ed": 17, "text": "SAT solver"}, {"st": 24, "ed": 26, "text": "inherent relation"}, {"st": 40, "ed": 43, "text": "modern SAT solver"}, {"st": 44, "ed": 46, "text": "DLL step"}, {"st": 54, "ed": 56, "text": "inference power"}, {"st": 57, "ed": 60, "text": "Boolean Constraint Propagation"}, {"st": 63, "ed": 65, "text": "Chronological Backtracking"}, {"st": 83, "ed": 87, "text": "modern SAT solver functionality"}, {"st": 92, "ed": 94, "text": "future work"}, {"st": 96, "ed": 98, "text": "inference power"}, {"st": 100, "ed": 103, "text": "modern SAT solver"}, {"st": 105, "ed": 109, "text": "practical SAT solver design"}]
[{"st": 9, "ed": 11, "text": "order logic"}]
[{"st": 9, "ed": 12, "text": "FPT graph algorithms"}, {"st": 32, "ed": 34, "text": "previous article"}, {"st": 71, "ed": 73, "text": "output functions"}, {"st": 88, "ed": 91, "text": "new algorithmic results"}, {"st": 92, "ed": 94, "text": "present tools"}, {"st": 97, "ed": 101, "text": "certain dynamic programming algorithms"}, {"st": 106, "ed": 108, "text": "basic functions"}]
[{"st": 0, "ed": 2, "text": "Pervasive Parallelism"}, {"st": 5, "ed": 10, "text": "Trustable Interactive Theorem Proving Systems"}]
[{"st": 8, "ed": 10, "text": "ITP project"}, {"st": 16, "ed": 19, "text": "proof assistants Isabelle"}, {"st": 20, "ed": 22, "text": "Coq fit"}, {"st": 24, "ed": 26, "text": "multicore era"}]
[{"st": 0, "ed": 2, "text": "Contract agreements"}]
[{"st": 3, "ed": 5, "text": "contract models"}, {"st": 9, "ed": 11, "text": "event structures"}, {"st": 12, "ed": 14, "text": "game theory"}, {"st": 40, "ed": 42, "text": "theoretic model"}, {"st": 50, "ed": 52, "text": "logical model"}]
[{"st": 1, "ed": 5, "text": "Real Quantifier Elimination Methods"}, {"st": 6, "ed": 9, "text": "Conflict Set Computation"}]
[{"st": 1, "ed": 3, "text": "satisfiability problem"}, {"st": 4, "ed": 7, "text": "real closed fields"}, {"st": 14, "ed": 17, "text": "satisfiability modulo theories"}, {"st": 22, "ed": 24, "text": "conjunctive sets"}, {"st": 32, "ed": 34, "text": "polynomial constraints"}, {"st": 37, "ed": 39, "text": "particular importance"}, {"st": 43, "ed": 45, "text": "central problems"}, {"st": 49, "ed": 51, "text": "good explanations"}, {"st": 55, "ed": 57, "text": "such sets"}, {"st": 61, "ed": 63, "text": "small subset"}, {"st": 65, "ed": 67, "text": "input constraints"}, {"st": 80, "ed": 82, "text": "elimination methods"}, {"st": 83, "ed": 86, "text": "cylindrical algebraic decomposition"}, {"st": 87, "ed": 89, "text": "virtual substitution"}, {"st": 92, "ed": 95, "text": "such conflict sets"}]
[{"st": 0, "ed": 2, "text": "Full abstraction"}, {"st": 3, "ed": 5, "text": "probabilistic PCF"}]
[{"st": 3, "ed": 5, "text": "probabilistic version"}, {"st": 13, "ed": 17, "text": "typed universal functional language"}, {"st": 19, "ed": 21, "text": "type hierarchy"}, {"st": 25, "ed": 28, "text": "single ground type"}, {"st": 29, "ed": 31, "text": "natural numbers"}, {"st": 51, "ed": 53, "text": "value evaluation"}, {"st": 54, "ed": 57, "text": "ground type arguments"}, {"st": 65, "ed": 68, "text": "suitable algorithmic expressiveness"}, {"st": 72, "ed": 74, "text": "denotational semantics"}, {"st": 76, "ed": 79, "text": "probabilistic coherence spaces"}, {"st": 83, "ed": 86, "text": "classical Linear Logic"}, {"st": 88, "ed": 90, "text": "previous works"}, {"st": 97, "ed": 101, "text": "equational full abstraction theorem"}, {"st": 110, "ed": 112, "text": "natural notion"}, {"st": 113, "ed": 115, "text": "observational equivalence"}]
[{"st": 7, "ed": 9, "text": "neighbourhood orders"}]
[{"st": 7, "ed": 9, "text": "intuitive language"}, {"st": 15, "ed": 18, "text": "symmetric monoidal category"}, {"st": 23, "ed": 25, "text": "infinite families"}, {"st": 38, "ed": 40, "text": "repeated structure"}, {"st": 53, "ed": 57, "text": "diagrammatic proof assistant Quantomatic"}, {"st": 79, "ed": 81, "text": "commutative theories"}, {"st": 85, "ed": 89, "text": "enriched abstract tensor notation"}, {"st": 107, "ed": 109, "text": "commutative structures"}, {"st": 115, "ed": 117, "text": "progress paper"}, {"st": 129, "ed": 131, "text": "additional structure"}, {"st": 146, "ed": 148, "text": "various tools"}, {"st": 151, "ed": 154, "text": "commutative diagrammatic reasoning"}]
[{"st": 2, "ed": 4, "text": "Comprehension Chains"}]
[{"st": 4, "ed": 7, "text": "fundamental mathematical constructions"}, {"st": 14, "ed": 16, "text": "categorical logic"}, {"st": 32, "ed": 34, "text": "quantum logic"}, {"st": 40, "ed": 42, "text": "classical logic"}, {"st": 49, "ed": 51, "text": "long series"}, {"st": 70, "ed": 73, "text": "von Neumann algebras"}, {"st": 81, "ed": 83, "text": "unifying theory"}, {"st": 96, "ed": 98, "text": "new quotient"}, {"st": 101, "ed": 103, "text": "comprehension perspective"}, {"st": 104, "ed": 106, "text": "measurement instruments"}]
[{"st": 0, "ed": 2, "text": "Equivalence Checking"}, {"st": 3, "ed": 5, "text": "Logic Relaxation"}]
[{"st": 3, "ed": 5, "text": "new framework"}, {"st": 6, "ed": 8, "text": "Equivalence Checking"}, {"st": 12, "ed": 14, "text": "Boolean circuits"}, {"st": 17, "ed": 19, "text": "general technique"}, {"st": 20, "ed": 22, "text": "Logic Relaxation"}, {"st": 41, "ed": 43, "text": "superset S"}, {"st": 47, "ed": 49, "text": "new behaviors"}, {"st": 70, "ed": 72, "text": "original formula"}, {"st": 73, "ed": 75, "text": "Set S"}, {"st": 87, "ed": 90, "text": "possible bad behaviors"}, {"st": 95, "ed": 97, "text": "original formula"}, {"st": 126, "ed": 129, "text": "powerful inductive proofs"}, {"st": 142, "ed": 144, "text": "bad behaviors"}, {"st": 146, "ed": 149, "text": "relaxed formula i.e."}, {"st": 151, "ed": 153, "text": "simpler version"}, {"st": 155, "ed": 157, "text": "original formula"}, {"st": 161, "ed": 163, "text": "experimental evidence"}]
[]
[{"st": 3, "ed": 5, "text": "synthesis problem"}, {"st": 6, "ed": 8, "text": "distributed architectures"}, {"st": 10, "ed": 12, "text": "parametric number"}, {"st": 15, "ed": 17, "text": "state components"}, {"st": 24, "ed": 26, "text": "synthesis setting"}, {"st": 44, "ed": 46, "text": "parameterized setting"}, {"st": 49, "ed": 51, "text": "classical result"}, {"st": 63, "ed": 65, "text": "indexed LTL\\X"}, {"st": 69, "ed": 72, "text": "token ring networks"}, {"st": 83, "ed": 85, "text": "few copies"}, {"st": 87, "ed": 89, "text": "single process"}, {"st": 104, "ed": 106, "text": "latter problem"}, {"st": 114, "ed": 116, "text": "decision procedure"}, {"st": 118, "ed": 121, "text": "parameterized synthesis problem"}, {"st": 122, "ed": 124, "text": "token rings"}, {"st": 127, "ed": 129, "text": "bounded synthesis"}, {"st": 140, "ed": 142, "text": "passing networks"}, {"st": 143, "ed": 145, "text": "arbitrary topologies"}, {"st": 151, "ed": 154, "text": "simple case study"}, {"st": 160, "ed": 162, "text": "general framework"}, {"st": 169, "ed": 173, "text": "other parameterized verification techniques"}]
[{"st": 0, "ed": 2, "text": "Algorithmic Introduction"}, {"st": 3, "ed": 5, "text": "Quantified Cuts"}]
[{"st": 15, "ed": 17, "text": "order logic"}, {"st": 23, "ed": 25, "text": "first computign"}, {"st": 26, "ed": 28, "text": "compressed representation"}, {"st": 36, "ed": 38, "text": "free proof"}, {"st": 65, "ed": 67, "text": "exponential compression"}, {"st": 68, "ed": 70, "text": "proof length"}, {"st": 79, "ed": 82, "text": "automated theorem provers"}, {"st": 86, "ed": 88, "text": "analytic proofs"}]
[{"st": 2, "ed": 6, "text": "Probabilistic Basic Parallel Processes"}]
[{"st": 0, "ed": 3, "text": "Basic Parallel Processes"}, {"st": 13, "ed": 15, "text": "Petri Nets"}, {"st": 19, "ed": 22, "text": "simplest common model"}, {"st": 23, "ed": 25, "text": "concurrent programs"}, {"st": 27, "ed": 29, "text": "unbounded spawning"}, {"st": 34, "ed": 36, "text": "probabilistic version"}, {"st": 42, "ed": 44, "text": "other processes"}, {"st": 47, "ed": 49, "text": "probability distribution"}, {"st": 57, "ed": 60, "text": "fundamental qualitative problems"}, {"st": 61, "ed": 63, "text": "probabilistic BPPs"}, {"st": 65, "ed": 67, "text": "particular reachability"}, {"st": 71, "ed": 73, "text": "different classes"}, {"st": 74, "ed": 76, "text": "target sets"}, {"st": 80, "ed": 82, "text": "closed sets"}, {"st": 85, "ed": 87, "text": "results concern"}, {"st": 91, "ed": 93, "text": "chain model"}, {"st": 102, "ed": 104, "text": "MDP model"}]
[{"st": 0, "ed": 2, "text": "Weak MSO"}, {"st": 5, "ed": 8, "text": "Expressiveness Modulo Bisimilarity"}]
[{"st": 6, "ed": 8, "text": "invariant fragment"}, {"st": 13, "ed": 15, "text": "order logic"}, {"st": 34, "ed": 36, "text": "fixpoint operator"}, {"st": 71, "ed": 73, "text": "expressive power"}, {"st": 76, "ed": 78, "text": "tree models"}, {"st": 79, "ed": 82, "text": "arbitrary branching degree"}, {"st": 84, "ed": 86, "text": "transition map"}, {"st": 105, "ed": 107, "text": "order logic"}, {"st": 117, "ed": 119, "text": "x. \\phi$"}, {"st": 124, "ed": 126, "text": "many objects"}, {"st": 130, "ed": 132, "text": "important part"}, {"st": 140, "ed": 142, "text": "theoretic analysis"}]
[{"st": 4, "ed": 6, "text": "Query Rewriting"}, {"st": 9, "ed": 11, "text": "QL Ontologies"}, {"st": 12, "ed": 14, "text": "Shallow Chases"}]
[{"st": 7, "ed": 9, "text": "order rewritings"}, {"st": 10, "ed": 12, "text": "conjunctive queries"}, {"st": 15, "ed": 17, "text": "QL ontologies"}, {"st": 25, "ed": 27, "text": "hypergraph programs"}, {"st": 28, "ed": 30, "text": "Boolean functions"}, {"st": 34, "ed": 36, "text": "negative results"}, {"st": 39, "ed": 41, "text": "Conjunctive queries"}, {"st": 49, "ed": 53, "text": "size nonrecursive datalog rewritings"}, {"st": 56, "ed": 58, "text": "shaped queries"}, {"st": 59, "ed": 63, "text": "polynomial positive existential rewritings"}, {"st": 71, "ed": 74, "text": "positive existential rewritings"}, {"st": 78, "ed": 80, "text": "superpolynomial size"}, {"st": 84, "ed": 87, "text": "nonrecursive datalog rewritings"}, {"st": 96, "ed": 98, "text": "exponential blowup"}, {"st": 106, "ed": 108, "text": "order rewritings"}, {"st": 123, "ed": 125, "text": "shaped queries"}, {"st": 126, "ed": 128, "text": "arbitrary ontologies"}, {"st": 132, "ed": 135, "text": "query entailment problem"}, {"st": 136, "ed": 138, "text": "such queries"}]
[{"st": 3, "ed": 5, "text": "fundamental structures"}]
[{"st": 0, "ed": 2, "text": "Process algebra"}, {"st": 6, "ed": 8, "text": "many ways"}, {"st": 19, "ed": 21, "text": "fundamental theory"}, {"st": 23, "ed": 25, "text": "fleeting glimpses"}, {"st": 28, "ed": 30, "text": "Petri Nets"}]
[{"st": 0, "ed": 2, "text": "Dialectica models"}, {"st": 5, "ed": 8, "text": "free linear logic"}]
[{"st": 7, "ed": 9, "text": "categorical models"}, {"st": 12, "ed": 16, "text": "free propositional linear logic"}, {"st": 23, "ed": 25, "text": "dialectica categories"}, {"st": 28, "ed": 30, "text": "functional interpretations"}, {"st": 31, "ed": 34, "text": "classical linear logic"}, {"st": 40, "ed": 43, "text": "dependent type theory"}, {"st": 49, "ed": 51, "text": "useful tool"}, {"st": 54, "ed": 56, "text": "dialectica categories"}, {"st": 62, "ed": 64, "text": "closure operator"}, {"st": 103, "ed": 105, "text": "game models"}, {"st": 109, "ed": 111, "text": "completeness theorems"}, {"st": 113, "ed": 116, "text": "specific such models"}]
[{"st": 3, "ed": 8, "text": "Free ExpTime Tableau Decision Procedure"}, {"st": 10, "ed": 13, "text": "Logic Extending Converse"}, {"st": 16, "ed": 19, "text": "Regular Inclusion Axioms"}]
[{"st": 3, "ed": 5, "text": "first cut"}, {"st": 6, "ed": 8, "text": "free ExpTime"}, {"st": 11, "ed": 14, "text": "tableau decision procedure"}, {"st": 16, "ed": 18, "text": "logic CPDLreg"}, {"st": 25, "ed": 28, "text": "regular inclusion axioms"}, {"st": 30, "ed": 32, "text": "finite automata"}, {"st": 34, "ed": 36, "text": "logic CPDLreg"}, {"st": 44, "ed": 47, "text": "regular grammar logic"}, {"st": 51, "ed": 54, "text": "tableau decision procedure"}, {"st": 55, "ed": 58, "text": "global state caching"}, {"st": 67, "ed": 70, "text": "various optimization techniques"}, {"st": 76, "ed": 78, "text": "fly propagation"}]
[{"st": 0, "ed": 3, "text": "Efficient Emptiness Check"}, {"st": 4, "ed": 7, "text": "Timed Buchi Automata"}, {"st": 8, "ed": 10, "text": "Extended version"}]
[{"st": 4, "ed": 6, "text": "emptiness problem"}, {"st": 7, "ed": 10, "text": "timed automata refers"}, {"st": 18, "ed": 20, "text": "infinite non"}, {"st": 30, "ed": 32, "text": "standard solution"}, {"st": 38, "ed": 40, "text": "auxiliary clock"}, {"st": 58, "ed": 60, "text": "simple transformation"}, {"st": 65, "ed": 67, "text": "exponential blowup"}, {"st": 82, "ed": 84, "text": "many cases"}, {"st": 92, "ed": 94, "text": "extra construction"}, {"st": 100, "ed": 102, "text": "fly algorithm"}, {"st": 106, "ed": 108, "text": "emptiness problem"}, {"st": 112, "ed": 114, "text": "Zenoness construction"}, {"st": 126, "ed": 128, "text": "prototype implementation"}]
[{"st": 2, "ed": 5, "text": "Linguistic Propositional Logic"}, {"st": 7, "ed": 11, "text": "Linear Symmetrical Hedge Algebra"}]
[{"st": 4, "ed": 7, "text": "propositional linguistic logic"}, {"st": 17, "ed": 19, "text": "linguistic information"}, {"st": 25, "ed": 28, "text": "linguistic logic system"}, {"st": 29, "ed": 32, "text": "truth value domain"}, {"st": 35, "ed": 39, "text": "linear symmetrical hedge algebra"}, {"st": 56, "ed": 58, "text": "logical connectives"}, {"st": 67, "ed": 70, "text": "resolution inference rule"}, {"st": 76, "ed": 80, "text": "contradictory linguistic truth values"}, {"st": 96, "ed": 98, "text": "approximative nature"}, {"st": 100, "ed": 103, "text": "resolution inference rule"}, {"st": 109, "ed": 111, "text": "resolution procedure"}, {"st": 113, "ed": 115, "text": "maximal reliability"}]
[{"st": 0, "ed": 3, "text": "Interactive Logic Programming"}, {"st": 6, "ed": 8, "text": "Disjunctive Clauses"}]
[{"st": 7, "ed": 9, "text": "essential task"}, {"st": 10, "ed": 12, "text": "Expressive logics"}, {"st": 18, "ed": 20, "text": "theoretical basis"}, {"st": 31, "ed": 34, "text": "linear logic languages"}, {"st": 49, "ed": 51, "text": "sole basis"}, {"st": 59, "ed": 61, "text": "game semantics"}, {"st": 73, "ed": 75, "text": "active participation"}, {"st": 93, "ed": 95, "text": "disjunctive clauses"}]
[{"st": 3, "ed": 5, "text": "Event Structures"}]
[{"st": 0, "ed": 2, "text": "Event Structures"}, {"st": 12, "ed": 14, "text": "causal relationships"}, {"st": 20, "ed": 23, "text": "other event relations"}, {"st": 31, "ed": 33, "text": "prominent variants"}, {"st": 36, "ed": 38, "text": "Prime ESs"}, {"st": 39, "ed": 41, "text": "Bundle ESs"}, {"st": 42, "ed": 44, "text": "Stable ESs"}, {"st": 46, "ed": 48, "text": "Dual ESs"}, {"st": 53, "ed": 55, "text": "causality models"}, {"st": 56, "ed": 58, "text": "event relations"}, {"st": 62, "ed": 64, "text": "application domains"}, {"st": 65, "ed": 67, "text": "further kinds"}, {"st": 80, "ed": 82, "text": "priority relationships"}, {"st": 94, "ed": 96, "text": "Extended Bundle"}, {"st": 98, "ed": 100, "text": "Dual ESs"}, {"st": 109, "ed": 111, "text": "same way"}, {"st": 125, "ed": 128, "text": "other event relations"}, {"st": 135, "ed": 137, "text": "redundant priority"}, {"st": 168, "ed": 170, "text": "partial orders"}]
[{"st": 0, "ed": 2, "text": "Towards Meta"}, {"st": 6, "ed": 10, "text": "Concurrent Logical Framework CLF"}]
[{"st": 1, "ed": 5, "text": "concurrent logical framework CLF"}, {"st": 10, "ed": 13, "text": "logical framework LF"}, {"st": 35, "ed": 37, "text": "such languages"}, {"st": 60, "ed": 62, "text": "CLF specifications"}, {"st": 74, "ed": 76, "text": "small language"}, {"st": 78, "ed": 80, "text": "parallel semantics"}]
[{"st": 0, "ed": 2, "text": "Formal Analysis"}, {"st": 3, "ed": 5, "text": "Soft Errors"}]
[{"st": 4, "ed": 6, "text": "soft errors"}, {"st": 7, "ed": 9, "text": "electronic circuits"}, {"st": 14, "ed": 16, "text": "computer simulations"}, {"st": 17, "ed": 19, "text": "Computer simulations"}, {"st": 28, "ed": 32, "text": "approximate real number representations"}, {"st": 33, "ed": 36, "text": "pseudo random numbers"}, {"st": 49, "ed": 51, "text": "critical applications"}, {"st": 61, "ed": 64, "text": "order logic theorem"}, {"st": 72, "ed": 74, "text": "soft errors"}, {"st": 75, "ed": 77, "text": "electronic circuits"}, {"st": 79, "ed": 81, "text": "developed infrastructure"}, {"st": 83, "ed": 87, "text": "continuous random variable pairs"}, {"st": 89, "ed": 92, "text": "Cumulative Distribution Function"}, {"st": 97, "ed": 100, "text": "independent standard uniform"}, {"st": 101, "ed": 104, "text": "Gaussian random variables"}, {"st": 116, "ed": 118, "text": "soft errors"}, {"st": 121, "ed": 128, "text": "dynamic random access memory sense amplifier circuits"}]
[{"st": 1, "ed": 3, "text": "normalization time"}, {"st": 4, "ed": 6, "text": "intersection types"}]
[{"st": 2, "ed": 5, "text": "idempotent intersection types"}, {"st": 21, "ed": 23, "text": "reduction sequence"}, {"st": 25, "ed": 27, "text": "lambda term"}]
[{"st": 1, "ed": 3, "text": "formal proofs"}, {"st": 4, "ed": 6, "text": "mathematical proofs"}, {"st": 10, "ed": 12, "text": "incremental way"}, {"st": 17, "ed": 20, "text": "order decision procedures"}]
[{"st": 4, "ed": 6, "text": "new version"}, {"st": 10, "ed": 12, "text": "Inductive Constructions"}, {"st": 18, "ed": 21, "text": "proof assistant Coq"}, {"st": 27, "ed": 30, "text": "Congruent Inductive Constructions"}, {"st": 41, "ed": 44, "text": "order decision procedures"}, {"st": 52, "ed": 54, "text": "CIC kernel"}, {"st": 63, "ed": 66, "text": "order decision procedures"}, {"st": 77, "ed": 79, "text": "proof certificate"}, {"st": 84, "ed": 86, "text": "whole system"}, {"st": 88, "ed": 90, "text": "incremental property"}, {"st": 96, "ed": 98, "text": "certificate checkers"}, {"st": 105, "ed": 108, "text": "detailed example shows"}, {"st": 113, "ed": 115, "text": "proofs becomes"}, {"st": 120, "ed": 122, "text": "working mathematician"}]
[{"st": 0, "ed": 4, "text": "Practical Automated Partial Verification"}, {"st": 7, "ed": 9, "text": "Paradigm Real"}, {"st": 10, "ed": 12, "text": "Time Models"}]
[{"st": 6, "ed": 8, "text": "verification technique"}, {"st": 14, "ed": 16, "text": "time systems"}, {"st": 19, "ed": 21, "text": "continuous notion"}, {"st": 47, "ed": 49, "text": "technique relies"}, {"st": 54, "ed": 56, "text": "reasonable assumptions"}, {"st": 61, "ed": 64, "text": "time verification problem"}, {"st": 68, "ed": 70, "text": "time counterpart"}, {"st": 77, "ed": 79, "text": "effective way"}, {"st": 80, "ed": 83, "text": "dense / discrete"}, {"st": 84, "ed": 88, "text": "operational / descriptive dichotomies"}, {"st": 101, "ed": 104, "text": "complex critical systems"}, {"st": 115, "ed": 117, "text": "significant example"}, {"st": 120, "ed": 122, "text": "communication protocol"}, {"st": 126, "ed": 128, "text": "concurrent runs"}, {"st": 134, "ed": 136, "text": "parallel instances"}, {"st": 138, "ed": 140, "text": "Timed Automaton"}, {"st": 143, "ed": 145, "text": "synchronization rules"}, {"st": 151, "ed": 155, "text": "Metric Temporal Logic formulas"}, {"st": 161, "ed": 163, "text": "paradigm model"}, {"st": 164, "ed": 166, "text": "Verification tests"}, {"st": 172, "ed": 175, "text": "bounded validity checker"}, {"st": 177, "ed": 181, "text": "technique show consistent results"}, {"st": 182, "ed": 184, "text": "interesting performances"}]
[{"st": 4, "ed": 6, "text": "BSS Model"}, {"st": 9, "ed": 12, "text": "Light Affine Lambda"}]
[{"st": 9, "ed": 11, "text": "implicit characterization"}, {"st": 12, "ed": 14, "text": "complexity classes"}, {"st": 15, "ed": 17, "text": "Linear Logic"}, {"st": 29, "ed": 31, "text": "arbitrary ring"}, {"st": 48, "ed": 52, "text": "fixed ring structure K"}, {"st": 59, "ed": 61, "text": "light affine"}, {"st": 68, "ed": 71, "text": "Light Affine Logic"}, {"st": 74, "ed": 76, "text": "basic type"}, {"st": 85, "ed": 90, "text": "polynomial time function class FP(K"}, {"st": 93, "ed": 95, "text": "typed term"}, {"st": 99, "ed": 101, "text": "polynomial time"}, {"st": 104, "ed": 108, "text": "polynomial time BSS machine"}]
[{"st": 3, "ed": 7, "text": "contextual logic program refinement"}]
[{"st": 1, "ed": 3, "text": "refinement calculus"}, {"st": 4, "ed": 6, "text": "logic programs"}, {"st": 11, "ed": 13, "text": "logic programs"}, {"st": 23, "ed": 25, "text": "spectrum language"}, {"st": 35, "ed": 37, "text": "refinement relation"}, {"st": 42, "ed": 44, "text": "correct implementation"}, {"st": 55, "ed": 57, "text": "contextual refinement"}, {"st": 58, "ed": 60, "text": "Contextual refinement"}, {"st": 62, "ed": 64, "text": "refinement process"}, {"st": 85, "ed": 87, "text": "free variables"}, {"st": 94, "ed": 96, "text": "module refinement"}, {"st": 108, "ed": 111, "text": "common data type"}, {"st": 116, "ed": 119, "text": "specification module A"}, {"st": 121, "ed": 124, "text": "implementation module C"}, {"st": 139, "ed": 141, "text": "corresponding procedures"}, {"st": 148, "ed": 150, "text": "module refinement"}, {"st": 158, "ed": 160, "text": "implementation module"}, {"st": 162, "ed": 164, "text": "specification module"}, {"st": 168, "ed": 170, "text": "module refinement"}, {"st": 172, "ed": 174, "text": "refinement calculus"}, {"st": 187, "ed": 189, "text": "unified framework"}]
[]
[{"st": 3, "ed": 7, "text": "normed Basic Process Algebra"}, {"st": 18, "ed": 20, "text": "previous papers"}, {"st": 22, "ed": 24, "text": "explicit proof"}, {"st": 46, "ed": 49, "text": "new complete proof"}, {"st": 57, "ed": 59, "text": "normed BPA"}, {"st": 64, "ed": 67, "text": "associate regularity problem"}, {"st": 68, "ed": 70, "text": "normed BPA"}, {"st": 80, "ed": 82, "text": "previous P"}, {"st": 85, "ed": 87, "text": "NEXPTIME result"}]
